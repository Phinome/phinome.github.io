<h1 id="UglifyJS_2">UglifyJS 2</h1><p><a href="https://travis-ci.org/mishoo/UglifyJS2"><img src="https://travis-ci.org/mishoo/UglifyJS2.svg" alt="Build Status"></a></p>
<p>UglifyJS is a JavaScript parser, minifier, compressor or beautifier toolkit.</p>
<p>This page documents the command line utility.  For<br><a href="http://lisperator.net/uglifyjs/">API and internals documentation see my website</a>.<br>There’s also an<br><a href="http://lisperator.net/uglifyjs/#demo">in-browser online demo</a> (for Firefox,<br>Chrome and probably Safari).</p>
<h2 id="Install">Install</h2><p>First make sure you have installed the latest version of <a href="http://nodejs.org/">node.js</a><br>(You may need to restart your computer after this step).</p>
<p>From NPM for use as a command line app:</p>
<pre><code>npm <span class="keyword">install</span> uglify-js -g
</code></pre><p>From NPM for programmatic use:</p>
<pre><code>npm <span class="keyword">install</span> uglify-js
</code></pre><p>From Git:</p>
<pre><code>git clone gi<span class="variable">t:</span>//github.<span class="keyword">com</span>/mishoo/UglifyJS2.git
<span class="keyword">cd</span> UglifyJS2
npm link .
</code></pre><h2 id="Usage">Usage</h2><pre><code>uglifyjs [<span class="built_in">input</span> <span class="keyword">files</span>] [<span class="keyword">options</span>]
</code></pre><p>UglifyJS2 can take multiple input files.  It’s recommended that you pass the<br>input files first, then pass the options.  UglifyJS will parse input files<br>in sequence and apply any compression options.  The files are parsed in the<br>same global scope, that is, a reference from a file to some<br>variable/function declared in another file will be matched properly.</p>
<p>If you want to read from STDIN instead, pass a single dash instead of input<br>files.</p>
<p>If you wish to pass your options before the input files, separate the two with<br>a double dash to prevent input files being used as option arguments:</p>
<pre><code><span class="comment">uglifyjs</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">compress</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">mangle</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">input</span><span class="string">.</span><span class="comment">js</span>
</code></pre><p>The available options are:</p>
<pre><code><span class="comment">--source-map                  Specify an output file where to generate source</span>
                              map.
<span class="comment">--source-map-root             The path to the original source to be included</span>
                              <span class="operator">in</span> <span class="operator">the</span> source map.
<span class="comment">--source-map-url              The path to the source map to be added in //#</span>
                              sourceMappingURL.  Defaults <span class="built_in">to</span> <span class="operator">the</span> <span class="built_in">value</span> passed
                              <span class="operator">with</span> <span class="comment">--source-map.</span>
<span class="comment">--source-map-include-sources  Pass this flag if you want to include the</span>
                              content <span class="operator">of</span> source <span class="built_in">files</span> <span class="operator">in</span> <span class="operator">the</span> source map <span class="keyword">as</span>
                              sourcesContent property.
<span class="comment">--in-source-map               Input source map, useful if you're compressing</span>
                              JS that was generated <span class="built_in">from</span> some other original
                              code.
<span class="comment">--screw-ie8                   Pass this flag if you don't care about full</span>
                              compliance <span class="operator">with</span> Internet Explorer <span class="number">6</span>-<span class="number">8</span> quirks
                              (<span class="keyword">by</span> default UglifyJS will <span class="keyword">try</span> <span class="built_in">to</span> be IE-proof).
<span class="comment">--expr                        Parse a single expression, rather than a</span>
                              program (<span class="keyword">for</span> parsing JSON)
-p, <span class="comment">--prefix                  Skip prefix for original filenames that appear</span>
                              <span class="operator">in</span> source maps. For example -p <span class="number">3</span> will drop <span class="number">3</span>
                              <span class="built_in">directories</span> <span class="built_in">from</span> <span class="built_in">file</span> names <span class="operator">and</span> ensure they are
                              <span class="built_in">relative</span> paths. You can also specify -p
                              <span class="built_in">relative</span>, which will make UglifyJS figure out
                              itself <span class="operator">the</span> <span class="built_in">relative</span> paths between original
                              sources, <span class="operator">the</span> source map <span class="operator">and</span> <span class="operator">the</span> output <span class="built_in">file</span>.
-o, <span class="comment">--output                  Output file (default STDOUT).</span>
-b, <span class="comment">--beautify                Beautify output/specify output options.</span>
-m, <span class="comment">--mangle                  Mangle names/pass mangler options.</span>
-r, <span class="comment">--reserved                Reserved names to exclude from mangling.</span>
-c, <span class="comment">--compress                Enable compressor/pass compressor options. Pass</span>
                              options like -c
                              hoist_vars=<span class="constant">false</span>,if_return=<span class="constant">false</span>. Use -c <span class="operator">with</span>
                              no argument <span class="built_in">to</span> use <span class="operator">the</span> default compression
                              options.
-d, <span class="comment">--define                  Global definitions</span>
-e, <span class="comment">--enclose                 Embed everything in a big function, with a</span>
                              configurable parameter/argument list.
<span class="comment">--comments                    Preserve copyright comments in the output. By</span>
                              default this works like Google Closure, keeping
                              JSDoc-style comments that contain <span class="string">"@license"</span> <span class="operator">or</span>
                              <span class="string">"@preserve"</span>. You can optionally pass <span class="constant">one</span> <span class="operator">of</span> <span class="operator">the</span>
                              following arguments <span class="built_in">to</span> this flag:
                              - <span class="string">"all"</span> <span class="built_in">to</span> keep all comments
                              - <span class="operator">a</span> valid JS regexp (needs <span class="built_in">to</span> <span class="built_in">start</span> <span class="operator">with</span> <span class="operator">a</span>
                              slash) <span class="built_in">to</span> keep only comments that match.
                              Note that currently <span class="operator">not</span> *all* comments can be
                              kept when compression is <span class="command"><span class="keyword">on</span>, <span class="title">because</span> <span class="title">of</span> <span class="title">dead</span></span>
                              code removal <span class="operator">or</span> cascading statements <span class="keyword">into</span>
                              sequences.
<span class="comment">--preamble                    Preamble to prepend to the output.  You can use</span>
                              this <span class="built_in">to</span> insert <span class="operator">a</span> comment, <span class="keyword">for</span> example <span class="keyword">for</span>
                              licensing information.  This will <span class="operator">not</span> be
                              parsed, but <span class="operator">the</span> source map will adjust <span class="keyword">for</span> its
                              presence.
<span class="comment">--stats                       Display operations run time on STDERR.</span>
<span class="comment">--acorn                       Use Acorn for parsing.</span>
<span class="comment">--spidermonkey                Assume input files are SpiderMonkey AST format</span>
                              (<span class="keyword">as</span> JSON).
<span class="comment">--self                        Build itself (UglifyJS2) as a library (implies</span>
                              <span class="comment">--wrap=UglifyJS --export-all)</span>
<span class="comment">--wrap                        Embed everything in a big function, making the</span>
                              “exports” <span class="operator">and</span> “<span class="built_in">global</span>” variables available. You
                              need <span class="built_in">to</span> pass <span class="operator">an</span> argument <span class="built_in">to</span> this option <span class="built_in">to</span>
                              specify <span class="operator">the</span> name that your module will take
                              when included <span class="operator">in</span>, say, <span class="operator">a</span> browser.
<span class="comment">--export-all                  Only used when --wrap, this tells UglifyJS to</span>
                              <span class="built_in">add</span> code <span class="built_in">to</span> automatically export all <span class="built_in">globals</span>.
<span class="comment">--lint                        Display some scope warnings</span>
-v, <span class="comment">--verbose                 Verbose</span>
-V, <span class="comment">--version                 Print version number and exit.</span>
<span class="comment">--noerr                       Don't throw an error for unknown options in -c,</span>
                              -b <span class="operator">or</span> -m.
<span class="comment">--bare-returns                Allow return outside of functions.  Useful when</span>
                              minifying CommonJS modules.
<span class="comment">--keep-fnames                 Do not mangle/drop function names.  Useful for</span>
                              code relying <span class="command"><span class="keyword">on</span> <span class="title">Function</span>.<span class="title">prototype</span>.<span class="title">name</span>.</span>
<span class="comment">--reserved-file               File containing reserved names</span>
<span class="comment">--reserve-domprops            Make (most?) DOM properties reserved for</span>
                              <span class="comment">--mangle-props</span>
<span class="comment">--mangle-props                Mangle property names</span>
<span class="comment">--name-cache                  File to hold mangled names mappings</span>
</code></pre><p>Specify <code>--output</code> (<code>-o</code>) to declare the output file.  Otherwise the output<br>goes to STDOUT.</p>
<h2 id="Source_map_options">Source map options</h2><p>UglifyJS2 can generate a source map file, which is highly useful for<br>debugging your compressed JavaScript.  To get a source map, pass<br><code>--source-map output.js.map</code> (full path to the file where you want the<br>source map dumped).</p>
<p>Additionally you might need <code>--source-map-root</code> to pass the URL where the<br>original files can be found.  In case you are passing full paths to input<br>files to UglifyJS, you can use <code>--prefix</code> (<code>-p</code>) to specify the number of<br>directories to drop from the path prefix when declaring files in the source<br>map.</p>
<p>For example:</p>
<pre><code>uglifyjs /home/doe/work/foo/src/js/file1<span class="class">.js</span> \
         /home/doe/work/foo/src/js/file2<span class="class">.js</span> \
         -o foo<span class="class">.min</span><span class="class">.js</span> \
         --source-map foo<span class="class">.min</span><span class="class">.js</span><span class="class">.map</span> \
         --source-map-root http:<span class="comment">//foo.com/src \</span>
         -<span class="tag">p</span> <span class="number">5</span> -c -m
</code></pre><p>The above will compress and mangle <code>file1.js</code> and <code>file2.js</code>, will drop the<br>output in <code>foo.min.js</code> and the source map in <code>foo.min.js.map</code>.  The source<br>mapping will refer to <code>http://foo.com/src/js/file1.js</code> and<br><code>http://foo.com/src/js/file2.js</code> (in fact it will list <code>http://foo.com/src</code><br>as the source map root, and the original files as <code>js/file1.js</code> and<br><code>js/file2.js</code>).</p>
<h3 id="Composed_source_map">Composed source map</h3><p>When you’re compressing JS code that was output by a compiler such as<br>CoffeeScript, mapping to the JS code won’t be too helpful.  Instead, you’d<br>like to map back to the original code (i.e. CoffeeScript).  UglifyJS has an<br>option to take an input source map.  Assuming you have a mapping from<br>CoffeeScript → compiled JS, UglifyJS can generate a map from CoffeeScript →<br>compressed JS by mapping every token in the compiled JS to its original<br>location.</p>
<p>To use this feature you need to pass <code>--in-source-map
/path/to/input/source.map</code>.  Normally the input source map should also point<br>to the file containing the generated JS, so if that’s correct you can omit<br>input files from the command line.</p>
<h2 id="Mangler_options">Mangler options</h2><p>To enable the mangler you need to pass <code>--mangle</code> (<code>-m</code>).  The following<br>(comma-separated) options are supported:</p>
<ul>
<li><p><code>sort</code> — to assign shorter names to most frequently used variables.  This<br>saves a few hundred bytes on jQuery before gzip, but the output is<br><em>bigger</em> after gzip (and seems to happen for other libraries I tried it<br>on) therefore it’s not enabled by default.</p>
</li>
<li><p><code>toplevel</code> — mangle names declared in the toplevel scope (disabled by<br>default).</p>
</li>
<li><p><code>eval</code> — mangle names visible in scopes where <code>eval</code> or <code>with</code> are used<br>(disabled by default).</p>
</li>
</ul>
<p>When mangling is enabled but you want to prevent certain names from being<br>mangled, you can declare those names with <code>--reserved</code> (<code>-r</code>) — pass a<br>comma-separated list of names.  For example:</p>
<pre><code>uglifyjs <span class="attribute">...</span> <span class="attribute">-m</span> <span class="attribute">-r</span> <span class="string">'$,require,exports'</span>
</code></pre><p>to prevent the <code>require</code>, <code>exports</code> and <code>$</code> names from being changed.</p>
<h3 id="Mangling_property_names_(-mangle-props)">Mangling property names (<code>--mangle-props</code>)</h3><p><strong>Note:</strong> this will probably break your code.  Mangling property names is a<br>separate step, different from variable name mangling.  Pass<br><code>--mangle-props</code>.  It will mangle all properties that are seen in some<br>object literal, or that are assigned to.  For example:</p>
<pre><code class="js"><span class="keyword">var</span> x = {
  foo: <span class="number">1</span>
};

x.bar = <span class="number">2</span>;
x[<span class="string">"baz"</span>] = <span class="number">3</span>;
x[condition ? <span class="string">"moo"</span> : <span class="string">"boo"</span>] = <span class="number">4</span>;
<span class="built_in">console</span>.log(x.something());
</code></pre>
<p>In the above code, <code>foo</code>, <code>bar</code>, <code>baz</code>, <code>moo</code> and <code>boo</code> will be replaced<br>with single characters, while <code>something()</code> will be left as is.</p>
<p>In order for this to be of any use, we should avoid mangling standard JS<br>names.  For instance, if your code would contain <code>x.length = 10</code>, then<br><code>length</code> becomes a candidate for mangling and it will be mangled throughout<br>the code, regardless if it’s being used as part of your own objects or<br>accessing an array’s length.  To avoid that, you can use <code>--reserved-file</code><br>to pass a filename that should contain the names to be excluded from<br>mangling.  This file can be used both for excluding variable names and<br>property names.  It could look like this, for example:</p>
<pre><code class="js">{
  <span class="string">"vars"</span>: [ <span class="string">"define"</span>, <span class="string">"require"</span>, ... ],
  <span class="string">"props"</span>: [ <span class="string">"length"</span>, <span class="string">"prototype"</span>, ... ]
}
</code></pre>
<p><code>--reserved-file</code> can be an array of file names (either a single<br>comma-separated argument, or you can pass multiple <code>--reserved-file</code><br>arguments) — in this case it will exclude names from all those files.</p>
<p>A default exclusion file is provided in <code>tools/domprops.json</code> which should<br>cover most standard JS and DOM properties defined in various browsers.  Pass<br><code>--reserve-domprops</code> to read that in.</p>
<p>When you compress multiple files using this option, in order for them to<br>work together in the end we need to ensure somehow that one property gets<br>mangled to the same name in all of them.  For this, pass <code>--name-cache
filename.json</code> and UglifyJS will maintain these mappings in a file which can<br>then be reused.  It should be initially empty.  Example:</p>
<pre><code><span class="comment">rm</span> <span class="literal">-</span><span class="comment">f</span> <span class="comment">/tmp/cache</span><span class="string">.</span><span class="comment">json</span>  <span class="comment">#</span> <span class="comment">start</span> <span class="comment">fresh</span>
<span class="comment">uglifyjs</span> <span class="comment">file1</span><span class="string">.</span><span class="comment">js</span> <span class="comment">file2</span><span class="string">.</span><span class="comment">js</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">mangle</span><span class="literal">-</span><span class="comment">props</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">name</span><span class="literal">-</span><span class="comment">cache</span> <span class="comment">/tmp/cache</span><span class="string">.</span><span class="comment">json</span> <span class="literal">-</span><span class="comment">o</span> <span class="comment">part1</span><span class="string">.</span><span class="comment">js</span>
<span class="comment">uglifyjs</span> <span class="comment">file3</span><span class="string">.</span><span class="comment">js</span> <span class="comment">file4</span><span class="string">.</span><span class="comment">js</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">mangle</span><span class="literal">-</span><span class="comment">props</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">name</span><span class="literal">-</span><span class="comment">cache</span> <span class="comment">/tmp/cache</span><span class="string">.</span><span class="comment">json</span> <span class="literal">-</span><span class="comment">o</span> <span class="comment">part2</span><span class="string">.</span><span class="comment">js</span>
</code></pre><p>Now, <code>part1.js</code> and <code>part2.js</code> will be consistent with each other in terms<br>of mangled property names.</p>
<p>Using the name cache is not necessary if you compress all your files in a<br>single call to UglifyJS.</p>
<h2 id="Compressor_options">Compressor options</h2><p>You need to pass <code>--compress</code> (<code>-c</code>) to enable the compressor.  Optionally<br>you can pass a comma-separated list of options.  Options are in the form<br><code>foo=bar</code>, or just <code>foo</code> (the latter implies a boolean option that you want<br>to set <code>true</code>; it’s effectively a shortcut for <code>foo=true</code>).</p>
<ul>
<li><p><code>sequences</code> — join consecutive simple statements using the comma operator</p>
</li>
<li><p><code>properties</code> — rewrite property access using the dot notation, for<br>example <code>foo[&quot;bar&quot;] → foo.bar</code></p>
</li>
<li><p><code>dead_code</code> — remove unreachable code</p>
</li>
<li><p><code>drop_debugger</code> — remove <code>debugger;</code> statements</p>
</li>
<li><p><code>unsafe</code> (default: false) — apply “unsafe” transformations (discussion below)</p>
</li>
<li><p><code>conditionals</code> — apply optimizations for <code>if</code>-s and conditional<br>expressions</p>
</li>
<li><p><code>comparisons</code> — apply certain optimizations to binary nodes, for example:<br><code>!(a &lt;= b) → a &gt; b</code> (only when <code>unsafe</code>), attempts to negate binary nodes,<br>e.g. <code>a = !b &amp;&amp; !c &amp;&amp; !d &amp;&amp; !e → a=!(b||c||d||e)</code> etc.</p>
</li>
<li><p><code>evaluate</code> — attempt to evaluate constant expressions</p>
</li>
<li><p><code>booleans</code> — various optimizations for boolean context, for example <code>!!a
? b : c → a ? b : c</code></p>
</li>
<li><p><code>loops</code> — optimizations for <code>do</code>, <code>while</code> and <code>for</code> loops when we can<br>statically determine the condition</p>
</li>
<li><p><code>unused</code> — drop unreferenced functions and variables</p>
</li>
<li><p><code>hoist_funs</code> — hoist function declarations</p>
</li>
<li><p><code>hoist_vars</code> (default: false) — hoist <code>var</code> declarations (this is <code>false</code><br>by default because it seems to increase the size of the output in general)</p>
</li>
<li><p><code>if_return</code> — optimizations for if/return and if/continue</p>
</li>
<li><p><code>join_vars</code> — join consecutive <code>var</code> statements</p>
</li>
<li><p><code>cascade</code> — small optimization for sequences, transform <code>x, x</code> into <code>x</code><br>and <code>x = something(), x</code> into <code>x = something()</code></p>
</li>
<li><p><code>warnings</code> — display warnings when dropping unreachable code or unused<br>declarations etc.</p>
</li>
<li><p><code>negate_iife</code> — negate “Immediately-Called Function Expressions”<br>where the return value is discarded, to avoid the parens that the<br>code generator would insert.</p>
</li>
<li><p><code>pure_getters</code> — the default is <code>false</code>.  If you pass <code>true</code> for<br>this, UglifyJS will assume that object property access<br>(e.g. <code>foo.bar</code> or <code>foo[&quot;bar&quot;]</code>) doesn’t have any side effects.</p>
</li>
<li><p><code>pure_funcs</code> — default <code>null</code>.  You can pass an array of names and<br>UglifyJS will assume that those functions do not produce side<br>effects.  DANGER: will not check if the name is redefined in scope.<br>An example case here, for instance <code>var q = Math.floor(a/b)</code>.  If<br>variable <code>q</code> is not used elsewhere, UglifyJS will drop it, but will<br>still keep the <code>Math.floor(a/b)</code>, not knowing what it does.  You can<br>pass <code>pure_funcs: [ &#39;Math.floor&#39; ]</code> to let it know that this<br>function won’t produce any side effect, in which case the whole<br>statement would get discarded.  The current implementation adds some<br>overhead (compression will be slower).</p>
</li>
<li><p><code>drop_console</code> — default <code>false</code>.  Pass <code>true</code> to discard calls to<br><code>console.*</code> functions.</p>
</li>
<li><p><code>keep_fargs</code> — default <code>false</code>.  Pass <code>true</code> to prevent the<br>compressor from discarding unused function arguments.  You need this<br>for code which relies on <code>Function.length</code>.</p>
</li>
</ul>
<h3 id="The_unsafe_option">The <code>unsafe</code> option</h3><p>It enables some transformations that <em>might</em> break code logic in certain<br>contrived cases, but should be fine for most code.  You might want to try it<br>on your own code, it should reduce the minified size.  Here’s what happens<br>when this flag is on:</p>
<ul>
<li><code>new Array(1, 2, 3)</code> or <code>Array(1, 2, 3)</code> → <code>[ 1, 2, 3 ]</code></li>
<li><code>new Object()</code> → <code>{}</code></li>
<li><code>String(exp)</code> or <code>exp.toString()</code> → <code>&quot;&quot; + exp</code></li>
<li><code>new Object/RegExp/Function/Error/Array (...)</code> → we discard the <code>new</code></li>
<li><code>typeof foo == &quot;undefined&quot;</code> → <code>foo === void 0</code></li>
<li><code>void 0</code> → <code>undefined</code> (if there is a variable named “undefined” in<br>scope; we do it because the variable name will be mangled, typically<br>reduced to a single character)</li>
<li>discards unused function arguments (affects <code>function.length</code>)</li>
</ul>
<h3 id="Conditional_compilation">Conditional compilation</h3><p>You can use the <code>--define</code> (<code>-d</code>) switch in order to declare global<br>variables that UglifyJS will assume to be constants (unless defined in<br>scope).  For example if you pass <code>--define DEBUG=false</code> then, coupled with<br>dead code removal UglifyJS will discard the following from the output:</p>
<pre><code class="javascript"><span class="keyword">if</span> (DEBUG) {
    <span class="built_in">console</span>.log(<span class="string">"debug stuff"</span>);
}
</code></pre>
<p>UglifyJS will warn about the condition being always false and about dropping<br>unreachable code; for now there is no option to turn off only this specific<br>warning, you can pass <code>warnings=false</code> to turn off <em>all</em> warnings.</p>
<p>Another way of doing that is to declare your globals as constants in a<br>separate file and include it into the build.  For example you can have a<br><code>build/defines.js</code> file with the following:</p>
<pre><code class="javascript"><span class="keyword">const</span> DEBUG = <span class="literal">false</span>;
<span class="keyword">const</span> PRODUCTION = <span class="literal">true</span>;
<span class="comment">// etc.</span>
</code></pre>
<p>and build your code like this:</p>
<pre><code>uglifyjs build/defines<span class="class">.js</span> js/foo<span class="class">.js</span> js/bar<span class="class">.js</span>... -c
</code></pre><p>UglifyJS will notice the constants and, since they cannot be altered, it<br>will evaluate references to them to the value itself and drop unreachable<br>code as usual.  The possible downside of this approach is that the build<br>will contain the <code>const</code> declarations.</p>
<p><a name="codegen-options"></a></p>
<h2 id="Beautifier_options">Beautifier options</h2><p>The code generator tries to output shortest code possible by default.  In<br>case you want beautified output, pass <code>--beautify</code> (<code>-b</code>).  Optionally you<br>can pass additional arguments that control the code output:</p>
<ul>
<li><code>beautify</code> (default <code>true</code>) — whether to actually beautify the output.<br>Passing <code>-b</code> will set this to true, but you might need to pass <code>-b</code> even<br>when you want to generate minified code, in order to specify additional<br>arguments, so you can use <code>-b beautify=false</code> to override it.</li>
<li><code>indent-level</code> (default 4)</li>
<li><code>indent-start</code> (default 0) — prefix all lines by that many spaces</li>
<li><code>quote-keys</code> (default <code>false</code>) — pass <code>true</code> to quote all keys in literal<br>objects</li>
<li><code>space-colon</code> (default <code>true</code>) — insert a space after the colon signs</li>
<li><code>ascii-only</code> (default <code>false</code>) — escape Unicode characters in strings and<br>regexps</li>
<li><code>inline-script</code> (default <code>false</code>) — escape the slash in occurrences of<br><code>&lt;/script</code> in strings</li>
<li><code>width</code> (default 80) — only takes effect when beautification is on, this<br>specifies an (orientative) line width that the beautifier will try to<br>obey.  It refers to the width of the line text (excluding indentation).<br>It doesn’t work very well currently, but it does make the code generated<br>by UglifyJS more readable.</li>
<li><code>max-line-len</code> (default 32000) — maximum line length (for uglified code)</li>
<li><code>bracketize</code> (default <code>false</code>) — always insert brackets in <code>if</code>, <code>for</code>,<br><code>do</code>, <code>while</code> or <code>with</code> statements, even if their body is a single<br>statement.</li>
<li><code>semicolons</code> (default <code>true</code>) — separate statements with semicolons.  If<br>you pass <code>false</code> then whenever possible we will use a newline instead of a<br>semicolon, leading to more readable output of uglified code (size before<br>gzip could be smaller; size after gzip insignificantly larger).</li>
<li><code>preamble</code> (default <code>null</code>) — when passed it must be a string and<br>it will be prepended to the output literally.  The source map will<br>adjust for this text.  Can be used to insert a comment containing<br>licensing information, for example.</li>
<li><code>quote_style</code> (default <code>0</code>) — preferred quote style for strings (affects<br>quoted property names and directives as well):<ul>
<li><code>0</code> — prefers double quotes, switches to single quotes when there are<br>more double quotes in the string itself.</li>
<li><code>1</code> — always use single quotes</li>
<li><code>2</code> — always use double quotes</li>
<li><code>3</code> — always use the original quotes</li>
</ul>
</li>
</ul>
<h3 id="Keeping_copyright_notices_or_other_comments">Keeping copyright notices or other comments</h3><p>You can pass <code>--comments</code> to retain certain comments in the output.  By<br>default it will keep JSDoc-style comments that contain “@preserve”,<br>“@license” or “@cc_on” (conditional compilation for IE).  You can pass<br><code>--comments all</code> to keep all the comments, or a valid JavaScript regexp to<br>keep only comments that match this regexp.  For example <code>--comments
&#39;/foo|bar/&#39;</code> will keep only comments that contain “foo” or “bar”.</p>
<p>Note, however, that there might be situations where comments are lost.  For<br>example:</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>{
    <span class="comment">/** @preserve Foo Bar */</span>
    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>{
      <span class="comment">// this function is never called</span>
    }
    <span class="keyword">return</span> something();
}
</code></pre>
<p>Even though it has “@preserve”, the comment will be lost because the inner<br>function <code>g</code> (which is the AST node to which the comment is attached to) is<br>discarded by the compressor as not referenced.</p>
<p>The safest comments where to place copyright information (or other info that<br>needs to be kept in the output) are comments attached to toplevel nodes.</p>
<h2 id="Support_for_the_SpiderMonkey_AST">Support for the SpiderMonkey AST</h2><p>UglifyJS2 has its own abstract syntax tree format; for<br><a href="http://lisperator.net/blog/uglifyjs-why-not-switching-to-spidermonkey-ast/">practical reasons</a><br>we can’t easily change to using the SpiderMonkey AST internally.  However,<br>UglifyJS now has a converter which can import a SpiderMonkey AST.</p>
<p>For example <a href="https://github.com/marijnh/acorn">Acorn</a> is a super-fast parser that produces a<br>SpiderMonkey AST.  It has a small CLI utility that parses one file and dumps<br>the AST in JSON on the standard output.  To use UglifyJS to mangle and<br>compress that:</p>
<pre><code>acorn <span class="type">file</span>.js | uglifyjs <span class="comment">--spidermonkey -m -c</span>
</code></pre><p>The <code>--spidermonkey</code> option tells UglifyJS that all input files are not<br>JavaScript, but JS code described in SpiderMonkey AST in JSON.  Therefore we<br>don’t use our own parser in this case, but just transform that AST into our<br>internal AST.</p>
<h3 id="Use_Acorn_for_parsing">Use Acorn for parsing</h3><p>More for fun, I added the <code>--acorn</code> option which will use Acorn to do all<br>the parsing.  If you pass this option, UglifyJS will <code>require(&quot;acorn&quot;)</code>.</p>
<p>Acorn is really fast (e.g. 250ms instead of 380ms on some 650K code), but<br>converting the SpiderMonkey tree that Acorn produces takes another 150ms so<br>in total it’s a bit more than just using UglifyJS’s own parser.</p>
<h3 id="Using_UglifyJS_to_transform_SpiderMonkey_AST">Using UglifyJS to transform SpiderMonkey AST</h3><p>Now you can use UglifyJS as any other intermediate tool for transforming<br>JavaScript ASTs in SpiderMonkey format.</p>
<p>Example:</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">uglify</span>(<span class="params">ast, options, mangle</span>) </span>{
  <span class="comment">// Conversion from SpiderMonkey AST to internal format</span>
  <span class="keyword">var</span> uAST = UglifyJS.AST_Node.from_mozilla_ast(ast);

  <span class="comment">// Compression</span>
  uAST.figure_out_scope();
  uAST = uAST.transform(UglifyJS.Compressor(options));

  <span class="comment">// Mangling (optional)</span>
  <span class="keyword">if</span> (mangle) {
    uAST.figure_out_scope();
    uAST.compute_char_frequency();
    uAST.mangle_names();
  }

  <span class="comment">// Back-conversion to SpiderMonkey AST</span>
  <span class="keyword">return</span> uAST.to_mozilla_ast();
}
</code></pre>
<p>Check out<br><a href="http://rreverser.com/using-mozilla-ast-with-uglifyjs/">original blog post</a><br>for details.</p>
<h2 id="API_Reference">API Reference</h2><p>Assuming installation via NPM, you can load UglifyJS in your application<br>like this:</p>
<pre><code class="javascript"><span class="keyword">var</span> UglifyJS = <span class="built_in">require</span>(<span class="string">"uglify-js"</span>);
</code></pre>
<p>It exports a lot of names, but I’ll discuss here the basics that are needed<br>for parsing, mangling and compressing a piece of code.  The sequence is (1)<br>parse, (2) compress, (3) mangle, (4) generate output code.</p>
<h3 id="The_simple_way">The simple way</h3><p>There’s a single toplevel function which combines all the steps.  If you<br>don’t need additional customization, you might want to go with <code>minify</code>.<br>Example:</p>
<pre><code class="javascript"><span class="keyword">var</span> result = UglifyJS.minify(<span class="string">"/path/to/file.js"</span>);
<span class="built_in">console</span>.log(result.code); <span class="comment">// minified output</span>
<span class="comment">// if you need to pass code instead of file name</span>
<span class="keyword">var</span> result = UglifyJS.minify(<span class="string">"var b = function () {};"</span>, {fromString: <span class="literal">true</span>});
</code></pre>
<p>You can also compress multiple files:</p>
<pre><code class="javascript"><span class="keyword">var</span> result = UglifyJS.minify([ <span class="string">"file1.js"</span>, <span class="string">"file2.js"</span>, <span class="string">"file3.js"</span> ]);
<span class="built_in">console</span>.log(result.code);
</code></pre>
<p>To generate a source map:</p>
<pre><code class="javascript"><span class="keyword">var</span> result = UglifyJS.minify([ <span class="string">"file1.js"</span>, <span class="string">"file2.js"</span>, <span class="string">"file3.js"</span> ], {
    outSourceMap: <span class="string">"out.js.map"</span>
});
<span class="built_in">console</span>.log(result.code); <span class="comment">// minified output</span>
<span class="built_in">console</span>.log(result.map);
</code></pre>
<p>Note that the source map is not saved in a file, it’s just returned in<br><code>result.map</code>.  The value passed for <code>outSourceMap</code> is only used to set the<br><code>file</code> attribute in the source map (see <a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit">the spec</a>).</p>
<p>You can also specify sourceRoot property to be included in source map:</p>
<pre><code class="javascript"><span class="keyword">var</span> result = UglifyJS.minify([ <span class="string">"file1.js"</span>, <span class="string">"file2.js"</span>, <span class="string">"file3.js"</span> ], {
    outSourceMap: <span class="string">"out.js.map"</span>,
    sourceRoot: <span class="string">"http://example.com/src"</span>
});
</code></pre>
<p>If you’re compressing compiled JavaScript and have a source map for it, you<br>can use the <code>inSourceMap</code> argument:</p>
<pre><code class="javascript"><span class="keyword">var</span> result = UglifyJS.minify(<span class="string">"compiled.js"</span>, {
    inSourceMap: <span class="string">"compiled.js.map"</span>,
    outSourceMap: <span class="string">"minified.js.map"</span>
});
<span class="comment">// same as before, it returns `code` and `map`</span>
</code></pre>
<p>If your input source map is not in a file, you can pass it in as an object<br>using the <code>inSourceMap</code> argument:</p>
<pre><code class="javascript"><span class="keyword">var</span> result = UglifyJS.minify(<span class="string">"compiled.js"</span>, {
    inSourceMap: <span class="built_in">JSON</span>.parse(my_source_map_string),
    outSourceMap: <span class="string">"minified.js.map"</span>
});
</code></pre>
<p>The <code>inSourceMap</code> is only used if you also request <code>outSourceMap</code> (it makes<br>no sense otherwise).</p>
<p>Other options:</p>
<ul>
<li><p><code>warnings</code> (default <code>false</code>) — pass <code>true</code> to display compressor warnings.</p>
</li>
<li><p><code>fromString</code> (default <code>false</code>) — if you pass <code>true</code> then you can pass<br>JavaScript source code, rather than file names.</p>
</li>
<li><p><code>mangle</code> — pass <code>false</code> to skip mangling names.</p>
</li>
<li><p><code>output</code> (default <code>null</code>) — pass an object if you wish to specify<br>additional <a href="http://lisperator.net/uglifyjs/codegen">output options</a>.  The defaults are optimized<br>for best compression.</p>
</li>
<li><p><code>compress</code> (default <code>{}</code>) — pass <code>false</code> to skip compressing entirely.<br>Pass an object to specify custom <a href="http://lisperator.net/uglifyjs/compress">compressor options</a>.</p>
</li>
</ul>
<p>We could add more options to <code>UglifyJS.minify</code> — if you need additional<br>functionality please suggest!</p>
<h3 id="The_hard_way">The hard way</h3><p>Following there’s more detailed API info, in case the <code>minify</code> function is<br>too simple for your needs.</p>
<h4 id="The_parser">The parser</h4><pre><code class="javascript"><span class="keyword">var</span> toplevel_ast = UglifyJS.parse(code, options);
</code></pre>
<p><code>options</code> is optional and if present it must be an object.  The following<br>properties are available:</p>
<ul>
<li><code>strict</code> — disable automatic semicolon insertion and support for trailing<br>comma in arrays and objects</li>
<li><code>filename</code> — the name of the file where this code is coming from</li>
<li><code>toplevel</code> — a <code>toplevel</code> node (as returned by a previous invocation of<br><code>parse</code>)</li>
</ul>
<p>The last two options are useful when you’d like to minify multiple files and<br>get a single file as the output and a proper source map.  Our CLI tool does<br>something like this:</p>
<pre><code class="javascript"><span class="keyword">var</span> toplevel = <span class="literal">null</span>;
files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>{
    <span class="keyword">var</span> code = fs.readFileSync(file, <span class="string">"utf8"</span>);
    toplevel = UglifyJS.parse(code, {
        filename: file,
        toplevel: toplevel
    });
});
</code></pre>
<p>After this, we have in <code>toplevel</code> a big AST containing all our files, with<br>each token having proper information about where it came from.</p>
<h4 id="Scope_information">Scope information</h4><p>UglifyJS contains a scope analyzer that you need to call manually before<br>compressing or mangling.  Basically it augments various nodes in the AST<br>with information about where is a name defined, how many times is a name<br>referenced, if it is a global or not, if a function is using <code>eval</code> or the<br><code>with</code> statement etc.  I will discuss this some place else, for now what’s<br>important to know is that you need to call the following before doing<br>anything with the tree:</p>
<pre><code class="javascript">toplevel.figure_out_scope()
</code></pre>
<h4 id="Compression">Compression</h4><p>Like this:</p>
<pre><code class="javascript"><span class="keyword">var</span> compressor = UglifyJS.Compressor(options);
<span class="keyword">var</span> compressed_ast = toplevel.transform(compressor);
</code></pre>
<p>The <code>options</code> can be missing.  Available options are discussed above in<br>“Compressor options”.  Defaults should lead to best compression in most<br>scripts.</p>
<p>The compressor is destructive, so don’t rely that <code>toplevel</code> remains the<br>original tree.</p>
<h4 id="Mangling">Mangling</h4><p>After compression it is a good idea to call again <code>figure_out_scope</code> (since<br>the compressor might drop unused variables / unreachable code and this might<br>change the number of identifiers or their position).  Optionally, you can<br>call a trick that helps after Gzip (counting character frequency in<br>non-mangleable words).  Example:</p>
<pre><code class="javascript">compressed_ast.figure_out_scope();
compressed_ast.compute_char_frequency();
compressed_ast.mangle_names();
</code></pre>
<h4 id="Generating_output">Generating output</h4><p>AST nodes have a <code>print</code> method that takes an output stream.  Essentially,<br>to generate code you do this:</p>
<pre><code class="javascript"><span class="keyword">var</span> stream = UglifyJS.OutputStream(options);
compressed_ast.print(stream);
<span class="keyword">var</span> code = stream.toString(); <span class="comment">// this is your minified code</span>
</code></pre>
<p>or, for a shortcut you can do:</p>
<pre><code class="javascript"><span class="keyword">var</span> code = compressed_ast.print_to_string(options);
</code></pre>
<p>As usual, <code>options</code> is optional.  The output stream accepts a lot of options,<br>most of them documented above in section “Beautifier options”.  The two<br>which we care about here are <code>source_map</code> and <code>comments</code>.</p>
<h4 id="Keeping_comments_in_the_output">Keeping comments in the output</h4><p>In order to keep certain comments in the output you need to pass the<br><code>comments</code> option.  Pass a RegExp or a function.  If you pass a RegExp, only<br>those comments whose body matches the regexp will be kept.  Note that body<br>means without the initial <code>//</code> or <code>/*</code>.  If you pass a function, it will be<br>called for every comment in the tree and will receive two arguments: the<br>node that the comment is attached to, and the comment token itself.</p>
<p>The comment token has these properties:</p>
<ul>
<li><code>type</code>: “comment1” for single-line comments or “comment2” for multi-line<br>comments</li>
<li><code>value</code>: the comment body</li>
<li><code>pos</code> and <code>endpos</code>: the start/end positions (zero-based indexes) in the<br>original code where this comment appears</li>
<li><code>line</code> and <code>col</code>: the line and column where this comment appears in the<br>original code</li>
<li><code>file</code> — the file name of the original file</li>
<li><code>nlb</code> — true if there was a newline before this comment in the original<br>code, or if this comment contains a newline.</li>
</ul>
<p>Your function should return <code>true</code> to keep the comment, or a falsy value<br>otherwise.</p>
<h4 id="Generating_a_source_mapping">Generating a source mapping</h4><p>You need to pass the <code>source_map</code> argument when calling <code>print</code>.  It needs<br>to be a <code>SourceMap</code> object (which is a thin wrapper on top of the<br><a href="https://github.com/mozilla/source-map">source-map</a> library).</p>
<p>Example:</p>
<pre><code class="javascript"><span class="keyword">var</span> source_map = UglifyJS.SourceMap(source_map_options);
<span class="keyword">var</span> stream = UglifyJS.OutputStream({
    ...
    source_map: source_map
});
compressed_ast.print(stream);

<span class="keyword">var</span> code = stream.toString();
<span class="keyword">var</span> map = source_map.toString(); <span class="comment">// json output for your source map</span>
</code></pre>
<p>The <code>source_map_options</code> (optional) can contain the following properties:</p>
<ul>
<li><code>file</code>: the name of the JavaScript output file that this mapping refers to</li>
<li><code>root</code>: the <code>sourceRoot</code> property (see the <a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit">spec</a>)</li>
<li><code>orig</code>: the “original source map”, handy when you compress generated JS<br>and want to map the minified output back to the original code where it<br>came from.  It can be simply a string in JSON, or a JSON object containing<br>the original source map.</li>
</ul>
