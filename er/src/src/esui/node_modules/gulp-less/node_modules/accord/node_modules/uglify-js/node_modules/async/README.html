<h1 id="Async-js">Async.js</h1><p>Async is a utility module which provides straight-forward, powerful functions<br>for working with asynchronous JavaScript. Although originally designed for<br>use with <a href="http://nodejs.org">node.js</a>, it can also be used directly in the<br>browser. Also supports <a href="https://github.com/component/component">component</a>.</p>
<p>Async provides around 20 functions that include the usual ‘functional’<br>suspects (map, reduce, filter, each…) as well as some common patterns<br>for asynchronous control flow (parallel, series, waterfall…). All these<br>functions assume you follow the node.js convention of providing a single<br>callback as the last argument of your async function.</p>
<h2 id="Quick_Examples">Quick Examples</h2><pre><code class="javascript"><span class="keyword">async</span>.map([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.stat, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// results is now an array of stats for each file</span>
});

<span class="keyword">async</span>.filter([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.exists, <span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>{
    <span class="comment">// results now equals an array of the existing files</span>
});

<span class="keyword">async</span>.parallel([
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ ... },
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ ... }
], callback);

<span class="keyword">async</span>.series([
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ ... },
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ ... }
]);
</code></pre>
<p>There are many more functions available so take a look at the docs below for a<br>full list. This module aims to be comprehensive, so if you feel anything is<br>missing please create a GitHub issue for it.</p>
<h2 id="Common_Pitfalls">Common Pitfalls</h2><h3 id="Binding_a_context_to_an_iterator">Binding a context to an iterator</h3><p>This section is really about bind, not about async. If you are wondering how to<br>make async execute your iterators in a given context, or are confused as to why<br>a method of another library isn’t working as an iterator, study this example:</p>
<pre><code class="js"><span class="comment">// Here is a simple object with an (unnecessarily roundabout) squaring method</span>
<span class="keyword">var</span> AsyncSquaringLibrary = {
  squareExponent: <span class="number">2</span>,
  square: <span class="function"><span class="keyword">function</span>(<span class="params">number, callback</span>)</span>{ 
    <span class="keyword">var</span> result = <span class="built_in">Math</span>.pow(number, <span class="keyword">this</span>.squareExponent);
    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
      callback(<span class="literal">null</span>, result);
    }, <span class="number">200</span>);
  }
};

<span class="keyword">async</span>.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], AsyncSquaringLibrary.square, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>)</span>{
  <span class="comment">// result is [NaN, NaN, NaN]</span>
  <span class="comment">// This fails because the `this.squareExponent` expression in the square</span>
  <span class="comment">// function is not evaluated in the context of AsyncSquaringLibrary, and is</span>
  <span class="comment">// therefore undefined.</span>
});

<span class="keyword">async</span>.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>)</span>{
  <span class="comment">// result is [1, 4, 9]</span>
  <span class="comment">// With the help of bind we can attach a context to the iterator before</span>
  <span class="comment">// passing it to async. Now the square function will be executed in its </span>
  <span class="comment">// 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`</span>
  <span class="comment">// will be as expected.</span>
});
</code></pre>
<h2 id="Download">Download</h2><p>The source is available for download from<br><a href="http://github.com/caolan/async">GitHub</a>.<br>Alternatively, you can install using Node Package Manager (npm):</p>
<pre><code>npm <span class="keyword">install</span> async
</code></pre><p><strong>Development:</strong> <a href="https://github.com/caolan/async/raw/master/lib/async.js">async.js</a> - 29.6kb Uncompressed</p>
<h2 id="In_the_Browser">In the Browser</h2><p>So far it’s been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. Usage:</p>
<pre><code class="html"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"async.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="http">

<span class="fortran">    async.map(<span class="type">data</span>, asyncProcess, <span class="function"><span class="keyword">function</span><span class="params">(err, results)</span></span>{
        alert(results);
    });

</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre>
<h2 id="Documentation">Documentation</h2><h3 id="Collections">Collections</h3><ul>
<li><a href="#each">each</a></li>
<li><a href="#eachSeries">eachSeries</a></li>
<li><a href="#eachLimit">eachLimit</a></li>
<li><a href="#map">map</a></li>
<li><a href="#mapSeries">mapSeries</a></li>
<li><a href="#mapLimit">mapLimit</a></li>
<li><a href="#filter">filter</a></li>
<li><a href="#filterSeries">filterSeries</a></li>
<li><a href="#reject">reject</a></li>
<li><a href="#rejectSeries">rejectSeries</a></li>
<li><a href="#reduce">reduce</a></li>
<li><a href="#reduceRight">reduceRight</a></li>
<li><a href="#detect">detect</a></li>
<li><a href="#detectSeries">detectSeries</a></li>
<li><a href="#sortBy">sortBy</a></li>
<li><a href="#some">some</a></li>
<li><a href="#every">every</a></li>
<li><a href="#concat">concat</a></li>
<li><a href="#concatSeries">concatSeries</a></li>
</ul>
<h3 id="Control_Flow">Control Flow</h3><ul>
<li><a href="#series">series</a></li>
<li><a href="#parallel">parallel</a></li>
<li><a href="#parallellimittasks-limit-callback">parallelLimit</a></li>
<li><a href="#whilst">whilst</a></li>
<li><a href="#doWhilst">doWhilst</a></li>
<li><a href="#until">until</a></li>
<li><a href="#doUntil">doUntil</a></li>
<li><a href="#forever">forever</a></li>
<li><a href="#waterfall">waterfall</a></li>
<li><a href="#compose">compose</a></li>
<li><a href="#applyEach">applyEach</a></li>
<li><a href="#applyEachSeries">applyEachSeries</a></li>
<li><a href="#queue">queue</a></li>
<li><a href="#cargo">cargo</a></li>
<li><a href="#auto">auto</a></li>
<li><a href="#iterator">iterator</a></li>
<li><a href="#apply">apply</a></li>
<li><a href="#nextTick">nextTick</a></li>
<li><a href="#times">times</a></li>
<li><a href="#timesSeries">timesSeries</a></li>
</ul>
<h3 id="Utils">Utils</h3><ul>
<li><a href="#memoize">memoize</a></li>
<li><a href="#unmemoize">unmemoize</a></li>
<li><a href="#log">log</a></li>
<li><a href="#dir">dir</a></li>
<li><a href="#noConflict">noConflict</a></li>
</ul>
<h2 id="Collections-1">Collections</h2><p><a name="forEach" /><br><a name="each" /></p>
<h3 id="each(arr,_iterator,_callback)">each(arr, iterator, callback)</h3><p>Applies an iterator function to each item in an array, in parallel.<br>The iterator is called with an item from the list and a callback for when it<br>has finished. If the iterator passes an error to this callback, the main<br>callback for the each function is immediately called with the error.</p>
<p>Note, that since this function applies the iterator to each item in parallel<br>there is no guarantee that the iterator functions will complete in order.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A function to apply to each item in the array.<br>The iterator is passed a callback(err) which must be called once it has<br>completed. If no error has occured, the callback should be run without<br>arguments or with an explicit null argument.</li>
<li>callback(err) - A callback which is called after all the iterator functions<br>have finished, or an error has occurred.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// assuming openFiles is an array of file names and saveFile is a function</span>
<span class="comment">// to save the modified contents of that file:</span>

<span class="keyword">async</span>.each(openFiles, saveFile, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>{
    <span class="comment">// if any of the saves produced an error, err would equal that error</span>
});
</code></pre>
<hr>
<p><a name="forEachSeries" /><br><a name="eachSeries" /></p>
<h3 id="eachSeries(arr,_iterator,_callback)">eachSeries(arr, iterator, callback)</h3><p>The same as each only the iterator is applied to each item in the array in<br>series. The next iterator is only called once the current one has completed<br>processing. This means the iterator functions will complete in order.</p>
<hr>
<p><a name="forEachLimit" /><br><a name="eachLimit" /></p>
<h3 id="eachLimit(arr,_limit,_iterator,_callback)">eachLimit(arr, limit, iterator, callback)</h3><p>The same as each only no more than “limit” iterators will be simultaneously<br>running at any time.</p>
<p>Note that the items are not processed in batches, so there is no guarantee that<br> the first “limit” iterator functions will complete before any others are<br>started.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>limit - The maximum number of iterators to run at any time.</li>
<li>iterator(item, callback) - A function to apply to each item in the array.<br>The iterator is passed a callback(err) which must be called once it has<br>completed. If no error has occured, the callback should be run without<br>arguments or with an explicit null argument.</li>
<li>callback(err) - A callback which is called after all the iterator functions<br>have finished, or an error has occurred.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// Assume documents is an array of JSON objects and requestApi is a</span>
<span class="comment">// function that interacts with a rate-limited REST api.</span>

<span class="keyword">async</span>.eachLimit(documents, <span class="number">20</span>, requestApi, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>{
    <span class="comment">// if any of the saves produced an error, err would equal that error</span>
});
</code></pre>
<hr>
<p><a name="map" /></p>
<h3 id="map(arr,_iterator,_callback)">map(arr, iterator, callback)</h3><p>Produces a new array of values by mapping each value in the given array through<br>the iterator function. The iterator is called with an item from the array and a<br>callback for when it has finished processing. The callback takes 2 arguments,<br>an error and the transformed item from the array. If the iterator passes an<br>error to this callback, the main callback for the map function is immediately<br>called with the error.</p>
<p>Note, that since this function applies the iterator to each item in parallel<br>there is no guarantee that the iterator functions will complete in order, however<br>the results array will be in the same order as the original array.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A function to apply to each item in the array.<br>The iterator is passed a callback(err, transformed) which must be called once<br>it has completed with an error (which can be null) and a transformed item.</li>
<li>callback(err, results) - A callback which is called after all the iterator<br>functions have finished, or an error has occurred. Results is an array of the<br>transformed items from the original array.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.map([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.stat, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// results is now an array of stats for each file</span>
});
</code></pre>
<hr>
<p><a name="mapSeries" /></p>
<h3 id="mapSeries(arr,_iterator,_callback)">mapSeries(arr, iterator, callback)</h3><p>The same as map only the iterator is applied to each item in the array in<br>series. The next iterator is only called once the current one has completed<br>processing. The results array will be in the same order as the original.</p>
<hr>
<p><a name="mapLimit" /></p>
<h3 id="mapLimit(arr,_limit,_iterator,_callback)">mapLimit(arr, limit, iterator, callback)</h3><p>The same as map only no more than “limit” iterators will be simultaneously<br>running at any time.</p>
<p>Note that the items are not processed in batches, so there is no guarantee that<br> the first “limit” iterator functions will complete before any others are<br>started.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>limit - The maximum number of iterators to run at any time.</li>
<li>iterator(item, callback) - A function to apply to each item in the array.<br>The iterator is passed a callback(err, transformed) which must be called once<br>it has completed with an error (which can be null) and a transformed item.</li>
<li>callback(err, results) - A callback which is called after all the iterator<br>functions have finished, or an error has occurred. Results is an array of the<br>transformed items from the original array.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.mapLimit([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], <span class="number">1</span>, fs.stat, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// results is now an array of stats for each file</span>
});
</code></pre>
<hr>
<p><a name="filter" /></p>
<h3 id="filter(arr,_iterator,_callback)">filter(arr, iterator, callback)</h3><p><strong>Alias:</strong> select</p>
<p>Returns a new array of all the values which pass an async truth test.<br><em>The callback for each iterator call only accepts a single argument of true or<br>false, it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like fs.exists. This operation is<br>performed in parallel, but the results array will be in the same order as the<br>original.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A truth test to apply to each item in the array.<br>The iterator is passed a callback(truthValue) which must be called with a<br>boolean argument once it has completed.</li>
<li>callback(results) - A callback which is called after all the iterator<br>functions have finished.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.filter([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.exists, <span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>{
    <span class="comment">// results now equals an array of the existing files</span>
});
</code></pre>
<hr>
<p><a name="filterSeries" /></p>
<h3 id="filterSeries(arr,_iterator,_callback)">filterSeries(arr, iterator, callback)</h3><p><strong>alias:</strong> selectSeries</p>
<p>The same as filter only the iterator is applied to each item in the array in<br>series. The next iterator is only called once the current one has completed<br>processing. The results array will be in the same order as the original.</p>
<hr>
<p><a name="reject" /></p>
<h3 id="reject(arr,_iterator,_callback)">reject(arr, iterator, callback)</h3><p>The opposite of filter. Removes values that pass an async truth test.</p>
<hr>
<p><a name="rejectSeries" /></p>
<h3 id="rejectSeries(arr,_iterator,_callback)">rejectSeries(arr, iterator, callback)</h3><p>The same as reject, only the iterator is applied to each item in the array<br>in series.</p>
<hr>
<p><a name="reduce" /></p>
<h3 id="reduce(arr,_memo,_iterator,_callback)">reduce(arr, memo, iterator, callback)</h3><p><strong>aliases:</strong> inject, foldl</p>
<p>Reduces a list of values into a single value using an async iterator to return<br>each successive step. Memo is the initial state of the reduction. This<br>function only operates in series. For performance reasons, it may make sense to<br>split a call to this function into a parallel map, then use the normal<br>Array.prototype.reduce on the results. This function is for situations where<br>each step in the reduction needs to be async, if you can get the data before<br>reducing it then it’s probably a good idea to do so.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>memo - The initial state of the reduction.</li>
<li>iterator(memo, item, callback) - A function applied to each item in the<br>array to produce the next step in the reduction. The iterator is passed a<br>callback(err, reduction) which accepts an optional error as its first<br>argument, and the state of the reduction as the second. If an error is<br>passed to the callback, the reduction is stopped and the main callback is<br>immediately called with the error.</li>
<li>callback(err, result) - A callback which is called after all the iterator<br>functions have finished. Result is the reduced value.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.reduce([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">memo, item, callback</span>)</span>{
    <span class="comment">// pointless async:</span>
    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        callback(<span class="literal">null</span>, memo + item)
    });
}, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>)</span>{
    <span class="comment">// result is now equal to the last value of memo, which is 6</span>
});
</code></pre>
<hr>
<p><a name="reduceRight" /></p>
<h3 id="reduceRight(arr,_memo,_iterator,_callback)">reduceRight(arr, memo, iterator, callback)</h3><p><strong>Alias:</strong> foldr</p>
<p>Same as reduce, only operates on the items in the array in reverse order.</p>
<hr>
<p><a name="detect" /></p>
<h3 id="detect(arr,_iterator,_callback)">detect(arr, iterator, callback)</h3><p>Returns the first value in a list that passes an async truth test. The<br>iterator is applied in parallel, meaning the first iterator to return true will<br>fire the detect callback with that result. That means the result might not be<br>the first item in the original array (in terms of order) that passes the test.</p>
<p>If order within the original array is important then look at detectSeries.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A truth test to apply to each item in the array.<br>The iterator is passed a callback(truthValue) which must be called with a<br>boolean argument once it has completed.</li>
<li>callback(result) - A callback which is called as soon as any iterator returns<br>true, or after all the iterator functions have finished. Result will be<br>the first item in the array that passes the truth test (iterator) or the<br>value undefined if none passed.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.detect([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.exists, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>{
    <span class="comment">// result now equals the first file in the list that exists</span>
});
</code></pre>
<hr>
<p><a name="detectSeries" /></p>
<h3 id="detectSeries(arr,_iterator,_callback)">detectSeries(arr, iterator, callback)</h3><p>The same as detect, only the iterator is applied to each item in the array<br>in series. This means the result is always the first in the original array (in<br>terms of array order) that passes the truth test.</p>
<hr>
<p><a name="sortBy" /></p>
<h3 id="sortBy(arr,_iterator,_callback)">sortBy(arr, iterator, callback)</h3><p>Sorts a list by the results of running each value through an async iterator.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A function to apply to each item in the array.<br>The iterator is passed a callback(err, sortValue) which must be called once it<br>has completed with an error (which can be null) and a value to use as the sort<br>criteria.</li>
<li>callback(err, results) - A callback which is called after all the iterator<br>functions have finished, or an error has occurred. Results is the items from<br>the original array sorted by the values returned by the iterator calls.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.sortBy([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">file, callback</span>)</span>{
    fs.stat(file, <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>)</span>{
        callback(err, stats.mtime);
    });
}, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// results is now the original array of files sorted by</span>
    <span class="comment">// modified date</span>
});
</code></pre>
<hr>
<p><a name="some" /></p>
<h3 id="some(arr,_iterator,_callback)">some(arr, iterator, callback)</h3><p><strong>Alias:</strong> any</p>
<p>Returns true if at least one element in the array satisfies an async test.<br><em>The callback for each iterator call only accepts a single argument of true or<br>false, it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like fs.exists. Once any iterator<br>call returns true, the main callback is immediately called.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A truth test to apply to each item in the array.<br>The iterator is passed a callback(truthValue) which must be called with a<br>boolean argument once it has completed.</li>
<li>callback(result) - A callback which is called as soon as any iterator returns<br>true, or after all the iterator functions have finished. Result will be<br>either true or false depending on the values of the async tests.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.some([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.exists, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>{
    <span class="comment">// if result is true then at least one of the files exists</span>
});
</code></pre>
<hr>
<p><a name="every" /></p>
<h3 id="every(arr,_iterator,_callback)">every(arr, iterator, callback)</h3><p><strong>Alias:</strong> all</p>
<p>Returns true if every element in the array satisfies an async test.<br><em>The callback for each iterator call only accepts a single argument of true or<br>false, it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like fs.exists.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over.</li>
<li>iterator(item, callback) - A truth test to apply to each item in the array.<br>The iterator is passed a callback(truthValue) which must be called with a<br>boolean argument once it has completed.</li>
<li>callback(result) - A callback which is called after all the iterator<br>functions have finished. Result will be either true or false depending on<br>the values of the async tests.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.every([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.exists, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>{
    <span class="comment">// if result is true then every file exists</span>
});
</code></pre>
<hr>
<p><a name="concat" /></p>
<h3 id="concat(arr,_iterator,_callback)">concat(arr, iterator, callback)</h3><p>Applies an iterator to each item in a list, concatenating the results. Returns the<br>concatenated list. The iterators are called in parallel, and the results are<br>concatenated as they return. There is no guarantee that the results array will<br>be returned in the original order of the arguments passed to the iterator function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>arr - An array to iterate over</li>
<li>iterator(item, callback) - A function to apply to each item in the array.<br>The iterator is passed a callback(err, results) which must be called once it<br>has completed with an error (which can be null) and an array of results.</li>
<li>callback(err, results) - A callback which is called after all the iterator<br>functions have finished, or an error has occurred. Results is an array containing<br>the concatenated results of the iterator function.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.concat([<span class="string">'dir1'</span>,<span class="string">'dir2'</span>,<span class="string">'dir3'</span>], fs.readdir, <span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>{
    <span class="comment">// files is now a list of filenames that exist in the 3 directories</span>
});
</code></pre>
<hr>
<p><a name="concatSeries" /></p>
<h3 id="concatSeries(arr,_iterator,_callback)">concatSeries(arr, iterator, callback)</h3><p>Same as async.concat, but executes in series instead of parallel.</p>
<h2 id="Control_Flow-1">Control Flow</h2><p><a name="series" /></p>
<h3 id="series(tasks,_[callback])">series(tasks, [callback])</h3><p>Run an array of functions in series, each one running once the previous<br>function has completed. If any functions in the series pass an error to its<br>callback, no more functions are run and the callback for the series is<br>immediately called with the value of the error. Once the tasks have completed,<br>the results are passed to the final callback as an array.</p>
<p>It is also possible to use an object instead of an array. Each property will be<br>run as a function and the results will be passed to the final callback as an object<br>instead of an array. This can be a more readable way of handling results from<br>async.series.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>tasks - An array or object containing functions to run, each function is passed<br>a callback(err, result) it must call on completion with an error (which can<br>be null) and an optional result value.</li>
<li>callback(err, results) - An optional callback to run once all the functions<br>have completed. This function gets a results array (or object) containing all<br>the result arguments passed to the task callbacks.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.series([
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="comment">// do some stuff ...</span>
        callback(<span class="literal">null</span>, <span class="string">'one'</span>);
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="comment">// do some more stuff ...</span>
        callback(<span class="literal">null</span>, <span class="string">'two'</span>);
    }
],
<span class="comment">// optional callback</span>
<span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// results is now equal to ['one', 'two']</span>
});


<span class="comment">// an example using an object instead of an array</span>
<span class="keyword">async</span>.series({
    one: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="number">1</span>);
        }, <span class="number">200</span>);
    },
    two: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="number">2</span>);
        }, <span class="number">100</span>);
    }
},
<span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>{
    <span class="comment">// results is now equal to: {one: 1, two: 2}</span>
});
</code></pre>
<hr>
<p><a name="parallel" /></p>
<h3 id="parallel(tasks,_[callback])">parallel(tasks, [callback])</h3><p>Run an array of functions in parallel, without waiting until the previous<br>function has completed. If any of the functions pass an error to its<br>callback, the main callback is immediately called with the value of the error.<br>Once the tasks have completed, the results are passed to the final callback as an<br>array.</p>
<p>It is also possible to use an object instead of an array. Each property will be<br>run as a function and the results will be passed to the final callback as an object<br>instead of an array. This can be a more readable way of handling results from<br>async.parallel.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>tasks - An array or object containing functions to run, each function is passed<br>a callback(err, result) it must call on completion with an error (which can<br>be null) and an optional result value.</li>
<li>callback(err, results) - An optional callback to run once all the functions<br>have completed. This function gets a results array (or object) containing all<br>the result arguments passed to the task callbacks.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.parallel([
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="string">'one'</span>);
        }, <span class="number">200</span>);
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="string">'two'</span>);
        }, <span class="number">100</span>);
    }
],
<span class="comment">// optional callback</span>
<span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// the results array will equal ['one','two'] even though</span>
    <span class="comment">// the second function had a shorter timeout.</span>
});


<span class="comment">// an example using an object instead of an array</span>
<span class="keyword">async</span>.parallel({
    one: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="number">1</span>);
        }, <span class="number">200</span>);
    },
    two: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="number">2</span>);
        }, <span class="number">100</span>);
    }
},
<span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>{
    <span class="comment">// results is now equals to: {one: 1, two: 2}</span>
});
</code></pre>
<hr>
<p><a name="parallel" /></p>
<h3 id="parallelLimit(tasks,_limit,_[callback])">parallelLimit(tasks, limit, [callback])</h3><p>The same as parallel only the tasks are executed in parallel with a maximum of “limit”<br>tasks executing at any time.</p>
<p>Note that the tasks are not executed in batches, so there is no guarantee that<br>the first “limit” tasks will complete before any others are started.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>tasks - An array or object containing functions to run, each function is passed<br>a callback(err, result) it must call on completion with an error (which can<br>be null) and an optional result value.</li>
<li>limit - The maximum number of tasks to run at any time.</li>
<li>callback(err, results) - An optional callback to run once all the functions<br>have completed. This function gets a results array (or object) containing all<br>the result arguments passed to the task callbacks.</li>
</ul>
<hr>
<p><a name="whilst" /></p>
<h3 id="whilst(test,_fn,_callback)">whilst(test, fn, callback)</h3><p>Repeatedly call fn, while test returns true. Calls the callback when stopped,<br>or an error occurs.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>test() - synchronous truth test to perform before each execution of fn.</li>
<li>fn(callback) - A function to call each time the test passes. The function is<br>passed a callback(err) which must be called once it has completed with an<br>optional error argument.</li>
<li>callback(err) - A callback which is called after the test fails and repeated<br>execution of fn has stopped.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> count = <span class="number">0</span>;

<span class="keyword">async</span>.whilst(
    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ <span class="keyword">return</span> count &lt; <span class="number">5</span>; },
    <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>{
        count++;
        setTimeout(callback, <span class="number">1000</span>);
    },
    <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
        <span class="comment">// 5 seconds have passed</span>
    }
);
</code></pre>
<hr>
<p><a name="doWhilst" /></p>
<h3 id="doWhilst(fn,_test,_callback)">doWhilst(fn, test, callback)</h3><p>The post check version of whilst. To reflect the difference in the order of operations <code>test</code> and <code>fn</code> arguments are switched. <code>doWhilst</code> is to <code>whilst</code> as <code>do while</code> is to <code>while</code> in plain JavaScript.</p>
<hr>
<p><a name="until" /></p>
<h3 id="until(test,_fn,_callback)">until(test, fn, callback)</h3><p>Repeatedly call fn, until test returns true. Calls the callback when stopped,<br>or an error occurs.</p>
<p>The inverse of async.whilst.</p>
<hr>
<p><a name="doUntil" /></p>
<h3 id="doUntil(fn,_test,_callback)">doUntil(fn, test, callback)</h3><p>Like doWhilst except the test is inverted. Note the argument ordering differs from <code>until</code>.</p>
<hr>
<p><a name="forever" /></p>
<h3 id="forever(fn,_callback)">forever(fn, callback)</h3><p>Calls the asynchronous function ‘fn’ repeatedly, in series, indefinitely.<br>If an error is passed to fn’s callback then ‘callback’ is called with the<br>error, otherwise it will never be called.</p>
<hr>
<p><a name="waterfall" /></p>
<h3 id="waterfall(tasks,_[callback])">waterfall(tasks, [callback])</h3><p>Runs an array of functions in series, each passing their results to the next in<br>the array. However, if any of the functions pass an error to the callback, the<br>next function is not executed and the main callback is immediately called with<br>the error.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>tasks - An array of functions to run, each function is passed a<br>callback(err, result1, result2, …) it must call on completion. The first<br>argument is an error (which can be null) and any further arguments will be<br>passed as arguments in order to the next task.</li>
<li>callback(err, [results]) - An optional callback to run once all the functions<br>have completed. This will be passed the results of the last task’s callback.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.waterfall([
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        callback(<span class="literal">null</span>, <span class="string">'one'</span>, <span class="string">'two'</span>);
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, callback</span>)</span>{
        callback(<span class="literal">null</span>, <span class="string">'three'</span>);
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">arg1, callback</span>)</span>{
        <span class="comment">// arg1 now equals 'three'</span>
        callback(<span class="literal">null</span>, <span class="string">'done'</span>);
    }
], <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>{
   <span class="comment">// result now equals 'done'    </span>
});
</code></pre>
<hr>
<p><a name="compose" /></p>
<h3 id="compose(fn1,_fn2…)">compose(fn1, fn2…)</h3><p>Creates a function which is a composition of the passed asynchronous<br>functions. Each function consumes the return value of the function that<br>follows. Composing functions f(), g() and h() would produce the result of<br>f(g(h())), only this version uses callbacks to obtain the return values.</p>
<p>Each function is executed with the <code>this</code> binding of the composed function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>functions… - the asynchronous functions to compose</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">n, callback</span>) </span>{
    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        callback(<span class="literal">null</span>, n + <span class="number">1</span>);
    }, <span class="number">10</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">mul3</span>(<span class="params">n, callback</span>) </span>{
    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        callback(<span class="literal">null</span>, n * <span class="number">3</span>);
    }, <span class="number">10</span>);
}

<span class="keyword">var</span> add1mul3 = <span class="keyword">async</span>.compose(mul3, add1);

add1mul3(<span class="number">4</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>{
   <span class="comment">// result now equals 15</span>
});
</code></pre>
<hr>
<p><a name="applyEach" /></p>
<h3 id="applyEach(fns,_args…,_callback)">applyEach(fns, args…, callback)</h3><p>Applies the provided arguments to each function in the array, calling the<br>callback after all functions have completed. If you only provide the first<br>argument then it will return a function which lets you pass in the<br>arguments as if it were a single function call.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>fns - the asynchronous functions to all call with the same arguments</li>
<li>args… - any number of separate arguments to pass to the function</li>
<li>callback - the final argument should be the callback, called when all<br>functions have completed processing</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.applyEach([enableSearch, updateSchema], <span class="string">'bucket'</span>, callback);

<span class="comment">// partial application example:</span>
<span class="keyword">async</span>.each(
    buckets,
    <span class="keyword">async</span>.applyEach([enableSearch, updateSchema]),
    callback
);
</code></pre>
<hr>
<p><a name="applyEachSeries" /></p>
<h3 id="applyEachSeries(arr,_iterator,_callback)">applyEachSeries(arr, iterator, callback)</h3><p>The same as applyEach only the functions are applied in series.</p>
<hr>
<p><a name="queue" /></p>
<h3 id="queue(worker,_concurrency)">queue(worker, concurrency)</h3><p>Creates a queue object with the specified concurrency. Tasks added to the<br>queue will be processed in parallel (up to the concurrency limit). If all<br>workers are in progress, the task is queued until one is available. Once<br>a worker has completed a task, the task’s callback is called.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>worker(task, callback) - An asynchronous function for processing a queued<br>task, which must call its callback(err) argument when finished, with an<br>optional error as an argument.</li>
<li>concurrency - An integer for determining how many worker functions should be<br>run in parallel.</li>
</ul>
<p><strong>Queue objects</strong></p>
<p>The queue object returned by this function has the following properties and<br>methods:</p>
<ul>
<li>length() - a function returning the number of items waiting to be processed.</li>
<li>concurrency - an integer for determining how many worker functions should be<br>run in parallel. This property can be changed after a queue is created to<br>alter the concurrency on-the-fly.</li>
<li>push(task, [callback]) - add a new task to the queue, the callback is called<br>once the worker has finished processing the task.<br>instead of a single task, an array of tasks can be submitted. the respective callback is used for every task in the list.</li>
<li>unshift(task, [callback]) - add a new task to the front of the queue.</li>
<li>saturated - a callback that is called when the queue length hits the concurrency and further tasks will be queued</li>
<li>empty - a callback that is called when the last item from the queue is given to a worker</li>
<li>drain - a callback that is called when the last item from the queue has returned from the worker</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// create a queue object with concurrency 2</span>

<span class="keyword">var</span> q = <span class="keyword">async</span>.queue(<span class="function"><span class="keyword">function</span> (<span class="params">task, callback</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'hello '</span> + task.name);
    callback();
}, <span class="number">2</span>);


<span class="comment">// assign a callback</span>
q.drain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'all items have been processed'</span>);
}

<span class="comment">// add some items to the queue</span>

q.push({name: <span class="string">'foo'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing foo'</span>);
});
q.push({name: <span class="string">'bar'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing bar'</span>);
});

<span class="comment">// add some items to the queue (batch-wise)</span>

q.push([{name: <span class="string">'baz'</span>},{name: <span class="string">'bay'</span>},{name: <span class="string">'bax'</span>}], <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing bar'</span>);
});

<span class="comment">// add some items to the front of the queue</span>

q.unshift({name: <span class="string">'bar'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing bar'</span>);
});
</code></pre>
<hr>
<p><a name="cargo" /></p>
<h3 id="cargo(worker,_[payload])">cargo(worker, [payload])</h3><p>Creates a cargo object with the specified payload. Tasks added to the<br>cargo will be processed altogether (up to the payload limit). If the<br>worker is in progress, the task is queued until it is available. Once<br>the worker has completed some tasks, each callback of those tasks is called.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>worker(tasks, callback) - An asynchronous function for processing an array of<br>queued tasks, which must call its callback(err) argument when finished, with<br>an optional error as an argument.</li>
<li>payload - An optional integer for determining how many tasks should be<br>processed per round; if omitted, the default is unlimited.</li>
</ul>
<p><strong>Cargo objects</strong></p>
<p>The cargo object returned by this function has the following properties and<br>methods:</p>
<ul>
<li>length() - a function returning the number of items waiting to be processed.</li>
<li>payload - an integer for determining how many tasks should be<br>process per round. This property can be changed after a cargo is created to<br>alter the payload on-the-fly.</li>
<li>push(task, [callback]) - add a new task to the queue, the callback is called<br>once the worker has finished processing the task.<br>instead of a single task, an array of tasks can be submitted. the respective callback is used for every task in the list.</li>
<li>saturated - a callback that is called when the queue length hits the concurrency and further tasks will be queued</li>
<li>empty - a callback that is called when the last item from the queue is given to a worker</li>
<li>drain - a callback that is called when the last item from the queue has returned from the worker</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// create a cargo object with payload 2</span>

<span class="keyword">var</span> cargo = <span class="keyword">async</span>.cargo(<span class="function"><span class="keyword">function</span> (<span class="params">tasks, callback</span>) </span>{
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;tasks.length; i++){
      <span class="built_in">console</span>.log(<span class="string">'hello '</span> + tasks[i].name);
    }
    callback();
}, <span class="number">2</span>);


<span class="comment">// add some items</span>

cargo.push({name: <span class="string">'foo'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing foo'</span>);
});
cargo.push({name: <span class="string">'bar'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing bar'</span>);
});
cargo.push({name: <span class="string">'baz'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing baz'</span>);
});
</code></pre>
<hr>
<p><a name="auto" /></p>
<h3 id="auto(tasks,_[callback])">auto(tasks, [callback])</h3><p>Determines the best order for running functions based on their requirements.<br>Each function can optionally depend on other functions being completed first,<br>and each function is run as soon as its requirements are satisfied. If any of<br>the functions pass an error to their callback, that function will not complete<br>(so any other functions depending on it will not run) and the main callback<br>will be called immediately with the error. Functions also receive an object<br>containing the results of functions which have completed so far.</p>
<p>Note, all functions are called with a results object as a second argument,<br>so it is unsafe to pass functions in the tasks object which cannot handle the<br>extra argument. For example, this snippet of code:</p>
<pre><code class="js"><span class="keyword">async</span>.auto({
  readData: <span class="keyword">async</span>.apply(fs.readFile, <span class="string">'data.txt'</span>, <span class="string">'utf-8'</span>)
}, callback);
</code></pre>
<p>will have the effect of calling readFile with the results object as the last<br>argument, which will fail:</p>
<pre><code class="js">fs.readFile(<span class="string">'data.txt'</span>, <span class="string">'utf-8'</span>, cb, {});
</code></pre>
<p>Instead, wrap the call to readFile in a function which does not forward the<br>results object:</p>
<pre><code class="js"><span class="keyword">async</span>.auto({
  readData: <span class="function"><span class="keyword">function</span>(<span class="params">cb, results</span>)</span>{
    fs.readFile(<span class="string">'data.txt'</span>, <span class="string">'utf-8'</span>, cb);
  }
}, callback);
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li>tasks - An object literal containing named functions or an array of<br>requirements, with the function itself the last item in the array. The key<br>used for each function or array is used when specifying requirements. The<br>function receives two arguments: (1) a callback(err, result) which must be<br>called when finished, passing an error (which can be null) and the result of<br>the function’s execution, and (2) a results object, containing the results of<br>the previously executed functions.</li>
<li>callback(err, results) - An optional callback which is called when all the<br>tasks have been completed. The callback will receive an error as an argument<br>if any tasks pass an error to their callback. Results will always be passed<br>  but if an error occurred, no other tasks will be performed, and the results<br>  object will only contain partial results.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.auto({
    get_data: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="comment">// async code to get some data</span>
    },
    make_folder: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="comment">// async code to create a directory to store a file in</span>
        <span class="comment">// this is run at the same time as getting the data</span>
    },
    write_file: [<span class="string">'get_data'</span>, <span class="string">'make_folder'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="comment">// once there is some data and the directory exists,</span>
        <span class="comment">// write the data to a file in the directory</span>
        callback(<span class="literal">null</span>, filename);
    }],
    email_link: [<span class="string">'write_file'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback, results</span>)</span>{
        <span class="comment">// once the file is written let's email a link to it...</span>
        <span class="comment">// results.write_file contains the filename returned by write_file.</span>
    }]
});
</code></pre>
<p>This is a fairly trivial example, but to do this using the basic parallel and<br>series functions would look like this:</p>
<pre><code class="js"><span class="keyword">async</span>.parallel([
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="comment">// async code to get some data</span>
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="comment">// async code to create a directory to store a file in</span>
        <span class="comment">// this is run at the same time as getting the data</span>
    }
],
<span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="keyword">async</span>.series([
        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
            <span class="comment">// once there is some data and the directory exists,</span>
            <span class="comment">// write the data to a file in the directory</span>
        },
        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
            <span class="comment">// once the file is written let's email a link to it...</span>
        }
    ]);
});
</code></pre>
<p>For a complicated series of async tasks using the auto function makes adding<br>new tasks much easier and makes the code more readable.</p>
<hr>
<p><a name="iterator" /></p>
<h3 id="iterator(tasks)">iterator(tasks)</h3><p>Creates an iterator function which calls the next function in the array,<br>returning a continuation to call the next one after that. It’s also possible to<br>‘peek’ the next iterator by doing iterator.next().</p>
<p>This function is used internally by the async module but can be useful when<br>you want to manually control the flow of functions in series.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>tasks - An array of functions to run.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> iterator = <span class="keyword">async</span>.iterator([
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ sys.p(<span class="string">'one'</span>); },
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ sys.p(<span class="string">'two'</span>); },
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ sys.p(<span class="string">'three'</span>); }
]);

node&gt; <span class="keyword">var</span> iterator2 = iterator();
<span class="string">'one'</span>
node&gt; <span class="keyword">var</span> iterator3 = iterator2();
<span class="string">'two'</span>
node&gt; iterator3();
<span class="string">'three'</span>
node&gt; <span class="keyword">var</span> nextfn = iterator2.next();
node&gt; nextfn();
<span class="string">'three'</span>
</code></pre>
<hr>
<p><a name="apply" /></p>
<h3 id="apply(function,_arguments-)">apply(function, arguments..)</h3><p>Creates a continuation function with some arguments already applied, a useful<br>shorthand when combined with other control flow functions. Any arguments<br>passed to the returned function are added to the arguments originally passed<br>to apply.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>function - The function you want to eventually apply all arguments to.</li>
<li>arguments… - Any number of arguments to automatically apply when the<br>continuation is called.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// using apply</span>

<span class="keyword">async</span>.parallel([
    <span class="keyword">async</span>.apply(fs.writeFile, <span class="string">'testfile1'</span>, <span class="string">'test1'</span>),
    <span class="keyword">async</span>.apply(fs.writeFile, <span class="string">'testfile2'</span>, <span class="string">'test2'</span>),
]);


<span class="comment">// the same process without using apply</span>

<span class="keyword">async</span>.parallel([
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        fs.writeFile(<span class="string">'testfile1'</span>, <span class="string">'test1'</span>, callback);
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        fs.writeFile(<span class="string">'testfile2'</span>, <span class="string">'test2'</span>, callback);
    }
]);
</code></pre>
<p>It’s possible to pass any number of additional arguments when calling the<br>continuation:</p>
<pre><code class="js">node&gt; <span class="keyword">var</span> fn = <span class="keyword">async</span>.apply(sys.puts, <span class="string">'one'</span>);
node&gt; fn(<span class="string">'two'</span>, <span class="string">'three'</span>);
one
two
three
</code></pre>
<hr>
<p><a name="nextTick" /></p>
<h3 id="nextTick(callback)">nextTick(callback)</h3><p>Calls the callback on a later loop around the event loop. In node.js this just<br>calls process.nextTick, in the browser it falls back to setImmediate(callback)<br>if available, otherwise setTimeout(callback, 0), which means other higher priority<br>events may precede the execution of the callback.</p>
<p>This is used internally for browser-compatibility purposes.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>callback - The function to call on a later loop around the event loop.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> call_order = [];
<span class="keyword">async</span>.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    call_order.push(<span class="string">'two'</span>);
    <span class="comment">// call_order now equals ['one','two']</span>
});
call_order.push(<span class="string">'one'</span>)
</code></pre>
<p><a name="times" /></p>
<h3 id="times(n,_callback)">times(n, callback)</h3><p>Calls the callback n times and accumulates results in the same manner<br>you would use with async.map.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>n - The number of times to run the function.</li>
<li>callback - The function to call n times.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// Pretend this is some complicated async factory</span>
<span class="keyword">var</span> createUser = <span class="function"><span class="keyword">function</span>(<span class="params">id, callback</span>) </span>{
  callback(<span class="literal">null</span>, {
    id: <span class="string">'user'</span> + id
  })
}
<span class="comment">// generate 5 users</span>
<span class="keyword">async</span>.times(<span class="number">5</span>, <span class="function"><span class="keyword">function</span>(<span class="params">n, next</span>)</span>{
    createUser(n, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
      next(err, user)
    })
}, <span class="function"><span class="keyword">function</span>(<span class="params">err, users</span>) </span>{
  <span class="comment">// we should now have 5 users</span>
});
</code></pre>
<p><a name="timesSeries" /></p>
<h3 id="timesSeries(n,_callback)">timesSeries(n, callback)</h3><p>The same as times only the iterator is applied to each item in the array in<br>series. The next iterator is only called once the current one has completed<br>processing. The results array will be in the same order as the original.</p>
<h2 id="Utils-1">Utils</h2><p><a name="memoize" /></p>
<h3 id="memoize(fn,_[hasher])">memoize(fn, [hasher])</h3><p>Caches the results of an async function. When creating a hash to store function<br>results against, the callback is omitted from the hash and an optional hash<br>function can be used.</p>
<p>The cache of results is exposed as the <code>memo</code> property of the function returned<br>by <code>memoize</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>fn - the function you to proxy and cache results from.</li>
<li>hasher - an optional function for generating a custom hash for storing<br>results, it has all the arguments applied to it apart from the callback, and<br>must be synchronous.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> slow_fn = <span class="function"><span class="keyword">function</span> (<span class="params">name, callback</span>) </span>{
    <span class="comment">// do something</span>
    callback(<span class="literal">null</span>, result);
};
<span class="keyword">var</span> fn = <span class="keyword">async</span>.memoize(slow_fn);

<span class="comment">// fn can now be used as if it were slow_fn</span>
fn(<span class="string">'some name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="comment">// callback</span>
});
</code></pre>
<p><a name="unmemoize" /></p>
<h3 id="unmemoize(fn)">unmemoize(fn)</h3><p>Undoes a memoized function, reverting it to the original, unmemoized<br>form. Comes handy in tests.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>fn - the memoized function</li>
</ul>
<p><a name="log" /></p>
<h3 id="log(function,_arguments)">log(function, arguments)</h3><p>Logs the result of an async function to the console. Only works in node.js or<br>in browsers that support console.log and console.error (such as FF and Chrome).<br>If multiple arguments are returned from the async function, console.log is<br>called on each argument in order.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>function - The function you want to eventually apply all arguments to.</li>
<li>arguments… - Any number of arguments to apply to the function.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params">name, callback</span>)</span>{
    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        callback(<span class="literal">null</span>, <span class="string">'hello '</span> + name);
    }, <span class="number">1000</span>);
};
</code></pre>
<pre><code class="js">node&gt; <span class="keyword">async</span>.log(hello, <span class="string">'world'</span>);
<span class="string">'hello world'</span>
</code></pre>
<hr>
<p><a name="dir" /></p>
<h3 id="dir(function,_arguments)">dir(function, arguments)</h3><p>Logs the result of an async function to the console using console.dir to<br>display the properties of the resulting object. Only works in node.js or<br>in browsers that support console.dir and console.error (such as FF and Chrome).<br>If multiple arguments are returned from the async function, console.dir is<br>called on each argument in order.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>function - The function you want to eventually apply all arguments to.</li>
<li>arguments… - Any number of arguments to apply to the function.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params">name, callback</span>)</span>{
    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        callback(<span class="literal">null</span>, {hello: name});
    }, <span class="number">1000</span>);
};
</code></pre>
<pre><code class="js">node&gt; <span class="keyword">async</span>.dir(hello, <span class="string">'world'</span>);
{hello: <span class="string">'world'</span>}
</code></pre>
<hr>
<p><a name="noConflict" /></p>
<h3 id="noConflict()">noConflict()</h3><p>Changes the value of async back to its original value, returning a reference to the<br>async object.</p>
