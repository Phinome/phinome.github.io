<h1 id="yargs">yargs</h1><p>Yargs be a node.js library fer hearties tryin’ ter parse optstrings.</p>
<p>With yargs, ye be havin’ a map that leads straight to yer treasure! Treasure of course, being a simple option hash.</p>
<p><a href="https://travis-ci.org/bcoe/yargs"><img src="https://travis-ci.org/bcoe/yargs.png" alt="Build Status"></a><br><a href="https://gemnasium.com/bcoe/yargs"><img src="https://gemnasium.com/bcoe/yargs.png" alt="Dependency Status"></a><br><a href="https://coveralls.io/r/bcoe/yargs?branch="><img src="https://coveralls.io/repos/bcoe/yargs/badge.svg?branch=" alt="Coverage Status"></a><br><a href="https://www.npmjs.com/package/yargs"><img src="https://img.shields.io/npm/v/yargs.svg" alt="NPM version"></a></p>
<blockquote>
<p>Yargs is the official successor to optimist. Please feel free to submit issues and pull requests. If you’d like to contribute and don’t know where to start, have a look at <a href="https://github.com/bcoe/yargs/issues">the issue list</a> :)</p>
</blockquote>
<h1 id="examples">examples</h1><h2 id="With_yargs,_the_options_be_just_a_hash!">With yargs, the options be just a hash!</h2><p>xup.js:</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>).argv;

<span class="keyword">if</span> (argv.rif - <span class="number">5</span> * argv.xup &gt; <span class="number">7.138</span>) {
    <span class="built_in">console</span>.log(<span class="string">'Plunder more riffiwobbles!'</span>);
}
<span class="keyword">else</span> {
    <span class="built_in">console</span>.log(<span class="string">'Drop the xupptumblers!'</span>);
}
</code></pre>
<hr>
<pre><code><span class="comment">$</span> <span class="string">.</span><span class="comment">/xup</span><span class="string">.</span><span class="comment">js</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">rif=55</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">xup=9</span><span class="string">.</span><span class="comment">52</span>
<span class="comment">Plunder</span> <span class="comment">more</span> <span class="comment">riffiwobbles!</span>

<span class="comment">$</span> <span class="string">.</span><span class="comment">/xup</span><span class="string">.</span><span class="comment">js</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">rif</span> <span class="comment">12</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">xup</span> <span class="comment">8</span><span class="string">.</span><span class="comment">1</span>
<span class="comment">Drop</span> <span class="comment">the</span> <span class="comment">xupptumblers!</span>
</code></pre><p><img src="http://i.imgur.com/4WFGVJ9.png" alt="Joe was one optimistic pirate."></p>
<h2 id="But_don’t_walk_the_plank_just_yet!_There_be_more!_You_can_do_short_options:">But don’t walk the plank just yet! There be more! You can do short options:</h2><p>short.js:</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>).argv;
<span class="built_in">console</span>.log(<span class="string">'(%d,%d)'</span>, argv.x, argv.y);
</code></pre>
<hr>
<pre><code>$ ./short<span class="class">.js</span> -x <span class="number">10</span> -y <span class="number">21</span>
(<span class="number">10</span>,<span class="number">21</span>)
</code></pre><h2 id="And_booleans,_both_long,_short,_and_even_grouped:">And booleans, both long, short, and even grouped:</h2><p>bool.js:</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>).argv;

<span class="keyword">if</span> (argv.s) {
    util.print(argv.fr ? <span class="string">'Le perroquet dit: '</span> : <span class="string">'The parrot says: '</span>);
}
<span class="built_in">console</span>.log(
    (argv.fr ? <span class="string">'couac'</span> : <span class="string">'squawk'</span>) + (argv.p ? <span class="string">'!'</span> : <span class="string">''</span>)
);
</code></pre>
<hr>
<pre><code>$ ./bool<span class="class">.js</span> -s
The parrot says: squawk

$ ./bool<span class="class">.js</span> -sp
The parrot says: squawk!

$ ./bool<span class="class">.js</span> -sp --fr
Le perroquet dit: couac!
</code></pre><h2 id="And_non-hyphenated_options_too!_Just_use_argv-_!">And non-hyphenated options too! Just use <code>argv._</code>!</h2><p>nonopt.js:</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>).argv;
<span class="built_in">console</span>.log(<span class="string">'(%d,%d)'</span>, argv.x, argv.y);
<span class="built_in">console</span>.log(argv._);
</code></pre>
<hr>
<pre><code>$ ./nonopt<span class="class">.js</span> -x <span class="number">6.82</span> -y <span class="number">3.35</span> rum
(<span class="number">6.82</span>,<span class="number">3.35</span>)
[ <span class="string">'rum'</span> ]

$ ./nonopt<span class="class">.js</span> <span class="string">"me hearties"</span> -x <span class="number">0.54</span> yo -y <span class="number">1.12</span> ho
(<span class="number">0.54</span>,<span class="number">1.12</span>)
[ <span class="string">'me hearties'</span>, <span class="string">'yo'</span>, <span class="string">'ho'</span> ]
</code></pre><h2 id="Yargs_even_counts_your_booleans!">Yargs even counts your booleans!</h2><p>count.js</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .count(<span class="string">'verbose'</span>)
    .alias(<span class="string">'v'</span>, <span class="string">'verbose'</span>)
    .argv;

VERBOSE_LEVEL = argv.verbose;

<span class="function"><span class="keyword">function</span> <span class="title">WARN</span>(<span class="params"></span>)  </span>{ VERBOSE_LEVEL &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>); }
<span class="function"><span class="keyword">function</span> <span class="title">INFO</span>(<span class="params"></span>)  </span>{ VERBOSE_LEVEL &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>); }
<span class="function"><span class="keyword">function</span> <span class="title">DEBUG</span>(<span class="params"></span>) </span>{ VERBOSE_LEVEL &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>); }

WARN(<span class="string">"Showing only important stuff"</span>);
INFO(<span class="string">"Showing semi-mportant stuff too"</span>);
DEBUG(<span class="string">"Extra chatty mode"</span>);
</code></pre>
<hr>
<pre><code>$ node <span class="built_in">count</span>.js
Showing <span class="keyword">only</span> important stuff

$ node <span class="built_in">count</span>.js -<span class="keyword">v</span>
Showing <span class="keyword">only</span> important stuff
Showing semi-important stuff too

$ node <span class="built_in">count</span>.js -vv
Showing <span class="keyword">only</span> important stuff
Showing semi-important stuff too
Extra chatty <span class="built_in">mode</span>

$ node <span class="built_in">count</span>.js -<span class="keyword">v</span> --<span class="keyword">verbose</span>
Showing <span class="keyword">only</span> important stuff
Showing semi-important stuff too
Extra chatty <span class="built_in">mode</span>
</code></pre><h2 id="Tell_users_how_to_use_yer_options_and_make_demands-">Tell users how to use yer options and make demands.</h2><p>divide.js:</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .usage(<span class="string">'Usage: $0 -x [num] -y [num]'</span>)
    .demand([<span class="string">'x'</span>,<span class="string">'y'</span>])
    .argv;

<span class="built_in">console</span>.log(argv.x / argv.y);
</code></pre>
<hr>
<pre><code>$ ./divide<span class="class">.js</span> -x <span class="number">55</span> -y <span class="number">11</span>
<span class="number">5</span>

$ node ./divide<span class="class">.js</span> -x <span class="number">4.91</span> -z <span class="number">2.51</span>
Usage: node ./divide<span class="class">.js</span> -x [num] -y [num]

Options:
  -x  [required]
  -y  [required]

Missing required arguments: y
</code></pre><h2 id="After_yer_demands_have_been_met,_demand_more!_Ask_for_non-hypenated_arguments!">After yer demands have been met, demand more! Ask for non-hypenated arguments!</h2><p>demand_count.js:</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .demand(<span class="number">2</span>)
    .argv;
<span class="built_in">console</span>.dir(argv)
</code></pre>
<hr>
<pre><code><span class="variable">$ </span>./demand_count.js a
<span class="constant">Not </span>enough arguments, expected <span class="number">2</span>, but only found <span class="number">1</span>
<span class="variable">$ </span>./demand_count.js a b
{ <span class="constant">_:</span> [ <span class="string">'a'</span>, <span class="string">'b'</span> ], <span class="string">'$0'</span><span class="symbol">:</span> <span class="string">'node ./demand_count.js'</span> }
<span class="variable">$ </span>./demand_count.js a b c
{ <span class="constant">_:</span> [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> ], <span class="string">'$0'</span><span class="symbol">:</span> <span class="string">'node ./demand_count.js'</span> }
</code></pre><h2 id="EVEN_MORE_SHIVER_ME_TIMBERS!">EVEN MORE SHIVER ME TIMBERS!</h2><p>default_singles.js:</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .default(<span class="string">'x'</span>, <span class="number">10</span>)
    .default(<span class="string">'y'</span>, <span class="number">10</span>)
    .argv
;
<span class="built_in">console</span>.log(argv.x + argv.y);
</code></pre>
<hr>
<pre><code>$ ./default_singles<span class="class">.js</span> -x <span class="number">5</span>
<span class="number">15</span>
</code></pre><p>default_hash.js:</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .default({ x : <span class="number">10</span>, y : <span class="number">10</span> })
    .argv
;
<span class="built_in">console</span>.log(argv.x + argv.y);
</code></pre>
<hr>
<pre><code>$ ./default_hash<span class="class">.js</span> -y <span class="number">7</span>
<span class="number">17</span>
</code></pre><h2 id="And_if_you_really_want_to_get_all_descriptive_about_it…">And if you really want to get all descriptive about it…</h2><p>boolean_single.js</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .boolean(<span class="string">'v'</span>)
    .argv
;
<span class="built_in">console</span>.dir(argv.v);
<span class="built_in">console</span>.dir(argv._);
</code></pre>
<hr>
<pre><code><span class="variable">$ </span>./boolean_single.js -v <span class="string">"me hearties"</span> yo ho
<span class="keyword">true</span>
[ <span class="string">'me hearties'</span>, <span class="string">'yo'</span>, <span class="string">'ho'</span> ]
</code></pre><p>boolean_double.js</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .boolean([<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>])
    .argv
;
<span class="built_in">console</span>.dir([ argv.x, argv.y, argv.z ]);
<span class="built_in">console</span>.dir(argv._);
</code></pre>
<hr>
<pre><code><span class="variable">$ </span>./boolean_double.js -x -z one two three
[ <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span> ]
[ <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span> ]
</code></pre><h2 id="Yargs_is_here_to_help_you…">Yargs is here to help you…</h2><p>Ye can describe parameters fer help messages and set aliases. Yargs figures<br>out how ter format a handy help string automatically.</p>
<p>line_count.js</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .usage(<span class="string">'Usage: $0 &lt;command&gt; [options]'</span>)
    .command(<span class="string">'count'</span>, <span class="string">'Count the lines in a file'</span>)
    .demand(<span class="number">1</span>)
    .example(<span class="string">'$0 count -f foo.js'</span>, <span class="string">'count the lines in the given file'</span>)
    .demand(<span class="string">'f'</span>)
    .alias(<span class="string">'f'</span>, <span class="string">'file'</span>)
    .nargs(<span class="string">'f'</span>, <span class="number">1</span>)
    .describe(<span class="string">'f'</span>, <span class="string">'Load a file'</span>)
    .help(<span class="string">'h'</span>)
    .alias(<span class="string">'h'</span>, <span class="string">'help'</span>)
    .epilog(<span class="string">'copyright 2015'</span>)
    .argv;

<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);
<span class="keyword">var</span> s = fs.createReadStream(argv.file);

<span class="keyword">var</span> lines = <span class="number">0</span>;
s.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">buf</span>) </span>{
    lines += buf.toString().match(<span class="regexp">/\n/g</span>).length;
});

s.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(lines);
});
</code></pre>
<hr>
<pre><code>$ node line_count<span class="class">.js</span> count
Usage: node test<span class="class">.js</span> &lt;command&gt; [options]

Commands:
  count    Count the lines <span class="keyword">in</span> <span class="tag">a</span> file

Options:
  -f, --file  Load <span class="tag">a</span> file        [required]
  -h, --help  Show help

Examples:
  node test<span class="class">.js</span> count -f foo<span class="class">.js</span>    count the lines <span class="keyword">in</span> the given file

copyright <span class="number">2015</span>

Missing required arguments: f

$ node line_count<span class="class">.js</span> count --file line_count<span class="class">.js</span>
<span class="number">20</span>

$ node line_count<span class="class">.js</span> count -f line_count<span class="class">.js</span>
<span class="number">20</span>
</code></pre><h1 id="methods">methods</h1><p>By itself,</p>
<pre><code class="javascript"><span class="built_in">require</span>(<span class="string">'yargs'</span>).argv
<span class="string">`</span>
</code></pre>
<p>will use <code>process.argv</code> array to construct the <code>argv</code> object.</p>
<p>You can pass in the <code>process.argv</code> yourself:</p>
<pre><code class="javascript"><span class="built_in">require</span>(<span class="string">'yargs'</span>)([ <span class="string">'-x'</span>, <span class="string">'1'</span>, <span class="string">'-y'</span>, <span class="string">'2'</span> ]).argv
</code></pre>
<p>or use .parse() to do the same thing:</p>
<pre><code class="javascript"><span class="built_in">require</span>(<span class="string">'yargs'</span>).parse([ <span class="string">'-x'</span>, <span class="string">'1'</span>, <span class="string">'-y'</span>, <span class="string">'2'</span> ])
</code></pre>
<p>The rest of these methods below come in just before the terminating <code>.argv</code>.</p>
<h2 id="-alias(key,_alias)">.alias(key, alias)</h2><p>Set key names as equivalent such that updates to a key will propagate to aliases<br>and vice-versa.</p>
<p>Optionally <code>.alias()</code> can take an object that maps keys to aliases.<br>Each key of this object should be the canonical version of the option, and each<br>value should be a string or an array of strings.</p>
<h2 id="-default(key,_value,_[description])">.default(key, value, [description])</h2><p>Set <code>argv[key]</code> to <code>value</code> if no option was specified on <code>process.argv</code>.</p>
<p>Optionally <code>.default()</code> can take an object that maps keys to default values.</p>
<p>But wait, there’s more! the default value can be a <code>function</code> which returns<br>a value. The name of the function will be used in the usage string:</p>
<pre><code class="js"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
  .default(<span class="string">'random'</span>, <span class="function"><span class="keyword">function</span> <span class="title">randomValue</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> <span class="built_in">Math</span>.random() * <span class="number">256</span>;
  }).argv;
</code></pre>
<p>Optionally, <code>description</code> can also be provided and will take precedence over<br>displaying the value in the usage instructions:</p>
<pre><code class="js">.default(<span class="string">'timeout'</span>, <span class="number">60000</span>, <span class="string">'(one-minute)'</span>);
</code></pre>
<h2 id="-demand(key,_[msg_|_boolean])">.demand(key, [msg | boolean])</h2><h2 id="-require(key,_[msg_|_boolean])">.require(key, [msg | boolean])</h2><h2 id="-required(key,_[msg_|_boolean])">.required(key, [msg | boolean])</h2><p>If <code>key</code> is a string, show the usage information and exit if <code>key</code> wasn’t<br>specified in <code>process.argv</code>.</p>
<p>If <code>key</code> is a number, demand at least as many non-option arguments, which show<br>up in <code>argv._</code>.</p>
<p>If <code>key</code> is an Array, demand each element.</p>
<p>If a <code>msg</code> string is given, it will be printed when the argument is missing,<br>instead of the standard error message. This is especially helpful for the non-option arguments in <code>argv._</code>.</p>
<p>If a <code>boolean</code> value is given, it controls whether the option is demanded;<br>this is useful when using <code>.options()</code> to specify command line parameters.</p>
<h2 id="-requiresArg(key)">.requiresArg(key)</h2><p>Specifies either a single option key (string), or an array of options that<br>must be followed by option values. If any option value is missing, show the<br>usage information and exit.</p>
<p>The default behaviour is to set the value of any key not followed by an<br>option value to <code>true</code>.</p>
<h2 id="-implies(x,_y)">.implies(x, y)</h2><p>Given the key <code>x</code> is set, it is required that the key <code>y</code> is set.</p>
<p>implies can also accept an object specifying multiple implications.</p>
<h2 id="-describe(key,_desc)">.describe(key, desc)</h2><p>Describe a <code>key</code> for the generated usage information.</p>
<p>Optionally <code>.describe()</code> can take an object that maps keys to descriptions.</p>
<h2 id="-option(key,_opt)">.option(key, opt)</h2><h2 id="-options(key,_opt)">.options(key, opt)</h2><p>Instead of chaining together <code>.alias().demand().default().describe().string()</code>, you can specify<br>keys in <code>opt</code> for each of the chainable methods.</p>
<p>For example:</p>
<pre><code class="javascript"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .option(<span class="string">'f'</span>, {
        alias : <span class="string">'file'</span>,
        demand: <span class="literal">true</span>,
        <span class="keyword">default</span>: <span class="string">'/etc/passwd'</span>,
        describe: <span class="string">'x marks the spot'</span>,
        type: <span class="string">'string'</span>
    })
    .argv
;
</code></pre>
<p>is the same as</p>
<pre><code class="javascript"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .alias(<span class="string">'f'</span>, <span class="string">'file'</span>)
    .default(<span class="string">'f'</span>, <span class="string">'/etc/passwd'</span>)
    .argv
;
</code></pre>
<p>Optionally <code>.options()</code> can take an object that maps keys to <code>opt</code> parameters.</p>
<pre><code class="javascript"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .options({
      <span class="string">'f'</span>: {
        alias: <span class="string">'file'</span>,
        demand: <span class="literal">true</span>,
        <span class="keyword">default</span>: <span class="string">'/etc/passwd'</span>,
        describe: <span class="string">'x marks the spot'</span>,
        type: <span class="string">'string'</span>
      }
    })
    .argv
;
</code></pre>
<h2 id="-usage(message,_opts)">.usage(message, opts)</h2><p>Set a usage message to show which commands to use. Inside <code>message</code>, the string<br><code>$0</code> will get interpolated to the current script name or node command for the<br>present script similar to how <code>$0</code> works in bash or perl.</p>
<p><code>opts</code> is optional and acts like calling <code>.options(opts)</code>.</p>
<h2 id="-command(cmd,_desc)">.command(cmd, desc)</h2><p>Document the commands exposed by your application (stored in the <code>_</code> variable).</p>
<p>As an example, here’s how the npm cli might document some of its commands:</p>
<pre><code class="js"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
  .usage(<span class="string">'npm &lt;command&gt;'</span>)
  .command(<span class="string">'install'</span>, <span class="string">'tis a mighty fine package to install'</span>)
  .command(<span class="string">'publish'</span>, <span class="string">'shiver me timbers, should you be sharing all that'</span>)
  .argv;
</code></pre>
<h2 id="-example(cmd,_desc)">.example(cmd, desc)</h2><p>Give some example invocations of your program. Inside <code>cmd</code>, the string<br><code>$0</code> will get interpolated to the current script name or node command for the<br>present script similar to how <code>$0</code> works in bash or perl.<br>Examples will be printed out as part of the help message.</p>
<h2 id="-epilogue(str)">.epilogue(str)</h2><h2 id="-epilog(str)">.epilog(str)</h2><p>A message to print at the end of the usage instructions, e.g.,</p>
<pre><code class="js"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
  .epilogue(<span class="string">'for more information, find our manual at http://example.com'</span>);
</code></pre>
<h2 id="-check(fn)">.check(fn)</h2><p>Check that certain conditions are met in the provided arguments.</p>
<p><code>fn</code> is called with two arguments, the parsed <code>argv</code> hash and an array of options and their aliases.</p>
<p>If <code>fn</code> throws or returns a non-truthy value, show the thrown error, usage information, and<br>exit.</p>
<h2 id="-fail(fn)">.fail(fn)</h2><p>Method to execute when a failure occurs, rather then printing the failure message.</p>
<p><code>fn</code> is called with the failure message that would have been printed.</p>
<h2 id="-boolean(key)">.boolean(key)</h2><p>Interpret <code>key</code> as a boolean. If a non-flag option follows <code>key</code> in<br><code>process.argv</code>, that string won’t get set as the value of <code>key</code>.</p>
<p><code>key</code> will default to <code>false</code>, unless an <code>default(key, undefined)</code> is<br>explicitly set.</p>
<p>If <code>key</code> is an Array, interpret all the elements as booleans.</p>
<h2 id="-string(key)">.string(key)</h2><p>Tell the parser logic not to interpret <code>key</code> as a number or boolean.<br>This can be useful if you need to preserve leading zeros in an input.</p>
<p>If <code>key</code> is an Array, interpret all the elements as strings.</p>
<p><code>.string(&#39;_&#39;)</code> will result in non-hyphenated arguments being interpreted as strings,<br>regardless of whether they resemble numbers.</p>
<h2 id="-array(key)">.array(key)</h2><p>Tell the parser to interpret <code>key</code> as an array. If <code>.array(&#39;foo&#39;)</code> is set,<br><code>--foo bar</code> will be parsed as <code>[&#39;bar&#39;]</code> rather than as <code>&#39;bar&#39;</code>.</p>
<h2 id="-nargs(key,_count)">.nargs(key, count)</h2><p>The number of arguments that should be consumed after a key. This can be a<br>useful hint to prevent parsing ambiguity:</p>
<pre><code class="js"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
  .nargs(<span class="string">'token'</span>, <span class="number">1</span>)
  .parse([<span class="string">'--token'</span>, <span class="string">'-my-token'</span>]);
</code></pre>
<p>parses as:</p>
<p><code>{ _: [], token: &#39;-my-token&#39;, &#39;$0&#39;: &#39;node test&#39; }</code></p>
<p>Optionally <code>.nargs()</code> can take an object of <code>key</code>/<code>narg</code> pairs.</p>
<h2 id="-config(key)">.config(key)</h2><p>Tells the parser to interpret <code>key</code> as a path to a JSON config file. The file<br>is loaded and parsed, and its properties are set as arguments.</p>
<h2 id="-wrap(columns)">.wrap(columns)</h2><p>Format usage output to wrap at <code>columns</code> many columns.</p>
<p>By default wrap will be set to <code>Math.min(80, windowWidth)</code>. Use <code>.wrap(null)</code> to<br>specify no column limit.</p>
<h2 id="-strict()">.strict()</h2><p>Any command-line argument given that is not demanded, or does not have a<br>corresponding description, will be reported as an error.</p>
<h2 id="-help([option,_[description]])">.help([option, [description]])</h2><p>Add an option (e.g., <code>--help</code>) that displays the usage string and exits the<br>process. If present, the <code>description</code> parameter customises the description of<br>the help option in the usage string.</p>
<p>If invoked without parameters, <code>.help</code> returns the generated usage string.</p>
<p>Example:</p>
<pre><code>var yargs = require<span class="params">(<span class="string">"yargs"</span>)</span>
       .usage<span class="params">(<span class="string">"$0 -operand1 number -operand2 number -operation [add|subtract]"</span>)</span>;
console.<span class="built_in">log</span><span class="params">(yargs.help<span class="params">()</span>)</span>;
</code></pre><p>Later on, <code>argv</code> can be retrived with <code>yargs.argv</code></p>
<h2 id="-version(version,_[option],_[description])">.version(version, [option], [description])</h2><p>Add an option (e.g., <code>--version</code>) that displays the version number (given by the<br><code>version</code> parameter) and exits the process. If present, the <code>description</code><br>parameter customizes the description of the version option in the usage string.</p>
<p>You can provide a <code>function</code> for version, rather than a string.<br>This is useful if you want to use the version from your package.json:</p>
<pre><code class="js"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
  .version(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">'../package'</span>).version;
  })
  .argv;
</code></pre>
<h2 id="-showHelpOnFail(enable,_[message])">.showHelpOnFail(enable, [message])</h2><p>By default, yargs outputs a usage string if any error is detected. Use the<br><code>.showHelpOnFail</code> method to customize this behaviour. if <code>enable</code> is <code>false</code>,<br>the usage string is not output. If the <code>message</code> parameter is present, this<br>message is output after the error message.</p>
<p>line_count.js</p>
<pre><code class="javascript">#!<span class="regexp">/usr/</span>bin/env node
<span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
    .usage(<span class="string">'Count the lines in a file.\nUsage: $0'</span>)
    .demand(<span class="string">'f'</span>)
    .alias(<span class="string">'f'</span>, <span class="string">'file'</span>)
    .describe(<span class="string">'f'</span>, <span class="string">'Load a file'</span>)
    .showHelpOnFail(<span class="literal">false</span>, <span class="string">"Specify --help for available options"</span>)
    .argv;

<span class="comment">// etc.</span>
</code></pre>
<hr>
<pre><code>$ node line_count.js --<span class="keyword">file</span>
Missing argument value: <span class="literal">f</span>

Specify --<span class="keyword">help</span> <span class="keyword">for</span> available options
</code></pre><h2 id="-showHelp(fn=console-error)">.showHelp(fn=console.error)</h2><p>Print the usage data using <code>fn</code> for printing.</p>
<p>Example:</p>
<pre><code>var yargs = require<span class="params">(<span class="string">"yargs"</span>)</span>
       .usage<span class="params">(<span class="string">"$0 -operand1 number -operand2 number -operation [add|subtract]"</span>)</span>;
yargs.showHelp<span class="params">()</span>;
</code></pre><p>Later on, <code>argv</code> can be retrived with <code>yargs.argv</code></p>
<h2 id="-completion(cmd,_[description],_[fn]);">.completion(cmd, [description], [fn]);</h2><p>Enable bash-completion shortcuts for commands and options.</p>
<p><code>cmd</code>: when present in <code>argv._</code>, will result in the <code>.bashrc</code> completion script<br>being outputted. To enable bash completions, concat the generated script to your<br><code>.bashrc</code>, or <code>.bash_profile</code>.</p>
<p><code>description</code>: provide a description in your usage instructions for the command<br>that generates bash completion scripts.</p>
<p><code>fn</code>, rather than relying on yargs’ default completion functionlity, which<br>shiver me timbers is pretty awesome, you can provide your own completion<br>method.</p>
<pre><code class="js"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
  .completion(<span class="string">'completion'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">current, argv</span>) </span>{
    <span class="comment">// 'current' is the current command being completed.</span>
    <span class="comment">// 'argv' is the parsed arguments so far.</span>
    <span class="comment">// simply return an array of completions.</span>
    <span class="keyword">return</span> [
      <span class="string">'foo'</span>,
      <span class="string">'bar'</span>
    ];
  })
  .argv;
</code></pre>
<p>But wait, there’s more! you can provide asynchronous completions.</p>
<pre><code class="js"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>)
  .completion(<span class="string">'completion'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">current, argv, done</span>) </span>{
    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
      done([
        <span class="string">'apple'</span>,
        <span class="string">'banana'</span>
      ]);
    }, <span class="number">500</span>);
  })
  .argv;
</code></pre>
<h2 id="-showCompletionScript()">.showCompletionScript()</h2><p>Generate a bash completion script. Users of your application can install this<br>script in their <code>.bashrc</code>, and yargs will provide completion shortcuts for<br>commands and options.</p>
<h2 id="-exitProcess(enable)">.exitProcess(enable)</h2><p>By default, yargs exits the process when the user passes a help flag, uses the <code>.version</code> functionality or when validation fails. Calling <code>.exitProcess(false)</code> disables this behavior, enabling further actions after yargs have been validated.</p>
<h2 id="-parse(args)">.parse(args)</h2><p>Parse <code>args</code> instead of <code>process.argv</code>. Returns the <code>argv</code> object.</p>
<h2 id="-reset()">.reset()</h2><p>Reset the argument object built up so far. This is useful for<br>creating nested command line interfaces.</p>
<pre><code class="js"><span class="keyword">var</span> yargs = <span class="built_in">require</span>(<span class="string">'./yargs'</span>)
  .usage(<span class="string">'$0 command'</span>)
  .command(<span class="string">'hello'</span>, <span class="string">'hello command'</span>)
  .command(<span class="string">'world'</span>, <span class="string">'world command'</span>)
  .demand(<span class="number">1</span>, <span class="string">'must provide a valid command'</span>),
  argv = yargs.argv,
  command = argv._[<span class="number">0</span>];

<span class="keyword">if</span> (command === <span class="string">'hello'</span>) {
  yargs.reset()
    .usage(<span class="string">'$0 hello'</span>)
    .help(<span class="string">'h'</span>)
    .example(<span class="string">'$0 hello'</span>, <span class="string">'print the hello message!'</span>)
    .argv

  <span class="built_in">console</span>.log(<span class="string">'hello!'</span>);
} <span class="keyword">else</span> <span class="keyword">if</span> (command === <span class="string">'world'</span>){
  yargs.reset()
    .usage(<span class="string">'$0 world'</span>)
    .help(<span class="string">'h'</span>)
    .example(<span class="string">'$0 world'</span>, <span class="string">'print the world message!'</span>)
    .argv

  <span class="built_in">console</span>.log(<span class="string">'world!'</span>);
} <span class="keyword">else</span> {
  yargs.showHelp();
}
</code></pre>
<h2 id="-argv">.argv</h2><p>Get the arguments as a plain old object.</p>
<p>Arguments without a corresponding flag show up in the <code>argv._</code> array.</p>
<p>The script name or node command is available at <code>argv.$0</code> similarly to how <code>$0</code><br>works in bash or perl.</p>
<h1 id="parsing_tricks">parsing tricks</h1><h2 id="stop_parsing">stop parsing</h2><p>Use <code>--</code> to stop parsing flags and stuff the remainder into <code>argv._</code>.</p>
<pre><code>$ node examples/reflect.js -<span class="operator">a</span> <span class="number">1</span> -b <span class="number">2</span> <span class="comment">-- -c 3 -d 4</span>
{ _: [ <span class="string">'-c'</span>, <span class="string">'3'</span>, <span class="string">'-d'</span>, <span class="string">'4'</span> ],
  <span class="string">'$0'</span>: <span class="string">'node ./examples/reflect.js'</span>,
  <span class="operator">a</span>: <span class="number">1</span>,
  b: <span class="number">2</span> }
</code></pre><h2 id="negate_fields">negate fields</h2><p>If you want to explicity set a field to false instead of just leaving it<br>undefined or to override a default you can do <code>--no-key</code>.</p>
<pre><code>$ node examples/reflect.js -<span class="operator">a</span> <span class="comment">--no-b</span>
{ _: [],
  <span class="string">'$0'</span>: <span class="string">'node ./examples/reflect.js'</span>,
  <span class="operator">a</span>: <span class="constant">true</span>,
  b: <span class="constant">false</span> }
</code></pre><h2 id="numbers">numbers</h2><p>Every argument that looks like a number (<code>!isNaN(Number(arg))</code>) is converted to<br>one. This way you can just <code>net.createConnection(argv.port)</code> and you can add<br>numbers out of <code>argv</code> with <code>+</code> without having that mean concatenation,<br>which is super frustrating.</p>
<h2 id="duplicates">duplicates</h2><p>If you specify a flag multiple times it will get turned into an array containing<br>all the values in order.</p>
<pre><code>$ <span class="atom">node</span> <span class="atom">examples</span>/<span class="atom">reflect</span>.<span class="atom">js</span> -<span class="atom">x</span> <span class="number">5</span> -<span class="atom">x</span> <span class="number">8</span> -<span class="atom">x</span> <span class="number">0</span>
{ <span class="name">_</span>: [],
  <span class="string">'$0'</span>: <span class="string">'node ./examples/reflect.js'</span>,
    <span class="atom">x</span>: [ <span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span> ] }
</code></pre><h2 id="dot_notation">dot notation</h2><p>When you use dots (<code>.</code>s) in argument names, an implicit object path is assumed.<br>This lets you organize arguments into nested objects.</p>
<pre><code>$ node examples/reflect.js --foo.bar.baz=<span class="number">33</span> --foo.quux=<span class="number">5</span>
{ <span class="string">_:</span> [],
  <span class="string">'$0'</span>: <span class="string">'node ./examples/reflect.js'</span>,
<span class="label">    foo:</span> { <span class="string">bar:</span> { <span class="string">baz:</span> <span class="number">33</span> }, <span class="string">quux:</span> <span class="number">5</span> } }
</code></pre><h2 id="short_numbers">short numbers</h2><p>Short numeric <code>head -n5</code> style argument work too:</p>
<pre><code><span class="variable">$ </span>node reflect.js -n123 -m456
{ <span class="string">'3'</span><span class="symbol">:</span> <span class="keyword">true</span>,
  <span class="string">'6'</span><span class="symbol">:</span> <span class="keyword">true</span>,
  <span class="constant">_:</span> [],
  <span class="string">'$0'</span><span class="symbol">:</span> <span class="string">'node ./reflect.js'</span>,
  <span class="symbol">n:</span> <span class="number">123</span>,
  <span class="symbol">m:</span> <span class="number">456</span> }
</code></pre><h1 id="installation">installation</h1><p>With <a href="http://github.com/isaacs/npm">npm</a>, just do:</p>
<pre><code>npm <span class="keyword">install</span> yargs
</code></pre><p>or clone this project on github:</p>
<pre><code>git clone <span class="string">http:</span><span class="comment">//github.com/bcoe/yargs.git</span>
</code></pre><p>To run the tests with npm, just do:</p>
<pre><code>npm <span class="built_in">test</span>
</code></pre><h1 id="inspired_by">inspired by</h1><p>This module is loosely inspired by Perl’s<br><a href="http://search.cpan.org/~photo/Getopt-Casual-0.13.1/Casual.pm">Getopt::Casual</a>.</p>
