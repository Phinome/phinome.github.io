<h1 id="ASAP">ASAP</h1><p>This <code>asap</code> CommonJS package contains a single <code>asap</code> module that<br>exports a single <code>asap</code> function that executes a function <strong>as soon as<br>possible</strong>.</p>
<pre><code class="javascript">asap(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="comment">// ...</span>
});
</code></pre>
<p>More formally, ASAP provides a fast event queue that will execute tasks<br>until it is empty before yielding to the JavaScript engine’s underlying<br>event-loop.  When the event queue becomes non-empty, ASAP schedules a<br>flush event, preferring for that event to occur before the JavaScript<br>engine has an opportunity to perform IO tasks or rendering, thus making<br>the first task and subsequent tasks semantically indistinguishable.<br>ASAP uses a variety of techniques to preserve this invariant on<br>different versions of browsers and NodeJS.</p>
<p>By design, ASAP can starve the event loop on the theory that, if there<br>is enough work to be done synchronously, albeit in separate events, long<br>enough to starve input or output, it is a strong indicator that the<br>program needs to push back on scheduling more work.</p>
<p>Take care.  ASAP can sustain infinite recursive calls indefinitely<br>without warning.  This is behaviorally equivalent to an infinite loop.<br>It will not halt from a stack overflow, but it <em>will</em> chew through<br>memory (which is an oddity I cannot explain at this time).  Just as with<br>infinite loops, you can monitor a Node process for this behavior with a<br>heart-beat signal.  As with infinite loops, a very small amount of<br>caution goes a long way to avoiding problems.</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>{
    asap(loop);
}
loop();
</code></pre>
<p>ASAP is distinct from <code>setImmediate</code> in that it does not suffer the<br>overhead of returning a handle and being possible to cancel.  For a<br><code>setImmediate</code> shim, consider <a href="https://github.com/noblejs/setimmediate">setImmediate</a>.</p>
<p>If a task throws an exception, it will not interrupt the flushing of<br>high-priority tasks.  The exception will be postponed to a later,<br>low-priority event to avoid slow-downs, when the underlying JavaScript<br>engine will treat it as it does any unhandled exception.</p>
<h2 id="Heritage">Heritage</h2><p>ASAP has been factored out of the <a href="https://github.com/kriskowal/q">Q</a> asynchronous promise library.<br>It originally had a naïve implementation in terms of <code>setTimeout</code>, but<br><a href="http://www.nonblocking.io/2011/06/windownexttick.html">Malte Ubl</a> provided an insight that <code>postMessage</code> might be<br>useful for creating a high-priority, no-delay event dispatch hack.<br>Since then, Internet Explorer proposed and implemented <code>setImmediate</code>.<br>Robert Kratić began contributing to Q by measuring the performance of<br>the internal implementation of <code>asap</code>, paying particular attention to<br>error recovery.  Domenic, Robert, and I collectively settled on the<br>current strategy of unrolling the high-priority event queue internally<br>regardless of what strategy we used to dispatch the potentially<br>lower-priority flush event.  Domenic went on to make ASAP cooperate with<br>NodeJS domains.</p>
<p>For further reading, Nicholas Zakas provided a thorough article on <a href="http://www.nczonline.net/blog/2013/07/09/the-case-for-setimmediate/">The<br>Case for setImmediate</a>.</p>
<h2 id="License">License</h2><p>Copyright 2009-2013 by Contributors<br>MIT License (enclosed)</p>
