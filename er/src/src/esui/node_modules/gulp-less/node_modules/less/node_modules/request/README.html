<h1 id="Request_-_Simplified_HTTP_client">Request - Simplified HTTP client</h1><p><a href="https://nodei.co/npm/request/"><img src="https://nodei.co/npm/request.png?downloads=true&amp;downloadRank=true&amp;stars=true" alt="npm package"></a></p>
<p><a href="https://travis-ci.org/request/request"><img src="https://img.shields.io/travis/request/request.svg?style=flat-square" alt="Build status"></a><br><a href="https://coveralls.io/r/request/request"><img src="https://img.shields.io/coveralls/request/request.svg?style=flat-square" alt="Coverage"></a><br><a href="https://gitter.im/request/request?utm_source=badge"><img src="https://img.shields.io/badge/gitter-join_chat-blue.svg?style=flat-square" alt="Gitter"></a></p>
<h2 id="Super_simple_to_use">Super simple to use</h2><p>Request is designed to be the simplest way possible to make http calls. It supports HTTPS and follows redirects by default.</p>
<pre><code class="js"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);
request(<span class="string">'http://www.google.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>{
  <span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>) {
    <span class="built_in">console</span>.log(body) <span class="comment">// Show the HTML for the Google homepage.</span>
  }
})
</code></pre>
<h2 id="Table_of_contents">Table of contents</h2><ul>
<li><a href="#streaming">Streaming</a></li>
<li><a href="#forms">Forms</a></li>
<li><a href="#http-authentication">HTTP Authentication</a></li>
<li><a href="#custom-http-headers">Custom HTTP Headers</a></li>
<li><a href="#oauth-signing">OAuth Signing</a></li>
<li><a href="#proxies">Proxies</a></li>
<li><a href="#unix-domain-sockets">Unix Domain Sockets</a></li>
<li><a href="#tlsssl-protocol">TLS/SSL Protocol</a></li>
<li><a href="#support-for-har-12">Support for HAR 1.2</a></li>
<li><a href="#requestoptions-callback"><strong>All Available Options</strong></a></li>
</ul>
<p>Request also offers <a href="#convenience-methods">convenience methods</a> like<br><code>request.defaults</code> and <code>request.post</code>, and there are<br>lots of <a href="#examples">usage examples</a> and several<br><a href="#debugging">debugging techniques</a>.</p>
<hr>
<h2 id="Streaming">Streaming</h2><p>You can stream any response to a file stream.</p>
<pre><code class="js">request(<span class="string">'http://google.com/doodle.png'</span>).pipe(fs.createWriteStream(<span class="string">'doodle.png'</span>))
</code></pre>
<p>You can also stream a file to a PUT or POST request. This method will also check the file extension against a mapping of file extensions to content-types (in this case <code>application/json</code>) and use the proper <code>content-type</code> in the PUT request (if the headers don’t already provide one).</p>
<pre><code class="js">fs.createReadStream(<span class="string">'file.json'</span>).pipe(request.put(<span class="string">'http://mysite.com/obj.json'</span>))
</code></pre>
<p>Request can also <code>pipe</code> to itself. When doing so, <code>content-type</code> and <code>content-length</code> are preserved in the PUT headers.</p>
<pre><code class="js">request.get(<span class="string">'http://google.com/img.png'</span>).pipe(request.put(<span class="string">'http://mysite.com/img.png'</span>))
</code></pre>
<p>Request emits a “response” event when a response is received. The <code>response</code> argument will be an instance of <a href="http://nodejs.org/api/http.html#http_http_incomingmessage">http.IncomingMessage</a>.</p>
<pre><code class="js">request
  .get(<span class="string">'http://google.com/img.png'</span>)
  .on(<span class="string">'response'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>{
    <span class="built_in">console</span>.log(response.statusCode) <span class="comment">// 200</span>
    <span class="built_in">console</span>.log(response.headers[<span class="string">'content-type'</span>]) <span class="comment">// 'image/png'</span>
  })
  .pipe(request.put(<span class="string">'http://mysite.com/img.png'</span>))
</code></pre>
<p>To easily handle errors when streaming requests, listen to the <code>error</code> event before piping:</p>
<pre><code class="js">request
  .get(<span class="string">'http://mysite.com/doodle.png'</span>)
  .on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(err)
  })
  .pipe(fs.createWriteStream(<span class="string">'doodle.png'</span>))
</code></pre>
<p>Now let’s get fancy.</p>
<pre><code class="js">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, resp</span>) </span>{
  <span class="keyword">if</span> (req.url === <span class="string">'/doodle.png'</span>) {
    <span class="keyword">if</span> (req.method === <span class="string">'PUT'</span>) {
      req.pipe(request.put(<span class="string">'http://mysite.com/doodle.png'</span>))
    } <span class="keyword">else</span> <span class="keyword">if</span> (req.method === <span class="string">'GET'</span> || req.method === <span class="string">'HEAD'</span>) {
      request.get(<span class="string">'http://mysite.com/doodle.png'</span>).pipe(resp)
    }
  }
})
</code></pre>
<p>You can also <code>pipe()</code> from <code>http.ServerRequest</code> instances, as well as to <code>http.ServerResponse</code> instances. The HTTP method, headers, and entity-body data will be sent. Which means that, if you don’t really care about security, you can do:</p>
<pre><code class="js">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, resp</span>) </span>{
  <span class="keyword">if</span> (req.url === <span class="string">'/doodle.png'</span>) {
    <span class="keyword">var</span> x = request(<span class="string">'http://mysite.com/doodle.png'</span>)
    req.pipe(x)
    x.pipe(resp)
  }
})
</code></pre>
<p>And since <code>pipe()</code> returns the destination stream in ≥ Node 0.5.x you can do one line proxying. :)</p>
<pre><code class="js">req.pipe(request(<span class="string">'http://mysite.com/doodle.png'</span>)).pipe(resp)
</code></pre>
<p>Also, none of this new functionality conflicts with requests previous features, it just expands them.</p>
<pre><code class="js"><span class="keyword">var</span> r = request.defaults({<span class="string">'proxy'</span>:<span class="string">'http://localproxy.com'</span>})

http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, resp</span>) </span>{
  <span class="keyword">if</span> (req.url === <span class="string">'/doodle.png'</span>) {
    r.get(<span class="string">'http://google.com/doodle.png'</span>).pipe(resp)
  }
})
</code></pre>
<p>You can still use intermediate proxies, the requests will still follow HTTP forwards, etc.</p>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="Forms">Forms</h2><p><code>request</code> supports <code>application/x-www-form-urlencoded</code> and <code>multipart/form-data</code> form uploads. For <code>multipart/related</code> refer to the <code>multipart</code> API.</p>
<h4 id="application/x-www-form-urlencoded_(URL-Encoded_Forms)">application/x-www-form-urlencoded (URL-Encoded Forms)</h4><p>URL-encoded forms are simple.</p>
<pre><code class="js">request.post(<span class="string">'http://service.com/upload'</span>, {form:{key:<span class="string">'value'</span>}})
<span class="comment">// or</span>
request.post(<span class="string">'http://service.com/upload'</span>).form({key:<span class="string">'value'</span>})
<span class="comment">// or</span>
request.post({url:<span class="string">'http://service.com/upload'</span>, form: {key:<span class="string">'value'</span>}}, <span class="function"><span class="keyword">function</span>(<span class="params">err,httpResponse,body</span>)</span>{ <span class="comment">/* ... */</span> })
</code></pre>
<h4 id="multipart/form-data_(Multipart_Form_Uploads)">multipart/form-data (Multipart Form Uploads)</h4><p>For <code>multipart/form-data</code> we use the <a href="https://github.com/felixge/node-form-data">form-data</a> library by <a href="https://github.com/felixge">@felixge</a>. For the most cases, you can pass your upload form data via the <code>formData</code> option.</p>
<pre><code class="js"><span class="keyword">var</span> formData = {
  <span class="comment">// Pass a simple key-value pair</span>
  my_field: <span class="string">'my_value'</span>,
  <span class="comment">// Pass data via Buffers</span>
  my_buffer: <span class="keyword">new</span> Buffer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]),
  <span class="comment">// Pass data via Streams</span>
  my_file: fs.createReadStream(__dirname + <span class="string">'/unicycle.jpg'</span>),
  <span class="comment">// Pass multiple values /w an Array</span>
  attachments: [
    fs.createReadStream(__dirname + <span class="string">'/attachment1.jpg'</span>),
    fs.createReadStream(__dirname + <span class="string">'/attachment2.jpg'</span>)
  ],
  <span class="comment">// Pass optional meta-data with an 'options' object with style: {value: DATA, options: OPTIONS}</span>
  <span class="comment">// Use case: for some types of streams, you'll need to provide "file"-related information manually.</span>
  <span class="comment">// See the `form-data` README for more information about options: https://github.com/felixge/node-form-data</span>
  custom_file: {
    value:  fs.createReadStream(<span class="string">'/dev/urandom'</span>),
    options: {
      filename: <span class="string">'topsecret.jpg'</span>,
      contentType: <span class="string">'image/jpg'</span>
    }
  }
};
request.post({url:<span class="string">'http://service.com/upload'</span>, formData: formData}, <span class="function"><span class="keyword">function</span> <span class="title">optionalCallback</span>(<span class="params">err, httpResponse, body</span>) </span>{
  <span class="keyword">if</span> (err) {
    <span class="keyword">return</span> <span class="built_in">console</span>.error(<span class="string">'upload failed:'</span>, err);
  }
  <span class="built_in">console</span>.log(<span class="string">'Upload successful!  Server responded with:'</span>, body);
});
</code></pre>
<p>For advanced cases, you can access the form-data object itself via <code>r.form()</code>. This can be modified until the request is fired on the next cycle of the event-loop. (Note that this calling <code>form()</code> will clear the currently set form data for that request.)</p>
<pre><code class="js"><span class="comment">// <span class="doctag">NOTE</span>: Advanced use-case, for normal use see 'formData' usage above</span>
<span class="keyword">var</span> r = request.post(<span class="string">'http://service.com/upload'</span>, <span class="function"><span class="keyword">function</span> <span class="title">optionalCallback</span>(<span class="params">err, httpResponse, body</span>) </span>{ <span class="comment">// ...</span>

<span class="keyword">var</span> form = r.form();
form.append(<span class="string">'my_field'</span>, <span class="string">'my_value'</span>);
form.append(<span class="string">'my_buffer'</span>, <span class="keyword">new</span> Buffer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));
form.append(<span class="string">'custom_file'</span>, fs.createReadStream(__dirname + <span class="string">'/unicycle.jpg'</span>), {filename: <span class="string">'unicycle.jpg'</span>});
</code></pre>
<p>See the <a href="https://github.com/felixge/node-form-data">form-data README</a> for more information &amp; examples.</p>
<h4 id="multipart/related">multipart/related</h4><p>Some variations in different HTTP implementations require a newline/CRLF before, after, or both before and after the boundary of a <code>multipart/related</code> request (using the multipart option). This has been observed in the .NET WebAPI version 4.0. You can turn on a boundary preambleCRLF or postamble by passing them as <code>true</code> to your request options.</p>
<pre><code class="js">request({
  method: <span class="string">'PUT'</span>,
  preambleCRLF: <span class="literal">true</span>,
  postambleCRLF: <span class="literal">true</span>,
  uri: <span class="string">'http://service.com/upload'</span>,
  multipart: [
    {
      <span class="string">'content-type'</span>: <span class="string">'application/json'</span>
      body: <span class="built_in">JSON</span>.stringify({foo: <span class="string">'bar'</span>, _attachments: {<span class="string">'message.txt'</span>: {follows: <span class="literal">true</span>, length: <span class="number">18</span>, <span class="string">'content_type'</span>: <span class="string">'text/plain'</span> }}})
    },
    { body: <span class="string">'I am an attachment'</span> },
    { body: fs.createReadStream(<span class="string">'image.png'</span>) }
  ],
  <span class="comment">// alternatively pass an object containing additional options</span>
  multipart: {
    chunked: <span class="literal">false</span>,
    data: [
      {
        <span class="string">'content-type'</span>: <span class="string">'application/json'</span>,
        body: <span class="built_in">JSON</span>.stringify({foo: <span class="string">'bar'</span>, _attachments: {<span class="string">'message.txt'</span>: {follows: <span class="literal">true</span>, length: <span class="number">18</span>, <span class="string">'content_type'</span>: <span class="string">'text/plain'</span> }}})
      },
      { body: <span class="string">'I am an attachment'</span> }
    ]
  }
},
<span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>{
  <span class="keyword">if</span> (error) {
    <span class="keyword">return</span> <span class="built_in">console</span>.error(<span class="string">'upload failed:'</span>, error);
  }
  <span class="built_in">console</span>.log(<span class="string">'Upload successful!  Server responded with:'</span>, body);
})
</code></pre>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="HTTP_Authentication">HTTP Authentication</h2><pre><code class="js">request.get(<span class="string">'http://some.server.com/'</span>).auth(<span class="string">'username'</span>, <span class="string">'password'</span>, <span class="literal">false</span>);
<span class="comment">// or</span>
request.get(<span class="string">'http://some.server.com/'</span>, {
  <span class="string">'auth'</span>: {
    <span class="string">'user'</span>: <span class="string">'username'</span>,
    <span class="string">'pass'</span>: <span class="string">'password'</span>,
    <span class="string">'sendImmediately'</span>: <span class="literal">false</span>
  }
});
<span class="comment">// or</span>
request.get(<span class="string">'http://some.server.com/'</span>).auth(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>, <span class="string">'bearerToken'</span>);
<span class="comment">// or</span>
request.get(<span class="string">'http://some.server.com/'</span>, {
  <span class="string">'auth'</span>: {
    <span class="string">'bearer'</span>: <span class="string">'bearerToken'</span>
  }
});
</code></pre>
<p>If passed as an option, <code>auth</code> should be a hash containing values:</p>
<ul>
<li><code>user</code> || <code>username</code></li>
<li><code>pass</code> || <code>password</code></li>
<li><code>sendImmediately</code> (optional)</li>
<li><code>bearer</code> (optional)</li>
</ul>
<p>The method form takes parameters<br><code>auth(username, password, sendImmediately, bearer)</code>.</p>
<p><code>sendImmediately</code> defaults to <code>true</code>, which causes a basic or bearer<br>authentication header to be sent.  If <code>sendImmediately</code> is <code>false</code>, then<br><code>request</code> will retry with a proper authentication header after receiving a<br><code>401</code> response from the server (which must contain a <code>WWW-Authenticate</code> header<br>indicating the required authentication method).</p>
<p>Note that you can also specify basic authentication using the URL itself, as<br>detailed in <a href="http://www.ietf.org/rfc/rfc1738.txt">RFC 1738</a>.  Simply pass the<br><code>user:password</code> before the host with an <code>@</code> sign:</p>
<pre><code class="js"><span class="keyword">var</span> username = <span class="string">'username'</span>,
    password = <span class="string">'password'</span>,
    url = <span class="string">'http://'</span> + username + <span class="string">':'</span> + password + <span class="string">'@some.server.com'</span>;

request({url: url}, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>{
   <span class="comment">// Do more stuff with 'body' here</span>
});
</code></pre>
<p>Digest authentication is supported, but it only works with <code>sendImmediately</code><br>set to <code>false</code>; otherwise <code>request</code> will send basic authentication on the<br>initial request, which will probably cause the request to fail.</p>
<p>Bearer authentication is supported, and is activated when the <code>bearer</code> value is<br>available. The value may be either a <code>String</code> or a <code>Function</code> returning a<br><code>String</code>. Using a function to supply the bearer token is particularly useful if<br>used in conjuction with <code>defaults</code> to allow a single function to supply the<br>last known token at the time of sending a request, or to compute one on the fly.</p>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="Custom_HTTP_Headers">Custom HTTP Headers</h2><p>HTTP Headers, such as <code>User-Agent</code>, can be set in the <code>options</code> object.<br>In the example below, we call the github API to find out the number<br>of stars and forks for the request repository. This requires a<br>custom <code>User-Agent</code> header as well as https.</p>
<pre><code class="js"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);

<span class="keyword">var</span> options = {
  url: <span class="string">'https://api.github.com/repos/request/request'</span>,
  headers: {
    <span class="string">'User-Agent'</span>: <span class="string">'request'</span>
  }
};

<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">error, response, body</span>) </span>{
  <span class="keyword">if</span> (!error &amp;&amp; response.statusCode == <span class="number">200</span>) {
    <span class="keyword">var</span> info = <span class="built_in">JSON</span>.parse(body);
    <span class="built_in">console</span>.log(info.stargazers_count + <span class="string">" Stars"</span>);
    <span class="built_in">console</span>.log(info.forks_count + <span class="string">" Forks"</span>);
  }
}

request(options, callback);
</code></pre>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="OAuth_Signing">OAuth Signing</h2><p><a href="https://tools.ietf.org/html/rfc5849">OAuth version 1.0</a> is supported.  The<br>default signing algorithm is<br><a href="https://tools.ietf.org/html/rfc5849#section-3.4.2">HMAC-SHA1</a>:</p>
<pre><code class="js"><span class="comment">// OAuth1.0 - 3-legged server side flow (Twitter example)</span>
<span class="comment">// step 1</span>
<span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>)
  , oauth =
    { callback: <span class="string">'http://mysite.com/callback/'</span>
    , consumer_key: CONSUMER_KEY
    , consumer_secret: CONSUMER_SECRET
    }
  , url = <span class="string">'https://api.twitter.com/oauth/request_token'</span>
  ;
request.post({url:url, oauth:oauth}, <span class="function"><span class="keyword">function</span> (<span class="params">e, r, body</span>) </span>{
  <span class="comment">// Ideally, you would take the body in the response</span>
  <span class="comment">// and construct a URL that a user clicks on (like a sign in button).</span>
  <span class="comment">// The verifier is only available in the response after a user has</span>
  <span class="comment">// verified with twitter that they are authorizing your app.</span>

  <span class="comment">// step 2</span>
  <span class="keyword">var</span> req_data = qs.parse(body)
  <span class="keyword">var</span> uri = <span class="string">'https://api.twitter.com/oauth/authenticate'</span>
    + <span class="string">'?'</span> + qs.stringify({oauth_token: req_data.oauth_token})
  <span class="comment">// redirect the user to the authorize uri</span>

  <span class="comment">// step 3</span>
  <span class="comment">// after the user is redirected back to your server</span>
  <span class="keyword">var</span> auth_data = qs.parse(body)
    , oauth =
      { consumer_key: CONSUMER_KEY
      , consumer_secret: CONSUMER_SECRET
      , token: auth_data.oauth_token
      , token_secret: req_data.oauth_token_secret
      , verifier: auth_data.oauth_verifier
      }
    , url = <span class="string">'https://api.twitter.com/oauth/access_token'</span>
    ;
  request.post({url:url, oauth:oauth}, <span class="function"><span class="keyword">function</span> (<span class="params">e, r, body</span>) </span>{
    <span class="comment">// ready to make signed requests on behalf of the user</span>
    <span class="keyword">var</span> perm_data = qs.parse(body)
      , oauth =
        { consumer_key: CONSUMER_KEY
        , consumer_secret: CONSUMER_SECRET
        , token: perm_data.oauth_token
        , token_secret: perm_data.oauth_token_secret
        }
      , url = <span class="string">'https://api.twitter.com/1.1/users/show.json'</span>
      , qs =
        { screen_name: perm_data.screen_name
        , user_id: perm_data.user_id
        }
      ;
    request.get({url:url, oauth:oauth, json:<span class="literal">true</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">e, r, user</span>) </span>{
      <span class="built_in">console</span>.log(user)
    })
  })
})
</code></pre>
<p>For <a href="https://tools.ietf.org/html/rfc5849#section-3.4.3">RSA-SHA1 signing</a>, make<br>the following changes to the OAuth options object:</p>
<ul>
<li>Pass <code>signature_method : &#39;RSA-SHA1&#39;</code></li>
<li>Instead of <code>consumer_secret</code>, specify a <code>private_key</code> string in<br><a href="http://how2ssl.com/articles/working_with_pem_files/">PEM format</a></li>
</ul>
<p>For <a href="http://oauth.net/core/1.0/#anchor22">PLAINTEXT signing</a>, make<br>the following changes to the OAuth options object:</p>
<ul>
<li>Pass <code>signature_method : &#39;PLAINTEXT&#39;</code></li>
</ul>
<p>To send OAuth parameters via query params or in a post body as described in The<br><a href="http://oauth.net/core/1.0/#consumer_req_param">Consumer Request Parameters</a><br>section of the oauth1 spec:</p>
<ul>
<li>Pass <code>transport_method : &#39;query&#39;</code> or <code>transport_method : &#39;body&#39;</code> in the OAuth<br>options object.</li>
<li><code>transport_method</code> defaults to <code>&#39;header&#39;</code></li>
</ul>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="Proxies">Proxies</h2><p>If you specify a <code>proxy</code> option, then the request (and any subsequent<br>redirects) will be sent via a connection to the proxy server.</p>
<p>If your endpoint is an <code>https</code> url, and you are using a proxy, then<br>request will send a <code>CONNECT</code> request to the proxy server <em>first</em>, and<br>then use the supplied connection to connect to the endpoint.</p>
<p>That is, first it will make a request like:</p>
<pre><code><span class="status">HTTP/1.1 CONNECT endpoint-server.com:80</span>
<span class="attribute">Host</span>: <span class="string">proxy-server.com</span>
<span class="attribute">User-Agent</span>: <span class="string">whatever user agent you specify</span>
</code></pre><p>and then the proxy server make a TCP connection to <code>endpoint-server</code><br>on port <code>80</code>, and return a response that looks like:</p>
<pre><code><span class="status">HTTP/1.1 <span class="number">200</span> OK</span>
</code></pre><p>At this point, the connection is left open, and the client is<br>communicating directly with the <code>endpoint-server.com</code> machine.</p>
<p>See <a href="http://en.wikipedia.org/wiki/HTTP_tunnel">the wikipedia page on HTTP Tunneling</a><br>for more information.</p>
<p>By default, when proxying <code>http</code> traffic, request will simply make a<br>standard proxied <code>http</code> request.  This is done by making the <code>url</code><br>section of the initial line of the request a fully qualified url to<br>the endpoint.</p>
<p>For example, it will make a single request that looks like:</p>
<pre><code><span class="status">HTTP/1.1 GET http://endpoint-server.com/some-url</span>
<span class="attribute">Host</span>: <span class="string">proxy-server.com</span>
<span class="attribute">Other-Headers</span>: <span class="string">all go here</span>

<span class="stylus">request <span class="tag">body</span> or whatever</span>
</code></pre><p>Because a pure “http over http” tunnel offers no additional security<br>or other features, it is generally simpler to go with a<br>straightforward HTTP proxy in this case.  However, if you would like<br>to force a tunneling proxy, you may set the <code>tunnel</code> option to <code>true</code>.</p>
<p>You can also make a standard proxied <code>http</code> request by explicitly setting<br><code>tunnel : false</code>, but <strong>note that this will allow the proxy to see the traffic<br>to/from the destination server</strong>.</p>
<p>If you are using a tunneling proxy, you may set the<br><code>proxyHeaderWhiteList</code> to share certain headers with the proxy.</p>
<p>You can also set the <code>proxyHeaderExclusiveList</code> to share certain<br>headers only with the proxy and not with destination host.</p>
<p>By default, this set is:</p>
<pre><code>accept
accept-charset
accept-encoding
accept-language
accept-ranges
cache-<span class="literal">control</span>
<span class="literal">content</span>-encoding
<span class="literal">content</span>-language
<span class="literal">content</span>-length
<span class="literal">content</span>-location
<span class="literal">content</span>-md5
<span class="literal">content</span>-range
<span class="literal">content</span>-<span class="built_in">type</span>
connection
date
expect
max-forwards
pragma
<span class="literal">proxy</span>-authorization
referer
te
transfer-encoding
<span class="keyword">user</span>-agent
via
</code></pre><p>Note that, when using a tunneling proxy, the <code>proxy-authorization</code><br>header and any headers from custom <code>proxyHeaderExclusiveList</code> are<br><em>never</em> sent to the endpoint server, but only to the proxy server.</p>
<h3 id="Controlling_proxy_behaviour_using_environment_variables">Controlling proxy behaviour using environment variables</h3><p>The following environment variables are respected by <code>request</code>:</p>
<ul>
<li><code>HTTP_PROXY</code> / <code>http_proxy</code></li>
<li><code>HTTPS_PROXY</code> / <code>https_proxy</code></li>
<li><code>NO_PROXY</code> / <code>no_proxy</code></li>
</ul>
<p>When <code>HTTP_PROXY</code> / <code>http_proxy</code> are set, they will be used to proxy non-SSL requests that do not have an explicit <code>proxy</code> configuration option present. Similarly, <code>HTTPS_PROXY</code> / <code>https_proxy</code> will be respected for SSL requests that do not have an explicit <code>proxy</code> configuration option. It is valid to define a proxy in one of the environment variables, but then override it for a specific request, using the <code>proxy</code> configuration option. Furthermore, the <code>proxy</code> configuration option can be explicitly set to false / null to opt out of proxying altogether for that request.</p>
<p><code>request</code> is also aware of the <code>NO_PROXY</code>/<code>no_proxy</code> environment variables. These variables provide a granular way to opt out of proxying, on a per-host basis. It should contain a comma separated list of hosts to opt out of proxying. It is also possible to opt of proxying when a particular destination port is used. Finally, the variable may be set to <code>*</code> to opt out of the implicit proxy configuration of the other environment variables.</p>
<p>Here’s some examples of valid <code>no_proxy</code> values:</p>
<ul>
<li><code>google.com</code> - don’t proxy HTTP/HTTPS requests to Google.</li>
<li><code>google.com:443</code> - don’t proxy HTTPS requests to Google, but <em>do</em> proxy HTTP requests to Google.</li>
<li><code>google.com:443, yahoo.com:80</code> - don’t proxy HTTPS requests to Google, and don’t proxy HTTP requests to Yahoo!</li>
<li><code>*</code> - ignore <code>https_proxy</code>/<code>http_proxy</code> environment variables altogether.</li>
</ul>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="UNIX_Domain_Sockets">UNIX Domain Sockets</h2><p><code>request</code> supports making requests to <a href="http://en.wikipedia.org/wiki/Unix_domain_socket">UNIX Domain Sockets</a>. To make one, use the following URL scheme:</p>
<pre><code class="js"><span class="comment">/* Pattern */</span> <span class="string">'http://unix:SOCKET:PATH'</span>
<span class="comment">/* Example */</span> request.get(<span class="string">'http://unix:/absolute/path/to/unix.socket:/request/path'</span>)
</code></pre>
<p>Note: The <code>SOCKET</code> path is assumed to be absolute to the root of the host file system.</p>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="TLS/SSL_Protocol">TLS/SSL Protocol</h2><p>TLS/SSL Protocol options, such as <code>cert</code>, <code>key</code> and <code>passphrase</code>, can be<br>set in the <code>agentOptions</code> property of the <code>options</code> object.<br>In the example below, we call an API requires client side SSL certificate<br>(in PEM format) with passphrase protected private key (in PEM format) and disable the SSLv3 protocol:</p>
<pre><code class="js"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)
    , path = <span class="built_in">require</span>(<span class="string">'path'</span>)
    , certFile = path.resolve(__dirname, <span class="string">'ssl/client.crt'</span>)
    , keyFile = path.resolve(__dirname, <span class="string">'ssl/client.key'</span>)
    , request = <span class="built_in">require</span>(<span class="string">'request'</span>);

<span class="keyword">var</span> options = {
    url: <span class="string">'https://api.some-server.com/'</span>,
    agentOptions: {
        cert: fs.readFileSync(certFile),
        key: fs.readFileSync(keyFile),
        <span class="comment">// Or use `pfx` property replacing `cert` and `key` when using private key, certificate and CA certs in PFX or PKCS12 format:</span>
        <span class="comment">// pfx: fs.readFileSync(pfxFilePath),</span>
        passphrase: <span class="string">'password'</span>,
        securityOptions: <span class="string">'SSL_OP_NO_SSLv3'</span>
    }
};

request.get(options);
</code></pre>
<p>It is able to force using SSLv3 only by specifying <code>secureProtocol</code>:</p>
<pre><code class="js">request.get({
    url: <span class="string">'https://api.some-server.com/'</span>,
    agentOptions: {
        secureProtocol: <span class="string">'SSLv3_method'</span>
    }
});
</code></pre>
<p>It is possible to accept other certificates than those signed by generally allowed Certificate Authorities (CAs).<br>This can be useful, for example,  when using self-signed certificates.<br>To allow a different certificate, you can specify the signing CA by adding the contents of the CA’s certificate file to the <code>agentOptions</code>:</p>
<pre><code class="js">request.get({
    url: <span class="string">'https://api.some-server.com/'</span>,
    agentOptions: {
        ca: fs.readFileSync(<span class="string">'ca.cert.pem'</span>)
    }
});
</code></pre>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="Support_for_HAR_1-2">Support for HAR 1.2</h2><p>The <code>options.har</code> property will override the values: <code>url</code>, <code>method</code>, <code>qs</code>, <code>headers</code>, <code>form</code>, <code>formData</code>, <code>body</code>, <code>json</code>, as well as construct multipart data and read files from disk when <code>request.postData.params[].fileName</code> is present without a matching <code>value</code>.</p>
<p>a validation step will check if the HAR Request format matches the latest spec (v1.2) and will skip parsing if not matching.</p>
<pre><code class="js"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)
request({
  <span class="comment">// will be ignored</span>
  method: <span class="string">'GET'</span>
  uri: <span class="string">'http://www.google.com'</span>,

  <span class="comment">// HTTP Archive Request Object</span>
  har: {
    url: <span class="string">'http://www.mockbin.com/har'</span>
    method: <span class="string">'POST'</span>,
    headers: [
      {
        name: <span class="string">'content-type'</span>,
        value: <span class="string">'application/x-www-form-urlencoded'</span>
      }
    ],
    postData: {
      mimeType: <span class="string">'application/x-www-form-urlencoded'</span>,
      params: [
        {
          name: <span class="string">'foo'</span>,
          value: <span class="string">'bar'</span>
        },
        {
          name: <span class="string">'hello'</span>,
          value: <span class="string">'world'</span>
        }
      ]
    }
  }
})

<span class="comment">// a POST request will be sent to http://www.mockbin.com</span>
<span class="comment">// with body an application/x-www-form-urlencoded body:</span>
<span class="comment">// foo=bar&amp;hello=world</span>
</code></pre>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="request(options,_callback)">request(options, callback)</h2><p>The first argument can be either a <code>url</code> or an <code>options</code> object. The only required option is <code>uri</code>; all others are optional.</p>
<ul>
<li><code>uri</code> || <code>url</code> - fully qualified uri or a parsed url object from <code>url.parse()</code></li>
<li><code>baseUrl</code> - fully qualified uri string used as the base url. Most useful with <code>request.defaults</code>, for example when you want to do many requests to the same domain.  If <code>baseUrl</code> is <code>https://example.com/api/</code>, then requesting <code>/end/point?test=true</code> will fetch <code>https://example.com/api/end/point?test=true</code>. When <code>baseUrl</code> is given, <code>uri</code> must also be a string.</li>
<li><code>method</code> - http method (default: <code>&quot;GET&quot;</code>)</li>
<li><code>headers</code> - http headers (default: <code>{}</code>)</li>
</ul>
<hr>
<ul>
<li><code>qs</code> - object containing querystring values to be appended to the <code>uri</code></li>
<li><code>qsParseOptions</code> - object containing options to pass to the <a href="https://github.com/hapijs/qs#parsing-objects">qs.parse</a> method or <a href="https://nodejs.org/docs/v0.12.0/api/querystring.html#querystring_querystring_parse_str_sep_eq_options">querystring.parse</a> method</li>
<li><code>qsStringifyOptions</code> - object containing options to pass to the <a href="https://github.com/hapijs/qs#stringifying">qs.stringify</a> method or to the <a href="https://nodejs.org/docs/v0.12.0/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options">querystring.stringify</a> method. For example, to change the way arrays are converted to query strings pass the <code>arrayFormat</code> option with one of <code>indices|brackets|repeat</code></li>
<li><code>useQuerystring</code> - If true, use <code>querystring</code> to stringify and parse<br>querystrings, otherwise use <code>qs</code> (default: <code>false</code>).  Set this option to<br><code>true</code> if you need arrays to be serialized as <code>foo=bar&amp;foo=baz</code> instead of the<br>default <code>foo[0]=bar&amp;foo[1]=baz</code>.</li>
</ul>
<hr>
<ul>
<li><code>body</code> - entity body for PATCH, POST and PUT requests. Must be a <code>Buffer</code> or <code>String</code>, unless <code>json</code> is <code>true</code>. If <code>json</code> is <code>true</code>, then <code>body</code> must be a JSON-serializable object.</li>
<li><code>form</code> - when passed an object or a querystring, this sets <code>body</code> to a querystring representation of value, and adds <code>Content-type: application/x-www-form-urlencoded</code> header. When passed no options, a <code>FormData</code> instance is returned (and is piped to request). See “Forms” section above.</li>
<li><code>formData</code> - Data to pass for a <code>multipart/form-data</code> request. See<br><a href="#forms">Forms</a> section above.</li>
<li><code>multipart</code> - array of objects which contain their own headers and <code>body</code><br>attributes. Sends a <code>multipart/related</code> request. See <a href="#forms">Forms</a> section<br>above.<ul>
<li>Alternatively you can pass in an object <code>{chunked: false, data: []}</code> where<br><code>chunked</code> is used to specify whether the request is sent in<br><a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">chunked transfer encoding</a><br>In non-chunked requests, data items with body streams are not allowed.</li>
</ul>
</li>
<li><code>preambleCRLF</code> - append a newline/CRLF before the boundary of your <code>multipart/form-data</code> request.</li>
<li><code>postambleCRLF</code> - append a newline/CRLF at the end of the boundary of your <code>multipart/form-data</code> request.</li>
<li><code>json</code> - sets <code>body</code> but to JSON representation of value and adds <code>Content-type: application/json</code> header.  Additionally, parses the response body as JSON.</li>
<li><code>jsonReviver</code> - a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">reviver function</a> that will be passed to <code>JSON.parse()</code> when parsing a JSON response body.</li>
</ul>
<hr>
<ul>
<li><code>auth</code> - A hash containing values <code>user</code> || <code>username</code>, <code>pass</code> || <code>password</code>, and <code>sendImmediately</code> (optional).  See documentation above.</li>
<li><code>oauth</code> - Options for OAuth HMAC-SHA1 signing. See documentation above.</li>
<li><code>hawk</code> - Options for <a href="https://github.com/hueniverse/hawk">Hawk signing</a>. The <code>credentials</code> key must contain the necessary signing info, <a href="https://github.com/hueniverse/hawk#usage-example">see hawk docs for details</a>.</li>
<li><code>aws</code> - <code>object</code> containing AWS signing information. Should have the properties <code>key</code>, <code>secret</code>. Also requires the property <code>bucket</code>, unless you’re specifying your <code>bucket</code> as part of the path, or the request doesn’t use a bucket (i.e. GET Services)</li>
<li><code>httpSignature</code> - Options for the <a href="https://github.com/joyent/node-http-signature/blob/master/http_signing.md">HTTP Signature Scheme</a> using <a href="https://github.com/joyent/node-http-signature">Joyent’s library</a>. The <code>keyId</code> and <code>key</code> properties must be specified. See the docs for other options.</li>
</ul>
<hr>
<ul>
<li><code>followRedirect</code> - follow HTTP 3xx responses as redirects (default: <code>true</code>). This property can also be implemented as function which gets <code>response</code> object as a single argument and should return <code>true</code> if redirects should continue or <code>false</code> otherwise.</li>
<li><code>followAllRedirects</code> - follow non-GET HTTP 3xx responses as redirects (default: <code>false</code>)</li>
<li><code>maxRedirects</code> - the maximum number of redirects to follow (default: <code>10</code>)</li>
</ul>
<hr>
<ul>
<li><code>encoding</code> - Encoding to be used on <code>setEncoding</code> of response data. If <code>null</code>, the <code>body</code> is returned as a <code>Buffer</code>. Anything else <strong>(including the default value of <code>undefined</code>)</strong> will be passed as the <a href="http://nodejs.org/api/buffer.html#buffer_buffer">encoding</a> parameter to <code>toString()</code> (meaning this is effectively <code>utf8</code> by default).</li>
<li><code>gzip</code> - If <code>true</code>, add an <code>Accept-Encoding</code> header to request compressed content encodings from the server (if not already present) and decode supported content encodings in the response.  <strong>Note:</strong> Automatic decoding of the response content is performed on the body data returned through <code>request</code> (both through the <code>request</code> stream and passed to the callback function) but is not performed on the <code>response</code> stream (available from the <code>response</code> event) which is the unmodified <code>http.IncomingMessage</code> object which may contain compressed data. See example below.</li>
<li><code>jar</code> - If <code>true</code> and <code>tough-cookie</code> is installed, remember cookies for future use (or define your custom cookie jar; see examples section)</li>
</ul>
<hr>
<ul>
<li><code>pool</code> - An object describing which agents to use for the request. If this option is omitted the request will use the global agent (as long as <a href="request.js#L747">your options allow for it</a>). Otherwise, request will search the pool for your custom agent. If no custom agent is found, a new agent will be created and added to the pool.<ul>
<li>A <code>maxSockets</code> property can also be provided on the <code>pool</code> object to set the max number of sockets for all agents created (ex: <code>pool: {maxSockets: Infinity}</code>).</li>
<li>Note that if you are sending multiple requests in a loop and creating<br>multiple new <code>pool</code> objects, <code>maxSockets</code> will not work as intended.  To<br>work around this, either use <a href="#requestdefaultsoptions"><code>request.defaults</code></a><br>with your pool options or create the pool object with the <code>maxSockets</code><br>property outside of the loop.</li>
</ul>
</li>
<li><code>timeout</code> - Integer containing the number of milliseconds to wait for a<br>request to respond before aborting the request.  Note that if the underlying<br>TCP connection cannot be established, the OS-wide TCP connection timeout will<br>overrule the <code>timeout</code> option (<a href="http://www.sekuda.com/overriding_the_default_linux_kernel_20_second_tcp_socket_connect_timeout">the default in Linux is around 20 seconds</a>).</li>
<li><code>localAddress</code> - Local interface to bind for network connections.</li>
<li><code>proxy</code> - An HTTP proxy to be used. Supports proxy Auth with Basic Auth, identical to support for the <code>url</code> parameter (by embedding the auth info in the <code>uri</code>)</li>
<li><code>strictSSL</code> - If <code>true</code>, requires SSL certificates be valid. <strong>Note:</strong> to use your own certificate authority, you need to specify an agent that was created with that CA as an option.</li>
<li><code>agentOptions</code> - Object containing user agent options. See documentation above. <strong>Note:</strong> <a href="http://nodejs.org/api/tls.html#tls_tls_connect_options_callback">see tls API doc for TLS/SSL options</a>.</li>
<li><code>tunnel</code> - controls the behavior of<br><a href="https://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling">HTTP <code>CONNECT</code> tunneling</a><br>as follows:<ul>
<li><code>undefined</code> (default) - <code>true</code> if the destination is <code>https</code> or a previous<br>request in the redirect chain used a tunneling proxy, <code>false</code> otherwise</li>
<li><code>true</code> - always tunnel to the destination by making a <code>CONNECT</code> request to<br>the proxy</li>
<li><code>false</code> - request the destination as a <code>GET</code> request.</li>
</ul>
</li>
<li><code>proxyHeaderWhiteList</code> - A whitelist of headers to send to a<br>tunneling proxy.</li>
<li><code>proxyHeaderExclusiveList</code> - A whitelist of headers to send<br>exclusively to a tunneling proxy and not to destination.</li>
<li><code>removeRefererHeader</code> - removes the referer header when a redirect happens (default: <code>false</code>).</li>
</ul>
<hr>
<ul>
<li><code>time</code> - If <code>true</code>, the request-response cycle (including all redirects) is timed at millisecond resolution, and the result provided on the response’s <code>elapsedTime</code> property.</li>
</ul>
<hr>
<ul>
<li><code>har</code> - A <a href="http://www.softwareishard.com/blog/har-12-spec/#request">HAR 1.2 Request Object</a>, will be processed from HAR format into options overwriting matching values <em>(see the <a href="#support-for-har-1.2">HAR 1.2 section</a> for details)</em></li>
</ul>
<p>The callback argument gets 3 arguments:</p>
<ol>
<li>An <code>error</code> when applicable (usually from <a href="http://nodejs.org/api/http.html#http_class_http_clientrequest"><code>http.ClientRequest</code></a> object)</li>
<li>An <a href="http://nodejs.org/api/http.html#http_http_incomingmessage"><code>http.IncomingMessage</code></a> object</li>
<li>The third is the <code>response</code> body (<code>String</code> or <code>Buffer</code>, or JSON object if the <code>json</code> option is supplied)</li>
</ol>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="Convenience_methods">Convenience methods</h2><p>There are also shorthand methods for different HTTP METHODs and some other conveniences.</p>
<h3 id="request-defaults(options)">request.defaults(options)</h3><p>This method <strong>returns a wrapper</strong> around the normal request API that defaults<br>to whatever options you pass to it.</p>
<p><strong>Note:</strong> <code>request.defaults()</code> <strong>does not</strong> modify the global request API;<br>instead, it <strong>returns a wrapper</strong> that has your default settings applied to it.</p>
<p><strong>Note:</strong> You can call <code>.defaults()</code> on the wrapper that is returned from<br><code>request.defaults</code> to add/override defaults that were previously defaulted.</p>
<p>For example:</p>
<pre><code class="js"><span class="comment">//requests using baseRequest() will set the 'x-token' header</span>
<span class="keyword">var</span> baseRequest = request.defaults({
  headers: {x-token: <span class="string">'my-token'</span>}
})

<span class="comment">//requests using specialRequest() will include the 'x-token' header set in</span>
<span class="comment">//baseRequest and will also include the 'special' header</span>
<span class="keyword">var</span> specialRequest = baseRequest.defaults({
  headers: {special: <span class="string">'special value'</span>}
})
</code></pre>
<h3 id="request-put">request.put</h3><p>Same as <code>request()</code>, but defaults to <code>method: &quot;PUT&quot;</code>.</p>
<pre><code class="js">request.put(url)
</code></pre>
<h3 id="request-patch">request.patch</h3><p>Same as <code>request()</code>, but defaults to <code>method: &quot;PATCH&quot;</code>.</p>
<pre><code class="js">request.patch(url)
</code></pre>
<h3 id="request-post">request.post</h3><p>Same as <code>request()</code>, but defaults to <code>method: &quot;POST&quot;</code>.</p>
<pre><code class="js">request.post(url)
</code></pre>
<h3 id="request-head">request.head</h3><p>Same as <code>request()</code>, but defaults to <code>method: &quot;HEAD&quot;</code>.</p>
<pre><code class="js">request.head(url)
</code></pre>
<h3 id="request-del">request.del</h3><p>Same as <code>request()</code>, but defaults to <code>method: &quot;DELETE&quot;</code>.</p>
<pre><code class="js">request.del(url)
</code></pre>
<h3 id="request-get">request.get</h3><p>Same as <code>request()</code> (for uniformity).</p>
<pre><code class="js">request.get(url)
</code></pre>
<h3 id="request-cookie">request.cookie</h3><p>Function that creates a new cookie.</p>
<pre><code class="js">request.cookie(<span class="string">'key1=value1'</span>)
</code></pre>
<h3 id="request-jar()">request.jar()</h3><p>Function that creates a new cookie jar.</p>
<pre><code class="js">request.jar()
</code></pre>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="Debugging">Debugging</h2><p>There are at least three ways to debug the operation of <code>request</code>:</p>
<ol>
<li><p>Launch the node process like <code>NODE_DEBUG=request node script.js</code><br>(<code>lib,request,otherlib</code> works too).</p>
</li>
<li><p>Set <code>require(&#39;request&#39;).debug = true</code> at any time (this does the same thing<br>as #1).</p>
</li>
<li><p>Use the <a href="https://github.com/nylen/request-debug">request-debug module</a> to<br>view request and response headers and bodies.</p>
</li>
</ol>
<p><a href="#table-of-contents">back to top</a></p>
<hr>
<h2 id="Examples:">Examples:</h2><pre><code class="js"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)
  , rand = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">100000000</span>).toString()
  ;
request(
  { method: <span class="string">'PUT'</span>
  , uri: <span class="string">'http://mikeal.iriscouch.com/testjs/'</span> + rand
  , multipart:
    [ { <span class="string">'content-type'</span>: <span class="string">'application/json'</span>
      ,  body: <span class="built_in">JSON</span>.stringify({foo: <span class="string">'bar'</span>, _attachments: {<span class="string">'message.txt'</span>: {follows: <span class="literal">true</span>, length: <span class="number">18</span>, <span class="string">'content_type'</span>: <span class="string">'text/plain'</span> }}})
      }
    , { body: <span class="string">'I am an attachment'</span> }
    ]
  }
, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>{
    <span class="keyword">if</span>(response.statusCode == <span class="number">201</span>){
      <span class="built_in">console</span>.log(<span class="string">'document saved as: http://mikeal.iriscouch.com/testjs/'</span>+ rand)
    } <span class="keyword">else</span> {
      <span class="built_in">console</span>.log(<span class="string">'error: '</span>+ response.statusCode)
      <span class="built_in">console</span>.log(body)
    }
  }
)
</code></pre>
<p>For backwards-compatibility, response compression is not supported by default.<br>To accept gzip-compressed responses, set the <code>gzip</code> option to <code>true</code>.  Note<br>that the body data passed through <code>request</code> is automatically decompressed<br>while the response object is unmodified and will contain compressed data if<br>the server sent a compressed response.</p>
<pre><code class="js"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)
request(
  { method: <span class="string">'GET'</span>
  , uri: <span class="string">'http://www.google.com'</span>
  , gzip: <span class="literal">true</span>
  }
, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>{
    <span class="comment">// body is the decompressed response body</span>
    <span class="built_in">console</span>.log(<span class="string">'server encoded the data as: '</span> + (response.headers[<span class="string">'content-encoding'</span>] || <span class="string">'identity'</span>))
    <span class="built_in">console</span>.log(<span class="string">'the decoded data is: '</span> + body)
  }
).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{
  <span class="comment">// decompressed data as it is received</span>
  <span class="built_in">console</span>.log(<span class="string">'decoded chunk: '</span> + data)
})
.on(<span class="string">'response'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>{
  <span class="comment">// unmodified http.IncomingMessage object</span>
  response.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{
    <span class="comment">// compressed data as it is received</span>
    <span class="built_in">console</span>.log(<span class="string">'received '</span> + data.length + <span class="string">' bytes of compressed data'</span>)
  })
})
</code></pre>
<p>Cookies are disabled by default (else, they would be used in subsequent requests). To enable cookies, set <code>jar</code> to <code>true</code> (either in <code>defaults</code> or <code>options</code>) and install <code>tough-cookie</code>.</p>
<pre><code class="js"><span class="keyword">var</span> request = request.defaults({jar: <span class="literal">true</span>})
request(<span class="string">'http://www.google.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
  request(<span class="string">'http://images.google.com'</span>)
})
</code></pre>
<p>To use a custom cookie jar (instead of <code>request</code>’s global cookie jar), set <code>jar</code> to an instance of <code>request.jar()</code> (either in <code>defaults</code> or <code>options</code>)</p>
<pre><code class="js"><span class="keyword">var</span> j = request.jar()
<span class="keyword">var</span> request = request.defaults({jar:j})
request(<span class="string">'http://www.google.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
  request(<span class="string">'http://images.google.com'</span>)
})
</code></pre>
<p>OR</p>
<pre><code class="js"><span class="keyword">var</span> j = request.jar();
<span class="keyword">var</span> cookie = request.cookie(<span class="string">'key1=value1'</span>);
<span class="keyword">var</span> url = <span class="string">'http://www.google.com'</span>;
j.setCookie(cookie, url);
request({url: url, jar: j}, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
  request(<span class="string">'http://images.google.com'</span>)
})
</code></pre>
<p>To use a custom cookie store (such as a<br><a href="https://github.com/mitsuru/tough-cookie-filestore"><code>FileCookieStore</code></a><br>which supports saving to and restoring from JSON files), pass it as a parameter<br>to <code>request.jar()</code>:</p>
<pre><code class="js"><span class="keyword">var</span> FileCookieStore = <span class="built_in">require</span>(<span class="string">'tough-cookie-filestore'</span>);
<span class="comment">// <span class="doctag">NOTE</span> - currently the 'cookies.json' file must already exist!</span>
<span class="keyword">var</span> j = request.jar(<span class="keyword">new</span> FileCookieStore(<span class="string">'cookies.json'</span>));
request = request.defaults({ jar : j })
request(<span class="string">'http://www.google.com'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
  request(<span class="string">'http://images.google.com'</span>)
})
</code></pre>
<p>The cookie store must be a<br><a href="https://github.com/goinstant/tough-cookie"><code>tough-cookie</code></a><br>store and it must support synchronous operations; see the<br><a href="https://github.com/goinstant/tough-cookie/#cookiestore-api"><code>CookieStore</code> API docs</a><br>for details.</p>
<p>To inspect your cookie jar after a request:</p>
<pre><code class="js"><span class="keyword">var</span> j = request.jar()
request({url: <span class="string">'http://www.google.com'</span>, jar: j}, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
  <span class="keyword">var</span> cookie_string = j.getCookieString(uri); <span class="comment">// "key1=value1; key2=value2; ..."</span>
  <span class="keyword">var</span> cookies = j.getCookies(uri);
  <span class="comment">// [{key: 'key1', value: 'value1', domain: "www.google.com", ...}, ...]</span>
})
</code></pre>
<p><a href="#table-of-contents">back to top</a></p>
