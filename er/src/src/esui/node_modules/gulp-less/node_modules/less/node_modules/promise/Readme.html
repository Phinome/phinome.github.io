<p><a href="https://promisesaplus.com/"><img src="https://promisesaplus.com/assets/logo-small.png" align="right" /></a></p>
<h1 id="promise">promise</h1><p>This is a simple implementation of Promises.  It is a super set of ES6 Promises designed to have readable, performant code and to provide just the extensions that are absolutely necessary for using promises today.</p>
<p>For detailed tutorials on its use, see www.promisejs.org</p>
<p><a href="https://travis-ci.org/then/promise"><img src="https://img.shields.io/travis/then/promise/master.svg" alt="Build Status"></a><br><a href="https://gemnasium.com/then/promise"><img src="https://img.shields.io/gemnasium/then/promise.svg" alt="Dependency Status"></a><br><a href="https://www.npmjs.org/package/promise"><img src="https://img.shields.io/npm/v/promise.svg" alt="NPM version"></a></p>
<h2 id="Installation">Installation</h2><p><strong>Server:</strong></p>
<pre><code>$ npm <span class="keyword">install</span> promise
</code></pre><p><strong>Client:</strong></p>
<p>You can use browserify on the client, or use the pre-compiled script that acts as a polyfill.</p>
<pre><code class="html"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://www.promisejs.org/polyfills/promise-6.1.0.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre>
<p>Note that the <a href="https://github.com/es-shims/es5-shim">es5-shim</a> must be loaded before this library to support browsers pre IE9.</p>
<pre><code class="html"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"https://cdnjs.cloudflare.com/ajax/libs/es5-shim/3.4.0/es5-shim.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre>
<h2 id="Usage">Usage</h2><p>The example below shows how you can load the promise library (in a way that works on both client and server).  It then demonstrates creating a promise from scratch.  You simply call <code>new Promise(fn)</code>.  There is a complete specification for what is returned by this method in <a href="http://promises-aplus.github.com/promises-spec/">Promises/A+</a>.</p>
<pre><code class="javascript"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'promise'</span>);

<span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>{
  get(<span class="string">'http://www.google.com'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>{
    <span class="keyword">if</span> (err) reject(err);
    <span class="keyword">else</span> resolve(res);
  });
});
</code></pre>
<h2 id="API">API</h2><p>Before all examples, you will need:</p>
<pre><code class="js"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'promise'</span>);
</code></pre>
<h3 id="new_Promise(resolver)">new Promise(resolver)</h3><p>This creates and returns a new promise.  <code>resolver</code> must be a function.  The <code>resolver</code> function is passed two arguments:</p>
<ol>
<li><code>resolve</code> should be called with a single argument.  If it is called with a non-promise value then the promise is fulfilled with that value.  If it is called with a promise (A) then the returned promise takes on the state of that new promise (A).</li>
<li><code>reject</code> should be called with a single argument.  The returned promise will be rejected with that argument.</li>
</ol>
<h3 id="Static_Functions">Static Functions</h3><p>  These methods are invoked by calling <code>Promise.methodName</code>.</p>
<h4 id="Promise-resolve(value)">Promise.resolve(value)</h4><p>(deprecated aliases: <code>Promise.from(value)</code>, <code>Promise.cast(value)</code>)</p>
<p>Converts values and foreign promises into Promises/A+ promises.  If you pass it a value then it returns a Promise for that value.  If you pass it something that is close to a promise (such as a jQuery attempt at a promise) it returns a Promise that takes on the state of <code>value</code> (rejected or fulfilled).</p>
<h4 id="Promise-all(array)">Promise.all(array)</h4><p>Returns a promise for an array.  If it is called with a single argument that <code>Array.isArray</code> then this returns a promise for a copy of that array with any promises replaced by their fulfilled values.  Otherwise it returns a promise for an array that conatins its arguments, except with promises replaced by their resolution values.  e.g.</p>
<pre><code class="js"><span class="built_in">Promise</span>.all([<span class="built_in">Promise</span>.resolve(<span class="string">'a'</span>), <span class="string">'b'</span>, <span class="built_in">Promise</span>.resolve(<span class="string">'c'</span>)])
  .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>{
    assert(res[<span class="number">0</span>] === <span class="string">'a'</span>)
    assert(res[<span class="number">1</span>] === <span class="string">'b'</span>)
    assert(res[<span class="number">2</span>] === <span class="string">'c'</span>)
  })

<span class="built_in">Promise</span>.all(<span class="built_in">Promise</span>.resolve(<span class="string">'a'</span>), <span class="string">'b'</span>, <span class="built_in">Promise</span>.resolve(<span class="string">'c'</span>))
  .then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>{
    assert(res[<span class="number">0</span>] === <span class="string">'a'</span>)
    assert(res[<span class="number">1</span>] === <span class="string">'b'</span>)
    assert(res[<span class="number">2</span>] === <span class="string">'c'</span>)
  })
</code></pre>
<h4 id="Promise-denodeify(fn)">Promise.denodeify(fn)</h4><p><em>Non Standard</em></p>
<p>Takes a function which accepts a node style callback and returns a new function that returns a promise instead.</p>
<p>e.g.</p>
<pre><code class="javascript"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)

<span class="keyword">var</span> read = <span class="built_in">Promise</span>.denodeify(fs.readFile)
<span class="keyword">var</span> write = <span class="built_in">Promise</span>.denodeify(fs.writeFile)

<span class="keyword">var</span> p = read(<span class="string">'foo.json'</span>, <span class="string">'utf8'</span>)
  .then(<span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>{
    <span class="keyword">return</span> write(<span class="string">'foo.json'</span>, <span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(str), <span class="literal">null</span>, <span class="string">'  '</span>), <span class="string">'utf8'</span>)
  })
</code></pre>
<h4 id="Promise-nodeify(fn)">Promise.nodeify(fn)</h4><p><em>Non Standard</em></p>
<p>The twin to <code>denodeify</code> is useful when you want to export an API that can be used by people who havenâ€™t learnt about the brilliance of promises yet.</p>
<pre><code class="javascript"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>.nodeify(awesomeAPI)
<span class="function"><span class="keyword">function</span> <span class="title">awesomeAPI</span>(<span class="params">a, b</span>) </span>{
  <span class="keyword">return</span> download(a, b)
}
</code></pre>
<p>If the last argument passed to <code>module.exports</code> is a function, then it will be treated like a node.js callback and not parsed on to the child function, otherwise the API will just return a promise.</p>
<h3 id="Prototype_Methods">Prototype Methods</h3><p>These methods are invoked on a promise instance by calling <code>myPromise.methodName</code></p>
<h3 id="Promise#then(onFulfilled,_onRejected)">Promise#then(onFulfilled, onRejected)</h3><p>This method follows the <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+ spec</a>.  It explains things very clearly so I recommend you read it.</p>
<p>Either <code>onFulfilled</code> or <code>onRejected</code> will be called and they will not be called more than once.  They will be passed a single argument and will always be called asynchronously (in the next turn of the event loop).</p>
<p>If the promise is fulfilled then <code>onFulfilled</code> is called.  If the promise is rejected then <code>onRejected</code> is called.</p>
<p>The call to <code>.then</code> also returns a promise.  If the handler that is called returns a promise, the promise returned by <code>.then</code> takes on the state of that returned promise.  If the handler that is called returns a value that is not a promise, the promise returned by <code>.then</code> will be fulfilled with that value. If the handler that is called throws an exception then the promise returned by <code>.then</code> is rejected with that exception.</p>
<h4 id="Promise#catch(onRejected)">Promise#catch(onRejected)</h4><p>Sugar for <code>Promise#then(null, onRejected)</code>, to mirror <code>catch</code> in synchronous code.</p>
<h4 id="Promise#done(onFulfilled,_onRejected)">Promise#done(onFulfilled, onRejected)</h4><p><em>Non Standard</em></p>
<p>The same semantics as <code>.then</code> except that it does not return a promise and any exceptions are re-thrown so that they can be logged (crashing the application in non-browser environments)</p>
<h4 id="Promise#nodeify(callback)">Promise#nodeify(callback)</h4><p><em>Non Standard</em></p>
<p>If <code>callback</code> is <code>null</code> or <code>undefined</code> it just returns <code>this</code>.  If <code>callback</code> is a function it is called with rejection reason as the first argument and result as the second argument (as per the node.js convention).</p>
<p>This lets you write API functions that look like:</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">awesomeAPI</span>(<span class="params">foo, bar, callback</span>) </span>{
  <span class="keyword">return</span> internalAPI(foo, bar)
    .then(parseResult)
    .then(<span class="literal">null</span>, retryErrors)
    .nodeify(callback)
}
</code></pre>
<p>People who use typical node.js style callbacks will be able to just pass a callback and get the expected behavior.  The enlightened people can not pass a callback and will get awesome promises.</p>
<h2 id="Extending_Promises">Extending Promises</h2><p>  There are three options for extending the promises created by this library.</p>
<h3 id="Inheritance">Inheritance</h3><p>  You can use inheritance if you want to create your own complete promise library with this as your basic starting point, perfect if you have lots of cool features you want to add.  Here is an example of a promise library called <code>Awesome</code>, which is built on top of <code>Promise</code> correctly.</p>
<pre><code class="javascript"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'promise'</span>);
<span class="function"><span class="keyword">function</span> <span class="title">Awesome</span>(<span class="params">fn</span>) </span>{
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Awesome)) <span class="keyword">return</span> <span class="keyword">new</span> Awesome(fn);
  <span class="built_in">Promise</span>.call(<span class="keyword">this</span>, fn);
}
Awesome.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Promise</span>.prototype);
Awesome.prototype.constructor = Awesome;

<span class="comment">//Awesome extension</span>
Awesome.prototype.spread = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>{
  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>{
    <span class="keyword">return</span> cb.apply(<span class="keyword">this</span>, arr);
  })
};
</code></pre>
<p>  N.B. if you fail to set the prototype and constructor properly or fail to do Promise.call, things can fail in really subtle ways.</p>
<h3 id="Wrap">Wrap</h3><p>  This is the nuclear option, for when you want to start from scratch.  It ensures you wonâ€™t be impacted by anyone who is extending the prototype (see below).</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Uber</span>(<span class="params">fn</span>) </span>{
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Uber)) <span class="keyword">return</span> <span class="keyword">new</span> Uber(fn);
  <span class="keyword">var</span> _prom = <span class="keyword">new</span> <span class="built_in">Promise</span>(fn);
  <span class="keyword">this</span>.then = _prom.then;
}

Uber.prototype.spread = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>{
  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>{
    <span class="keyword">return</span> cb.apply(<span class="keyword">this</span>, arr);
  })
};
</code></pre>
<h3 id="Extending_the_Prototype">Extending the Prototype</h3><p>  In general, you should never extend the prototype of this promise implimenation because your extensions could easily conflict with someone elses extensions.  However, this organisation will host a library of extensions which do not conflict with each other, so you can safely enable any of those.  If you think of an extension that we donâ€™t provide and you want to write it, submit an issue on this repository and (if I agree) Iâ€™ll set you up with a repository and give you permission to commit to it.</p>
<h2 id="License">License</h2><p>  MIT</p>
