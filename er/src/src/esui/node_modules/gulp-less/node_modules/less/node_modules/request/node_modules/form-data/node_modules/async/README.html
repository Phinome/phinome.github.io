<h1 id="Async-js">Async.js</h1><p><a href="https://travis-ci.org/caolan/async"><img src="https://travis-ci.org/caolan/async.svg?branch=master" alt="Build Status via Travis CI"></a></p>
<p>Async is a utility module which provides straight-forward, powerful functions<br>for working with asynchronous JavaScript. Although originally designed for<br>use with <a href="http://nodejs.org">Node.js</a>, it can also be used directly in the<br>browser. Also supports <a href="https://github.com/component/component">component</a>.</p>
<p>Async provides around 20 functions that include the usual ‘functional’<br>suspects (<code>map</code>, <code>reduce</code>, <code>filter</code>, <code>each</code>…) as well as some common patterns<br>for asynchronous control flow (<code>parallel</code>, <code>series</code>, <code>waterfall</code>…). All these<br>functions assume you follow the Node.js convention of providing a single<br>callback as the last argument of your <code>async</code> function.</p>
<h2 id="Quick_Examples">Quick Examples</h2><pre><code class="javascript"><span class="keyword">async</span>.map([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.stat, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// results is now an array of stats for each file</span>
});

<span class="keyword">async</span>.filter([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.exists, <span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>{
    <span class="comment">// results now equals an array of the existing files</span>
});

<span class="keyword">async</span>.parallel([
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ ... },
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ ... }
], callback);

<span class="keyword">async</span>.series([
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ ... },
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ ... }
]);
</code></pre>
<p>There are many more functions available so take a look at the docs below for a<br>full list. This module aims to be comprehensive, so if you feel anything is<br>missing please create a GitHub issue for it.</p>
<h2 id="Common_Pitfalls">Common Pitfalls</h2><h3 id="Binding_a_context_to_an_iterator">Binding a context to an iterator</h3><p>This section is really about <code>bind</code>, not about <code>async</code>. If you are wondering how to<br>make <code>async</code> execute your iterators in a given context, or are confused as to why<br>a method of another library isn’t working as an iterator, study this example:</p>
<pre><code class="js"><span class="comment">// Here is a simple object with an (unnecessarily roundabout) squaring method</span>
<span class="keyword">var</span> AsyncSquaringLibrary = {
  squareExponent: <span class="number">2</span>,
  square: <span class="function"><span class="keyword">function</span>(<span class="params">number, callback</span>)</span>{ 
    <span class="keyword">var</span> result = <span class="built_in">Math</span>.pow(number, <span class="keyword">this</span>.squareExponent);
    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
      callback(<span class="literal">null</span>, result);
    }, <span class="number">200</span>);
  }
};

<span class="keyword">async</span>.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], AsyncSquaringLibrary.square, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>)</span>{
  <span class="comment">// result is [NaN, NaN, NaN]</span>
  <span class="comment">// This fails because the `this.squareExponent` expression in the square</span>
  <span class="comment">// function is not evaluated in the context of AsyncSquaringLibrary, and is</span>
  <span class="comment">// therefore undefined.</span>
});

<span class="keyword">async</span>.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>)</span>{
  <span class="comment">// result is [1, 4, 9]</span>
  <span class="comment">// With the help of bind we can attach a context to the iterator before</span>
  <span class="comment">// passing it to async. Now the square function will be executed in its </span>
  <span class="comment">// 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`</span>
  <span class="comment">// will be as expected.</span>
});
</code></pre>
<h2 id="Download">Download</h2><p>The source is available for download from<br><a href="http://github.com/caolan/async">GitHub</a>.<br>Alternatively, you can install using Node Package Manager (<code>npm</code>):</p>
<pre><code>npm <span class="keyword">install</span> async
</code></pre><p><strong>Development:</strong> <a href="https://github.com/caolan/async/raw/master/lib/async.js">async.js</a> - 29.6kb Uncompressed</p>
<h2 id="In_the_Browser">In the Browser</h2><p>So far it’s been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. </p>
<p>Usage:</p>
<pre><code class="html"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"async.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="http">

<span class="fortran">    async.map(<span class="type">data</span>, asyncProcess, <span class="function"><span class="keyword">function</span><span class="params">(err, results)</span></span>{
        alert(results);
    });

</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</code></pre>
<h2 id="Documentation">Documentation</h2><h3 id="Collections">Collections</h3><ul>
<li><a href="#each"><code>each</code></a></li>
<li><a href="#eachSeries"><code>eachSeries</code></a></li>
<li><a href="#eachLimit"><code>eachLimit</code></a></li>
<li><a href="#map"><code>map</code></a></li>
<li><a href="#mapSeries"><code>mapSeries</code></a></li>
<li><a href="#mapLimit"><code>mapLimit</code></a></li>
<li><a href="#filter"><code>filter</code></a></li>
<li><a href="#filterSeries"><code>filterSeries</code></a></li>
<li><a href="#reject"><code>reject</code></a></li>
<li><a href="#rejectSeries"><code>rejectSeries</code></a></li>
<li><a href="#reduce"><code>reduce</code></a></li>
<li><a href="#reduceRight"><code>reduceRight</code></a></li>
<li><a href="#detect"><code>detect</code></a></li>
<li><a href="#detectSeries"><code>detectSeries</code></a></li>
<li><a href="#sortBy"><code>sortBy</code></a></li>
<li><a href="#some"><code>some</code></a></li>
<li><a href="#every"><code>every</code></a></li>
<li><a href="#concat"><code>concat</code></a></li>
<li><a href="#concatSeries"><code>concatSeries</code></a></li>
</ul>
<h3 id="Control_Flow">Control Flow</h3><ul>
<li><a href="#seriestasks-callback"><code>series</code></a></li>
<li><a href="#parallel"><code>parallel</code></a></li>
<li><a href="#parallellimittasks-limit-callback"><code>parallelLimit</code></a></li>
<li><a href="#whilst"><code>whilst</code></a></li>
<li><a href="#doWhilst"><code>doWhilst</code></a></li>
<li><a href="#until"><code>until</code></a></li>
<li><a href="#doUntil"><code>doUntil</code></a></li>
<li><a href="#forever"><code>forever</code></a></li>
<li><a href="#waterfall"><code>waterfall</code></a></li>
<li><a href="#compose"><code>compose</code></a></li>
<li><a href="#seq"><code>seq</code></a></li>
<li><a href="#applyEach"><code>applyEach</code></a></li>
<li><a href="#applyEachSeries"><code>applyEachSeries</code></a></li>
<li><a href="#queue"><code>queue</code></a></li>
<li><a href="#priorityQueue"><code>priorityQueue</code></a></li>
<li><a href="#cargo"><code>cargo</code></a></li>
<li><a href="#auto"><code>auto</code></a></li>
<li><a href="#retry"><code>retry</code></a></li>
<li><a href="#iterator"><code>iterator</code></a></li>
<li><a href="#apply"><code>apply</code></a></li>
<li><a href="#nextTick"><code>nextTick</code></a></li>
<li><a href="#times"><code>times</code></a></li>
<li><a href="#timesSeries"><code>timesSeries</code></a></li>
</ul>
<h3 id="Utils">Utils</h3><ul>
<li><a href="#memoize"><code>memoize</code></a></li>
<li><a href="#unmemoize"><code>unmemoize</code></a></li>
<li><a href="#log"><code>log</code></a></li>
<li><a href="#dir"><code>dir</code></a></li>
<li><a href="#noConflict"><code>noConflict</code></a></li>
</ul>
<h2 id="Collections-1">Collections</h2><p><a name="forEach" /><br><a name="each" /></p>
<h3 id="each(arr,_iterator,_callback)">each(arr, iterator, callback)</h3><p>Applies the function <code>iterator</code> to each item in <code>arr</code>, in parallel.<br>The <code>iterator</code> is called with an item from the list, and a callback for when it<br>has finished. If the <code>iterator</code> passes an error to its <code>callback</code>, the main<br><code>callback</code> (for the <code>each</code> function) is immediately called with the error.</p>
<p>Note, that since this function applies <code>iterator</code> to each item in parallel,<br>there is no guarantee that the iterator functions will complete in order.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err)</code> which must be called once it has<br>completed. If no error has occured, the <code>callback</code> should be run without<br>arguments or with an explicit <code>null</code> argument.</li>
<li><code>callback(err)</code> - A callback which is called when all <code>iterator</code> functions<br>have finished, or an error occurs.</li>
</ul>
<p><strong>Examples</strong></p>
<pre><code class="js"><span class="comment">// assuming openFiles is an array of file names and saveFile is a function</span>
<span class="comment">// to save the modified contents of that file:</span>

<span class="keyword">async</span>.each(openFiles, saveFile, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>{
    <span class="comment">// if any of the saves produced an error, err would equal that error</span>
});
</code></pre>
<pre><code class="js"><span class="comment">// assuming openFiles is an array of file names </span>

<span class="keyword">async</span>.each(openFiles, <span class="function"><span class="keyword">function</span>(<span class="params"> file, callback</span>) </span>{

  <span class="comment">// Perform operation on file here.</span>
  <span class="built_in">console</span>.log(<span class="string">'Processing file '</span> + file);

  <span class="keyword">if</span>( file.length &gt; <span class="number">32</span> ) {
    <span class="built_in">console</span>.log(<span class="string">'This file name is too long'</span>);
    callback(<span class="string">'File name too long'</span>);
  } <span class="keyword">else</span> {
    <span class="comment">// Do work to process file here</span>
    <span class="built_in">console</span>.log(<span class="string">'File processed'</span>);
    callback();
  }
}, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>{
    <span class="comment">// if any of the file processing produced an error, err would equal that error</span>
    <span class="keyword">if</span>( err ) {
      <span class="comment">// One of the iterations produced an error.</span>
      <span class="comment">// All processing will now stop.</span>
      <span class="built_in">console</span>.log(<span class="string">'A file failed to process'</span>);
    } <span class="keyword">else</span> {
      <span class="built_in">console</span>.log(<span class="string">'All files have been processed successfully'</span>);
    }
});
</code></pre>
<hr>
<p><a name="forEachSeries" /><br><a name="eachSeries" /></p>
<h3 id="eachSeries(arr,_iterator,_callback)">eachSeries(arr, iterator, callback)</h3><p>The same as <a href="#each"><code>each</code></a>, only <code>iterator</code> is applied to each item in <code>arr</code> in<br>series. The next <code>iterator</code> is only called once the current one has completed.<br>This means the <code>iterator</code> functions will complete in order.</p>
<hr>
<p><a name="forEachLimit" /><br><a name="eachLimit" /></p>
<h3 id="eachLimit(arr,_limit,_iterator,_callback)">eachLimit(arr, limit, iterator, callback)</h3><p>The same as <a href="#each"><code>each</code></a>, only no more than <code>limit</code> <code>iterator</code>s will be simultaneously<br>running at any time.</p>
<p>Note that the items in <code>arr</code> are not processed in batches, so there is no guarantee that<br>the first <code>limit</code> <code>iterator</code> functions will complete before any others are started.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>limit</code> - The maximum number of <code>iterator</code>s to run at any time.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err)</code> which must be called once it has<br>completed. If no error has occured, the callback should be run without<br>arguments or with an explicit <code>null</code> argument.</li>
<li><code>callback(err)</code> - A callback which is called when all <code>iterator</code> functions<br>have finished, or an error occurs.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// Assume documents is an array of JSON objects and requestApi is a</span>
<span class="comment">// function that interacts with a rate-limited REST api.</span>

<span class="keyword">async</span>.eachLimit(documents, <span class="number">20</span>, requestApi, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>{
    <span class="comment">// if any of the saves produced an error, err would equal that error</span>
});
</code></pre>
<hr>
<p><a name="map" /></p>
<h3 id="map(arr,_iterator,_callback)">map(arr, iterator, callback)</h3><p>Produces a new array of values by mapping each value in <code>arr</code> through<br>the <code>iterator</code> function. The <code>iterator</code> is called with an item from <code>arr</code> and a<br>callback for when it has finished processing. Each of these callback takes 2 arguments:<br>an <code>error</code>, and the transformed item from <code>arr</code>. If <code>iterator</code> passes an error to this<br>callback, the main <code>callback</code> (for the <code>map</code> function) is immediately called with the error.</p>
<p>Note, that since this function applies the <code>iterator</code> to each item in parallel,<br>there is no guarantee that the <code>iterator</code> functions will complete in order.<br>However, the results array will be in the same order as the original <code>arr</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err, transformed)</code> which must be called once<br>it has completed with an error (which can be <code>null</code>) and a transformed item.</li>
<li><code>callback(err, results)</code> - A callback which is called when all <code>iterator</code><br>functions have finished, or an error occurs. Results is an array of the<br>transformed items from the <code>arr</code>.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.map([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.stat, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// results is now an array of stats for each file</span>
});
</code></pre>
<hr>
<p><a name="mapSeries" /></p>
<h3 id="mapSeries(arr,_iterator,_callback)">mapSeries(arr, iterator, callback)</h3><p>The same as <a href="#map"><code>map</code></a>, only the <code>iterator</code> is applied to each item in <code>arr</code> in<br>series. The next <code>iterator</code> is only called once the current one has completed.<br>The results array will be in the same order as the original.</p>
<hr>
<p><a name="mapLimit" /></p>
<h3 id="mapLimit(arr,_limit,_iterator,_callback)">mapLimit(arr, limit, iterator, callback)</h3><p>The same as <a href="#map"><code>map</code></a>, only no more than <code>limit</code> <code>iterator</code>s will be simultaneously<br>running at any time.</p>
<p>Note that the items are not processed in batches, so there is no guarantee that<br>the first <code>limit</code> <code>iterator</code> functions will complete before any others are started.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>limit</code> - The maximum number of <code>iterator</code>s to run at any time.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err, transformed)</code> which must be called once<br>it has completed with an error (which can be <code>null</code>) and a transformed item.</li>
<li><code>callback(err, results)</code> - A callback which is called when all <code>iterator</code><br>calls have finished, or an error occurs. The result is an array of the<br>transformed items from the original <code>arr</code>.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.mapLimit([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], <span class="number">1</span>, fs.stat, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// results is now an array of stats for each file</span>
});
</code></pre>
<hr>
<p><a name="select" /><br><a name="filter" /></p>
<h3 id="filter(arr,_iterator,_callback)">filter(arr, iterator, callback)</h3><p><strong>Alias:</strong> <code>select</code></p>
<p>Returns a new array of all the values in <code>arr</code> which pass an async truth test.<br><em>The callback for each <code>iterator</code> call only accepts a single argument of <code>true</code> or<br><code>false</code>; it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like <code>fs.exists</code>. This operation is<br>performed in parallel, but the results array will be in the same order as the<br>original.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A truth test to apply to each item in <code>arr</code>.<br>The <code>iterator</code> is passed a <code>callback(truthValue)</code>, which must be called with a<br>boolean argument once it has completed.</li>
<li><code>callback(results)</code> - A callback which is called after all the <code>iterator</code><br>functions have finished.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.filter([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.exists, <span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>{
    <span class="comment">// results now equals an array of the existing files</span>
});
</code></pre>
<hr>
<p><a name="selectSeries" /><br><a name="filterSeries" /></p>
<h3 id="filterSeries(arr,_iterator,_callback)">filterSeries(arr, iterator, callback)</h3><p><strong>Alias:</strong> <code>selectSeries</code></p>
<p>The same as <a href="#filter"><code>filter</code></a> only the <code>iterator</code> is applied to each item in <code>arr</code> in<br>series. The next <code>iterator</code> is only called once the current one has completed.<br>The results array will be in the same order as the original.</p>
<hr>
<p><a name="reject" /></p>
<h3 id="reject(arr,_iterator,_callback)">reject(arr, iterator, callback)</h3><p>The opposite of <a href="#filter"><code>filter</code></a>. Removes values that pass an <code>async</code> truth test.</p>
<hr>
<p><a name="rejectSeries" /></p>
<h3 id="rejectSeries(arr,_iterator,_callback)">rejectSeries(arr, iterator, callback)</h3><p>The same as <a href="#reject"><code>reject</code></a>, only the <code>iterator</code> is applied to each item in <code>arr</code><br>in series.</p>
<hr>
<p><a name="reduce" /></p>
<h3 id="reduce(arr,_memo,_iterator,_callback)">reduce(arr, memo, iterator, callback)</h3><p><strong>Aliases:</strong> <code>inject</code>, <code>foldl</code></p>
<p>Reduces <code>arr</code> into a single value using an async <code>iterator</code> to return<br>each successive step. <code>memo</code> is the initial state of the reduction.<br>This function only operates in series. </p>
<p>For performance reasons, it may make sense to split a call to this function into<br>a parallel map, and then use the normal <code>Array.prototype.reduce</code> on the results.<br>This function is for situations where each step in the reduction needs to be async;<br>if you can get the data before reducing it, then it’s probably a good idea to do so.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>memo</code> - The initial state of the reduction.</li>
<li><code>iterator(memo, item, callback)</code> - A function applied to each item in the<br>array to produce the next step in the reduction. The <code>iterator</code> is passed a<br><code>callback(err, reduction)</code> which accepts an optional error as its first<br>argument, and the state of the reduction as the second. If an error is<br>passed to the callback, the reduction is stopped and the main <code>callback</code> is<br>immediately called with the error.</li>
<li><code>callback(err, result)</code> - A callback which is called after all the <code>iterator</code><br>functions have finished. Result is the reduced value.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.reduce([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">memo, item, callback</span>)</span>{
    <span class="comment">// pointless async:</span>
    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        callback(<span class="literal">null</span>, memo + item)
    });
}, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>)</span>{
    <span class="comment">// result is now equal to the last value of memo, which is 6</span>
});
</code></pre>
<hr>
<p><a name="reduceRight" /></p>
<h3 id="reduceRight(arr,_memo,_iterator,_callback)">reduceRight(arr, memo, iterator, callback)</h3><p><strong>Alias:</strong> <code>foldr</code></p>
<p>Same as <a href="#reduce"><code>reduce</code></a>, only operates on <code>arr</code> in reverse order.</p>
<hr>
<p><a name="detect" /></p>
<h3 id="detect(arr,_iterator,_callback)">detect(arr, iterator, callback)</h3><p>Returns the first value in <code>arr</code> that passes an async truth test. The<br><code>iterator</code> is applied in parallel, meaning the first iterator to return <code>true</code> will<br>fire the detect <code>callback</code> with that result. That means the result might not be<br>the first item in the original <code>arr</code> (in terms of order) that passes the test.</p>
<p>If order within the original <code>arr</code> is important, then look at <a href="#detectSeries"><code>detectSeries</code></a>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A truth test to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(truthValue)</code> which must be called with a<br>boolean argument once it has completed.</li>
<li><code>callback(result)</code> - A callback which is called as soon as any iterator returns<br><code>true</code>, or after all the <code>iterator</code> functions have finished. Result will be<br>the first item in the array that passes the truth test (iterator) or the<br>value <code>undefined</code> if none passed.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.detect([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.exists, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>{
    <span class="comment">// result now equals the first file in the list that exists</span>
});
</code></pre>
<hr>
<p><a name="detectSeries" /></p>
<h3 id="detectSeries(arr,_iterator,_callback)">detectSeries(arr, iterator, callback)</h3><p>The same as <a href="#detect"><code>detect</code></a>, only the <code>iterator</code> is applied to each item in <code>arr</code><br>in series. This means the result is always the first in the original <code>arr</code> (in<br>terms of array order) that passes the truth test.</p>
<hr>
<p><a name="sortBy" /></p>
<h3 id="sortBy(arr,_iterator,_callback)">sortBy(arr, iterator, callback)</h3><p>Sorts a list by the results of running each <code>arr</code> value through an async <code>iterator</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err, sortValue)</code> which must be called once it<br>has completed with an error (which can be <code>null</code>) and a value to use as the sort<br>criteria.</li>
<li><code>callback(err, results)</code> - A callback which is called after all the <code>iterator</code><br>functions have finished, or an error occurs. Results is the items from<br>the original <code>arr</code> sorted by the values returned by the <code>iterator</code> calls.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.sortBy([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">file, callback</span>)</span>{
    fs.stat(file, <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>)</span>{
        callback(err, stats.mtime);
    });
}, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// results is now the original array of files sorted by</span>
    <span class="comment">// modified date</span>
});
</code></pre>
<p><strong>Sort Order</strong></p>
<p>By modifying the callback parameter the sorting order can be influenced:</p>
<pre><code class="js"><span class="comment">//ascending order</span>
<span class="keyword">async</span>.sortBy([<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>], <span class="function"><span class="keyword">function</span>(<span class="params">x, callback</span>)</span>{
    callback(err, x);
}, <span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>{
    <span class="comment">//result callback</span>
} );

<span class="comment">//descending order</span>
<span class="keyword">async</span>.sortBy([<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>], <span class="function"><span class="keyword">function</span>(<span class="params">x, callback</span>)</span>{
    callback(err, x*-<span class="number">1</span>);    <span class="comment">//&lt;- x*-1 instead of x, turns the order around</span>
}, <span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>{
    <span class="comment">//result callback</span>
} );
</code></pre>
<hr>
<p><a name="some" /></p>
<h3 id="some(arr,_iterator,_callback)">some(arr, iterator, callback)</h3><p><strong>Alias:</strong> <code>any</code></p>
<p>Returns <code>true</code> if at least one element in the <code>arr</code> satisfies an async test.<br><em>The callback for each iterator call only accepts a single argument of <code>true</code> or<br><code>false</code>; it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like <code>fs.exists</code>. Once any iterator<br>call returns <code>true</code>, the main <code>callback</code> is immediately called.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A truth test to apply to each item in the array<br>in parallel. The iterator is passed a callback(truthValue) which must be<br>called with a boolean argument once it has completed.</li>
<li><code>callback(result)</code> - A callback which is called as soon as any iterator returns<br><code>true</code>, or after all the iterator functions have finished. Result will be<br>either <code>true</code> or <code>false</code> depending on the values of the async tests.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.some([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.exists, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>{
    <span class="comment">// if result is true then at least one of the files exists</span>
});
</code></pre>
<hr>
<p><a name="every" /></p>
<h3 id="every(arr,_iterator,_callback)">every(arr, iterator, callback)</h3><p><strong>Alias:</strong> <code>all</code></p>
<p>Returns <code>true</code> if every element in <code>arr</code> satisfies an async test.<br><em>The callback for each <code>iterator</code> call only accepts a single argument of <code>true</code> or<br><code>false</code>; it does not accept an error argument first!</em> This is in-line with the<br>way node libraries work with truth tests like <code>fs.exists</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A truth test to apply to each item in the array<br>in parallel. The iterator is passed a callback(truthValue) which must be<br>called with a  boolean argument once it has completed.</li>
<li><code>callback(result)</code> - A callback which is called after all the <code>iterator</code><br>functions have finished. Result will be either <code>true</code> or <code>false</code> depending on<br>the values of the async tests.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.every([<span class="string">'file1'</span>,<span class="string">'file2'</span>,<span class="string">'file3'</span>], fs.exists, <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>{
    <span class="comment">// if result is true then every file exists</span>
});
</code></pre>
<hr>
<p><a name="concat" /></p>
<h3 id="concat(arr,_iterator,_callback)">concat(arr, iterator, callback)</h3><p>Applies <code>iterator</code> to each item in <code>arr</code>, concatenating the results. Returns the<br>concatenated list. The <code>iterator</code>s are called in parallel, and the results are<br>concatenated as they return. There is no guarantee that the results array will<br>be returned in the original order of <code>arr</code> passed to the <code>iterator</code> function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arr</code> - An array to iterate over.</li>
<li><code>iterator(item, callback)</code> - A function to apply to each item in <code>arr</code>.<br>The iterator is passed a <code>callback(err, results)</code> which must be called once it<br>has completed with an error (which can be <code>null</code>) and an array of results.</li>
<li><code>callback(err, results)</code> - A callback which is called after all the <code>iterator</code><br>functions have finished, or an error occurs. Results is an array containing<br>the concatenated results of the <code>iterator</code> function.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.concat([<span class="string">'dir1'</span>,<span class="string">'dir2'</span>,<span class="string">'dir3'</span>], fs.readdir, <span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>{
    <span class="comment">// files is now a list of filenames that exist in the 3 directories</span>
});
</code></pre>
<hr>
<p><a name="concatSeries" /></p>
<h3 id="concatSeries(arr,_iterator,_callback)">concatSeries(arr, iterator, callback)</h3><p>Same as <a href="#concat"><code>concat</code></a>, but executes in series instead of parallel.</p>
<h2 id="Control_Flow-1">Control Flow</h2><p><a name="series" /></p>
<h3 id="series(tasks,_[callback])">series(tasks, [callback])</h3><p>Run the functions in the <code>tasks</code> array in series, each one running once the previous<br>function has completed. If any functions in the series pass an error to its<br>callback, no more functions are run, and <code>callback</code> is immediately called with the value of the error.<br>Otherwise, <code>callback</code> receives an array of results when <code>tasks</code> have completed.</p>
<p>It is also possible to use an object instead of an array. Each property will be<br>run as a function, and the results will be passed to the final <code>callback</code> as an object<br>instead of an array. This can be a more readable way of handling results from<br><a href="#series"><code>series</code></a>.</p>
<p><strong>Note</strong> that while many implementations preserve the order of object properties, the<br><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8.6">ECMAScript Language Specifcation</a><br>explicitly states that</p>
<blockquote>
<p>The mechanics and order of enumerating the properties is not specified.</p>
</blockquote>
<p>So if you rely on the order in which your series of functions are executed, and want<br>this to work on all platforms, consider using an array. </p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>tasks</code> - An array or object containing functions to run, each function is passed<br>a <code>callback(err, result)</code> it must call on completion with an error <code>err</code> (which can<br>be <code>null</code>) and an optional <code>result</code> value.</li>
<li><code>callback(err, results)</code> - An optional callback to run once all the functions<br>have completed. This function gets a results array (or object) containing all<br>the result arguments passed to the <code>task</code> callbacks.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.series([
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="comment">// do some stuff ...</span>
        callback(<span class="literal">null</span>, <span class="string">'one'</span>);
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="comment">// do some more stuff ...</span>
        callback(<span class="literal">null</span>, <span class="string">'two'</span>);
    }
],
<span class="comment">// optional callback</span>
<span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// results is now equal to ['one', 'two']</span>
});


<span class="comment">// an example using an object instead of an array</span>
<span class="keyword">async</span>.series({
    one: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="number">1</span>);
        }, <span class="number">200</span>);
    },
    two: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="number">2</span>);
        }, <span class="number">100</span>);
    }
},
<span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>{
    <span class="comment">// results is now equal to: {one: 1, two: 2}</span>
});
</code></pre>
<hr>
<p><a name="parallel" /></p>
<h3 id="parallel(tasks,_[callback])">parallel(tasks, [callback])</h3><p>Run the <code>tasks</code> array of functions in parallel, without waiting until the previous<br>function has completed. If any of the functions pass an error to its<br>callback, the main <code>callback</code> is immediately called with the value of the error.<br>Once the <code>tasks</code> have completed, the results are passed to the final <code>callback</code> as an<br>array.</p>
<p>It is also possible to use an object instead of an array. Each property will be<br>run as a function and the results will be passed to the final <code>callback</code> as an object<br>instead of an array. This can be a more readable way of handling results from<br><a href="#parallel"><code>parallel</code></a>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>tasks</code> - An array or object containing functions to run. Each function is passed<br>a <code>callback(err, result)</code> which it must call on completion with an error <code>err</code><br>(which can be <code>null</code>) and an optional <code>result</code> value.</li>
<li><code>callback(err, results)</code> - An optional callback to run once all the functions<br>have completed. This function gets a results array (or object) containing all<br>the result arguments passed to the task callbacks.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.parallel([
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="string">'one'</span>);
        }, <span class="number">200</span>);
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="string">'two'</span>);
        }, <span class="number">100</span>);
    }
],
<span class="comment">// optional callback</span>
<span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="comment">// the results array will equal ['one','two'] even though</span>
    <span class="comment">// the second function had a shorter timeout.</span>
});


<span class="comment">// an example using an object instead of an array</span>
<span class="keyword">async</span>.parallel({
    one: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="number">1</span>);
        }, <span class="number">200</span>);
    },
    two: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            callback(<span class="literal">null</span>, <span class="number">2</span>);
        }, <span class="number">100</span>);
    }
},
<span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>{
    <span class="comment">// results is now equals to: {one: 1, two: 2}</span>
});
</code></pre>
<hr>
<p><a name="parallelLimit" /></p>
<h3 id="parallelLimit(tasks,_limit,_[callback])">parallelLimit(tasks, limit, [callback])</h3><p>The same as <a href="#parallel"><code>parallel</code></a>, only <code>tasks</code> are executed in parallel<br>with a maximum of <code>limit</code> tasks executing at any time.</p>
<p>Note that the <code>tasks</code> are not executed in batches, so there is no guarantee that<br>the first <code>limit</code> tasks will complete before any others are started.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>tasks</code> - An array or object containing functions to run, each function is passed<br>a <code>callback(err, result)</code> it must call on completion with an error <code>err</code> (which can<br>be <code>null</code>) and an optional <code>result</code> value.</li>
<li><code>limit</code> - The maximum number of <code>tasks</code> to run at any time.</li>
<li><code>callback(err, results)</code> - An optional callback to run once all the functions<br>have completed. This function gets a results array (or object) containing all<br>the result arguments passed to the <code>task</code> callbacks.</li>
</ul>
<hr>
<p><a name="whilst" /></p>
<h3 id="whilst(test,_fn,_callback)">whilst(test, fn, callback)</h3><p>Repeatedly call <code>fn</code>, while <code>test</code> returns <code>true</code>. Calls <code>callback</code> when stopped,<br>or an error occurs.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>test()</code> - synchronous truth test to perform before each execution of <code>fn</code>.</li>
<li><code>fn(callback)</code> - A function which is called each time <code>test</code> passes. The function is<br>passed a <code>callback(err)</code>, which must be called once it has completed with an<br>optional <code>err</code> argument.</li>
<li><code>callback(err)</code> - A callback which is called after the test fails and repeated<br>execution of <code>fn</code> has stopped.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> count = <span class="number">0</span>;

<span class="keyword">async</span>.whilst(
    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{ <span class="keyword">return</span> count &lt; <span class="number">5</span>; },
    <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>{
        count++;
        setTimeout(callback, <span class="number">1000</span>);
    },
    <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
        <span class="comment">// 5 seconds have passed</span>
    }
);
</code></pre>
<hr>
<p><a name="doWhilst" /></p>
<h3 id="doWhilst(fn,_test,_callback)">doWhilst(fn, test, callback)</h3><p>The post-check version of <a href="#whilst"><code>whilst</code></a>. To reflect the difference in<br>the order of operations, the arguments <code>test</code> and <code>fn</code> are switched. </p>
<p><code>doWhilst</code> is to <code>whilst</code> as <code>do while</code> is to <code>while</code> in plain JavaScript.</p>
<hr>
<p><a name="until" /></p>
<h3 id="until(test,_fn,_callback)">until(test, fn, callback)</h3><p>Repeatedly call <code>fn</code> until <code>test</code> returns <code>true</code>. Calls <code>callback</code> when stopped,<br>or an error occurs.</p>
<p>The inverse of <a href="#whilst"><code>whilst</code></a>.</p>
<hr>
<p><a name="doUntil" /></p>
<h3 id="doUntil(fn,_test,_callback)">doUntil(fn, test, callback)</h3><p>Like <a href="#doWhilst"><code>doWhilst</code></a>, except the <code>test</code> is inverted. Note the argument ordering differs from <code>until</code>.</p>
<hr>
<p><a name="forever" /></p>
<h3 id="forever(fn,_errback)">forever(fn, errback)</h3><p>Calls the asynchronous function <code>fn</code> with a callback parameter that allows it to<br>call itself again, in series, indefinitely.</p>
<p>If an error is passed to the callback then <code>errback</code> is called with the<br>error, and execution stops, otherwise it will never be called.</p>
<pre><code class="js"><span class="keyword">async</span>.forever(
    <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>{
        <span class="comment">// next is suitable for passing to things that need a callback(err [, whatever]);</span>
        <span class="comment">// it will result in this function being called again.</span>
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>{
        <span class="comment">// if next is called with a value in its first parameter, it will appear</span>
        <span class="comment">// in here as 'err', and execution will stop.</span>
    }
);
</code></pre>
<hr>
<p><a name="waterfall" /></p>
<h3 id="waterfall(tasks,_[callback])">waterfall(tasks, [callback])</h3><p>Runs the <code>tasks</code> array of functions in series, each passing their results to the next in<br>the array. However, if any of the <code>tasks</code> pass an error to their own callback, the<br>next function is not executed, and the main <code>callback</code> is immediately called with<br>the error.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>tasks</code> - An array of functions to run, each function is passed a<br><code>callback(err, result1, result2, ...)</code> it must call on completion. The first<br>argument is an error (which can be <code>null</code>) and any further arguments will be<br>passed as arguments in order to the next task.</li>
<li><code>callback(err, [results])</code> - An optional callback to run once all the functions<br>have completed. This will be passed the results of the last task’s callback.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.waterfall([
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        callback(<span class="literal">null</span>, <span class="string">'one'</span>, <span class="string">'two'</span>);
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, callback</span>)</span>{
      <span class="comment">// arg1 now equals 'one' and arg2 now equals 'two'</span>
        callback(<span class="literal">null</span>, <span class="string">'three'</span>);
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">arg1, callback</span>)</span>{
        <span class="comment">// arg1 now equals 'three'</span>
        callback(<span class="literal">null</span>, <span class="string">'done'</span>);
    }
], <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>{
   <span class="comment">// result now equals 'done'    </span>
});
</code></pre>
<hr>
<p><a name="compose" /></p>
<h3 id="compose(fn1,_fn2…)">compose(fn1, fn2…)</h3><p>Creates a function which is a composition of the passed asynchronous<br>functions. Each function consumes the return value of the function that<br>follows. Composing functions <code>f()</code>, <code>g()</code>, and <code>h()</code> would produce the result of<br><code>f(g(h()))</code>, only this version uses callbacks to obtain the return values.</p>
<p>Each function is executed with the <code>this</code> binding of the composed function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>functions...</code> - the asynchronous functions to compose</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">n, callback</span>) </span>{
    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        callback(<span class="literal">null</span>, n + <span class="number">1</span>);
    }, <span class="number">10</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">mul3</span>(<span class="params">n, callback</span>) </span>{
    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        callback(<span class="literal">null</span>, n * <span class="number">3</span>);
    }, <span class="number">10</span>);
}

<span class="keyword">var</span> add1mul3 = <span class="keyword">async</span>.compose(mul3, add1);

add1mul3(<span class="number">4</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>{
   <span class="comment">// result now equals 15</span>
});
</code></pre>
<hr>
<p><a name="seq" /></p>
<h3 id="seq(fn1,_fn2…)">seq(fn1, fn2…)</h3><p>Version of the compose function that is more natural to read.<br>Each following function consumes the return value of the latter function. </p>
<p>Each function is executed with the <code>this</code> binding of the composed function.</p>
<p><strong>Arguments</strong></p>
<ul>
<li>functions… - the asynchronous functions to compose</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// Requires lodash (or underscore), express3 and dresende's orm2.</span>
<span class="comment">// Part of an app, that fetches cats of the logged user.</span>
<span class="comment">// This example uses `seq` function to avoid overnesting and error </span>
<span class="comment">// handling clutter.</span>
app.get(<span class="string">'/cats'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>{
  <span class="function"><span class="keyword">function</span> <span class="title">handleError</span>(<span class="params">err, data, callback</span>) </span>{
    <span class="keyword">if</span> (err) {
      <span class="built_in">console</span>.error(err);
      response.json({ status: <span class="string">'error'</span>, message: err.message });
    }
    <span class="keyword">else</span> {
      callback(data);
    }
  }
  <span class="keyword">var</span> User = request.models.User;
  <span class="keyword">async</span>.seq(
    _.bind(User.get, User),  <span class="comment">// 'User.get' has signature (id, callback(err, data))</span>
    handleError,
    <span class="function"><span class="keyword">function</span>(<span class="params">user, fn</span>) </span>{
      user.getCats(fn);      <span class="comment">// 'getCats' has signature (callback(err, data))</span>
    },
    handleError,
    <span class="function"><span class="keyword">function</span>(<span class="params">cats</span>) </span>{
      response.json({ status: <span class="string">'ok'</span>, message: <span class="string">'Cats found'</span>, data: cats });
    }
  )(req.session.user_id);
  }
});
</code></pre>
<hr>
<p><a name="applyEach" /></p>
<h3 id="applyEach(fns,_args…,_callback)">applyEach(fns, args…, callback)</h3><p>Applies the provided arguments to each function in the array, calling<br><code>callback</code> after all functions have completed. If you only provide the first<br>argument, then it will return a function which lets you pass in the<br>arguments as if it were a single function call.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>fns</code> - the asynchronous functions to all call with the same arguments</li>
<li><code>args...</code> - any number of separate arguments to pass to the function</li>
<li><code>callback</code> - the final argument should be the callback, called when all<br>functions have completed processing</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.applyEach([enableSearch, updateSchema], <span class="string">'bucket'</span>, callback);

<span class="comment">// partial application example:</span>
<span class="keyword">async</span>.each(
    buckets,
    <span class="keyword">async</span>.applyEach([enableSearch, updateSchema]),
    callback
);
</code></pre>
<hr>
<p><a name="applyEachSeries" /></p>
<h3 id="applyEachSeries(arr,_iterator,_callback)">applyEachSeries(arr, iterator, callback)</h3><p>The same as <a href="#applyEach"><code>applyEach</code></a> only the functions are applied in series.</p>
<hr>
<p><a name="queue" /></p>
<h3 id="queue(worker,_concurrency)">queue(worker, concurrency)</h3><p>Creates a <code>queue</code> object with the specified <code>concurrency</code>. Tasks added to the<br><code>queue</code> are processed in parallel (up to the <code>concurrency</code> limit). If all<br><code>worker</code>s are in progress, the task is queued until one becomes available.<br>Once a <code>worker</code> completes a <code>task</code>, that <code>task</code>‘s callback is called.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>worker(task, callback)</code> - An asynchronous function for processing a queued<br>task, which must call its <code>callback(err)</code> argument when finished, with an<br>optional <code>error</code> as an argument.</li>
<li><code>concurrency</code> - An <code>integer</code> for determining how many <code>worker</code> functions should be<br>run in parallel.</li>
</ul>
<p><strong>Queue objects</strong></p>
<p>The <code>queue</code> object returned by this function has the following properties and<br>methods:</p>
<ul>
<li><code>length()</code> - a function returning the number of items waiting to be processed.</li>
<li><code>started</code> - a function returning whether or not any items have been pushed and processed by the queue</li>
<li><code>running()</code> - a function returning the number of items currently being processed.</li>
<li><code>idle()</code> - a function returning false if there are items waiting or being processed, or true if not.</li>
<li><code>concurrency</code> - an integer for determining how many <code>worker</code> functions should be<br>run in parallel. This property can be changed after a <code>queue</code> is created to<br>alter the concurrency on-the-fly.</li>
<li><code>push(task, [callback])</code> - add a new task to the <code>queue</code>. Calls <code>callback</code> once<br>the <code>worker</code> has finished processing the task. Instead of a single task, a <code>tasks</code> array<br>can be submitted. The respective callback is used for every task in the list.</li>
<li><code>unshift(task, [callback])</code> - add a new task to the front of the <code>queue</code>.</li>
<li><code>saturated</code> - a callback that is called when the <code>queue</code> length hits the <code>concurrency</code> limit,<br> and further tasks will be queued.</li>
<li><code>empty</code> - a callback that is called when the last item from the <code>queue</code> is given to a <code>worker</code>.</li>
<li><code>drain</code> - a callback that is called when the last item from the <code>queue</code> has returned from the <code>worker</code>.</li>
<li><code>paused</code> - a boolean for determining whether the queue is in a paused state</li>
<li><code>pause()</code> - a function that pauses the processing of tasks until <code>resume()</code> is called.</li>
<li><code>resume()</code> - a function that resumes the processing of queued tasks when the queue is paused.</li>
<li><code>kill()</code> - a function that empties remaining tasks from the queue forcing it to go idle.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// create a queue object with concurrency 2</span>

<span class="keyword">var</span> q = <span class="keyword">async</span>.queue(<span class="function"><span class="keyword">function</span> (<span class="params">task, callback</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'hello '</span> + task.name);
    callback();
}, <span class="number">2</span>);


<span class="comment">// assign a callback</span>
q.drain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'all items have been processed'</span>);
}

<span class="comment">// add some items to the queue</span>

q.push({name: <span class="string">'foo'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing foo'</span>);
});
q.push({name: <span class="string">'bar'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing bar'</span>);
});

<span class="comment">// add some items to the queue (batch-wise)</span>

q.push([{name: <span class="string">'baz'</span>},{name: <span class="string">'bay'</span>},{name: <span class="string">'bax'</span>}], <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing bar'</span>);
});

<span class="comment">// add some items to the front of the queue</span>

q.unshift({name: <span class="string">'bar'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing bar'</span>);
});
</code></pre>
<hr>
<p><a name="priorityQueue" /></p>
<h3 id="priorityQueue(worker,_concurrency)">priorityQueue(worker, concurrency)</h3><p>The same as <a href="#queue"><code>queue</code></a> only tasks are assigned a priority and completed in ascending priority order. There are two differences between <code>queue</code> and <code>priorityQueue</code> objects:</p>
<ul>
<li><code>push(task, priority, [callback])</code> - <code>priority</code> should be a number. If an array of<br><code>tasks</code> is given, all tasks will be assigned the same priority.</li>
<li>The <code>unshift</code> method was removed.</li>
</ul>
<hr>
<p><a name="cargo" /></p>
<h3 id="cargo(worker,_[payload])">cargo(worker, [payload])</h3><p>Creates a <code>cargo</code> object with the specified payload. Tasks added to the<br>cargo will be processed altogether (up to the <code>payload</code> limit). If the<br><code>worker</code> is in progress, the task is queued until it becomes available. Once<br>the <code>worker</code> has completed some tasks, each callback of those tasks is called.<br>Check out <a href="https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966">this animation</a> for how <code>cargo</code> and <code>queue</code> work.</p>
<p>While <a href="#queue">queue</a> passes only one task to one of a group of workers<br>at a time, cargo passes an array of tasks to a single worker, repeating<br>when the worker is finished.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>worker(tasks, callback)</code> - An asynchronous function for processing an array of<br>queued tasks, which must call its <code>callback(err)</code> argument when finished, with<br>an optional <code>err</code> argument.</li>
<li><code>payload</code> - An optional <code>integer</code> for determining how many tasks should be<br>processed per round; if omitted, the default is unlimited.</li>
</ul>
<p><strong>Cargo objects</strong></p>
<p>The <code>cargo</code> object returned by this function has the following properties and<br>methods:</p>
<ul>
<li><code>length()</code> - A function returning the number of items waiting to be processed.</li>
<li><code>payload</code> - An <code>integer</code> for determining how many tasks should be<br>process per round. This property can be changed after a <code>cargo</code> is created to<br>alter the payload on-the-fly.</li>
<li><code>push(task, [callback])</code> - Adds <code>task</code> to the <code>queue</code>. The callback is called<br>once the <code>worker</code> has finished processing the task. Instead of a single task, an array of <code>tasks</code><br>can be submitted. The respective callback is used for every task in the list.</li>
<li><code>saturated</code> - A callback that is called when the <code>queue.length()</code> hits the concurrency and further tasks will be queued.</li>
<li><code>empty</code> - A callback that is called when the last item from the <code>queue</code> is given to a <code>worker</code>.</li>
<li><code>drain</code> - A callback that is called when the last item from the <code>queue</code> has returned from the <code>worker</code>.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// create a cargo object with payload 2</span>

<span class="keyword">var</span> cargo = <span class="keyword">async</span>.cargo(<span class="function"><span class="keyword">function</span> (<span class="params">tasks, callback</span>) </span>{
    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;tasks.length; i++){
      <span class="built_in">console</span>.log(<span class="string">'hello '</span> + tasks[i].name);
    }
    callback();
}, <span class="number">2</span>);


<span class="comment">// add some items</span>

cargo.push({name: <span class="string">'foo'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing foo'</span>);
});
cargo.push({name: <span class="string">'bar'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing bar'</span>);
});
cargo.push({name: <span class="string">'baz'</span>}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'finished processing baz'</span>);
});
</code></pre>
<hr>
<p><a name="auto" /></p>
<h3 id="auto(tasks,_[callback])">auto(tasks, [callback])</h3><p>Determines the best order for running the functions in <code>tasks</code>, based on their<br>requirements. Each function can optionally depend on other functions being completed<br>first, and each function is run as soon as its requirements are satisfied. </p>
<p>If any of the functions pass an error to their callback, it will not<br>complete (so any other functions depending on it will not run), and the main<br><code>callback</code> is immediately called with the error. Functions also receive an<br>object containing the results of functions which have completed so far.</p>
<p>Note, all functions are called with a <code>results</code> object as a second argument,<br>so it is unsafe to pass functions in the <code>tasks</code> object which cannot handle the<br>extra argument. </p>
<p>For example, this snippet of code:</p>
<pre><code class="js"><span class="keyword">async</span>.auto({
  readData: <span class="keyword">async</span>.apply(fs.readFile, <span class="string">'data.txt'</span>, <span class="string">'utf-8'</span>)
}, callback);
</code></pre>
<p>will have the effect of calling <code>readFile</code> with the results object as the last<br>argument, which will fail:</p>
<pre><code class="js">fs.readFile(<span class="string">'data.txt'</span>, <span class="string">'utf-8'</span>, cb, {});
</code></pre>
<p>Instead, wrap the call to <code>readFile</code> in a function which does not forward the<br><code>results</code> object:</p>
<pre><code class="js"><span class="keyword">async</span>.auto({
  readData: <span class="function"><span class="keyword">function</span>(<span class="params">cb, results</span>)</span>{
    fs.readFile(<span class="string">'data.txt'</span>, <span class="string">'utf-8'</span>, cb);
  }
}, callback);
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>tasks</code> - An object. Each of its properties is either a function or an array of<br>requirements, with the function itself the last item in the array. The object’s key<br>of a property serves as the name of the task defined by that property,<br>i.e. can be used when specifying requirements for other tasks.<br>The function receives two arguments: (1) a <code>callback(err, result)</code> which must be<br>called when finished, passing an <code>error</code> (which can be <code>null</code>) and the result of<br>the function’s execution, and (2) a <code>results</code> object, containing the results of<br>the previously executed functions.</li>
<li><code>callback(err, results)</code> - An optional callback which is called when all the<br>tasks have been completed. It receives the <code>err</code> argument if any <code>tasks</code><br>pass an error to their callback. Results are always returned; however, if<br>an error occurs, no further <code>tasks</code> will be performed, and the results<br>object will only contain partial results.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">async</span>.auto({
    get_data: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="built_in">console</span>.log(<span class="string">'in get_data'</span>);
        <span class="comment">// async code to get some data</span>
        callback(<span class="literal">null</span>, <span class="string">'data'</span>, <span class="string">'converted to array'</span>);
    },
    make_folder: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="built_in">console</span>.log(<span class="string">'in make_folder'</span>);
        <span class="comment">// async code to create a directory to store a file in</span>
        <span class="comment">// this is run at the same time as getting the data</span>
        callback(<span class="literal">null</span>, <span class="string">'folder'</span>);
    },
    write_file: [<span class="string">'get_data'</span>, <span class="string">'make_folder'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback, results</span>)</span>{
        <span class="built_in">console</span>.log(<span class="string">'in write_file'</span>, <span class="built_in">JSON</span>.stringify(results));
        <span class="comment">// once there is some data and the directory exists,</span>
        <span class="comment">// write the data to a file in the directory</span>
        callback(<span class="literal">null</span>, <span class="string">'filename'</span>);
    }],
    email_link: [<span class="string">'write_file'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback, results</span>)</span>{
        <span class="built_in">console</span>.log(<span class="string">'in email_link'</span>, <span class="built_in">JSON</span>.stringify(results));
        <span class="comment">// once the file is written let's email a link to it...</span>
        <span class="comment">// results.write_file contains the filename returned by write_file.</span>
        callback(<span class="literal">null</span>, {<span class="string">'file'</span>:results.write_file, <span class="string">'email'</span>:<span class="string">'user@example.com'</span>});
    }]
}, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'err = '</span>, err);
    <span class="built_in">console</span>.log(<span class="string">'results = '</span>, results);
});
</code></pre>
<p>This is a fairly trivial example, but to do this using the basic parallel and<br>series functions would look like this:</p>
<pre><code class="js"><span class="keyword">async</span>.parallel([
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="built_in">console</span>.log(<span class="string">'in get_data'</span>);
        <span class="comment">// async code to get some data</span>
        callback(<span class="literal">null</span>, <span class="string">'data'</span>, <span class="string">'converted to array'</span>);
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        <span class="built_in">console</span>.log(<span class="string">'in make_folder'</span>);
        <span class="comment">// async code to create a directory to store a file in</span>
        <span class="comment">// this is run at the same time as getting the data</span>
        callback(<span class="literal">null</span>, <span class="string">'folder'</span>);
    }
],
<span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>)</span>{
    <span class="keyword">async</span>.series([
        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
            <span class="built_in">console</span>.log(<span class="string">'in write_file'</span>, <span class="built_in">JSON</span>.stringify(results));
            <span class="comment">// once there is some data and the directory exists,</span>
            <span class="comment">// write the data to a file in the directory</span>
            results.push(<span class="string">'filename'</span>);
            callback(<span class="literal">null</span>);
        },
        <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
            <span class="built_in">console</span>.log(<span class="string">'in email_link'</span>, <span class="built_in">JSON</span>.stringify(results));
            <span class="comment">// once the file is written let's email a link to it...</span>
            callback(<span class="literal">null</span>, {<span class="string">'file'</span>:results.pop(), <span class="string">'email'</span>:<span class="string">'user@example.com'</span>});
        }
    ]);
});
</code></pre>
<p>For a complicated series of <code>async</code> tasks, using the <a href="#auto"><code>auto</code></a> function makes adding<br>new tasks much easier (and the code more readable).</p>
<hr>
<p><a name="retry" /></p>
<h3 id="retry([times_=_5],_task,_[callback])">retry([times = 5], task, [callback])</h3><p>Attempts to get a successful response from <code>task</code> no more than <code>times</code> times before<br>returning an error. If the task is successful, the <code>callback</code> will be passed the result<br>of the successfull task. If all attemps fail, the callback will be passed the error and<br>result (if any) of the final attempt.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>times</code> - An integer indicating how many times to attempt the <code>task</code> before giving up. Defaults to 5.</li>
<li><code>task(callback, results)</code> - A function which receives two arguments: (1) a <code>callback(err, result)</code><br>which must be called when finished, passing <code>err</code> (which can be <code>null</code>) and the <code>result</code> of<br>the function’s execution, and (2) a <code>results</code> object, containing the results of<br>the previously executed functions (if nested inside another control flow).</li>
<li><code>callback(err, results)</code> - An optional callback which is called when the<br>task has succeeded, or after the final failed attempt. It receives the <code>err</code> and <code>result</code> arguments of the last attempt at completing the <code>task</code>.</li>
</ul>
<p>The <a href="#retry"><code>retry</code></a> function can be used as a stand-alone control flow by passing a<br>callback, as shown below:</p>
<pre><code class="js"><span class="keyword">async</span>.retry(<span class="number">3</span>, apiMethod, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>{
    <span class="comment">// do something with the result</span>
});
</code></pre>
<p>It can also be embeded within other control flow functions to retry individual methods<br>that are not as reliable, like this:</p>
<pre><code class="js"><span class="keyword">async</span>.auto({
    users: api.getUsers.bind(api),
    payments: <span class="keyword">async</span>.retry(<span class="number">3</span>, api.getPayments.bind(api))
}, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>{
  <span class="comment">// do something with the results</span>
});
</code></pre>
<hr>
<p><a name="iterator" /></p>
<h3 id="iterator(tasks)">iterator(tasks)</h3><p>Creates an iterator function which calls the next function in the <code>tasks</code> array,<br>returning a continuation to call the next one after that. It’s also possible to<br>“peek” at the next iterator with <code>iterator.next()</code>.</p>
<p>This function is used internally by the <code>async</code> module, but can be useful when<br>you want to manually control the flow of functions in series.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>tasks</code> - An array of functions to run.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> iterator = <span class="keyword">async</span>.iterator([
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ sys.p(<span class="string">'one'</span>); },
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ sys.p(<span class="string">'two'</span>); },
    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ sys.p(<span class="string">'three'</span>); }
]);

node&gt; <span class="keyword">var</span> iterator2 = iterator();
<span class="string">'one'</span>
node&gt; <span class="keyword">var</span> iterator3 = iterator2();
<span class="string">'two'</span>
node&gt; iterator3();
<span class="string">'three'</span>
node&gt; <span class="keyword">var</span> nextfn = iterator2.next();
node&gt; nextfn();
<span class="string">'three'</span>
</code></pre>
<hr>
<p><a name="apply" /></p>
<h3 id="apply(function,_arguments-)">apply(function, arguments..)</h3><p>Creates a continuation function with some arguments already applied. </p>
<p>Useful as a shorthand when combined with other control flow functions. Any arguments<br>passed to the returned function are added to the arguments originally passed<br>to apply.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>function</code> - The function you want to eventually apply all arguments to.</li>
<li><code>arguments...</code> - Any number of arguments to automatically apply when the<br>continuation is called.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// using apply</span>

<span class="keyword">async</span>.parallel([
    <span class="keyword">async</span>.apply(fs.writeFile, <span class="string">'testfile1'</span>, <span class="string">'test1'</span>),
    <span class="keyword">async</span>.apply(fs.writeFile, <span class="string">'testfile2'</span>, <span class="string">'test2'</span>),
]);


<span class="comment">// the same process without using apply</span>

<span class="keyword">async</span>.parallel([
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        fs.writeFile(<span class="string">'testfile1'</span>, <span class="string">'test1'</span>, callback);
    },
    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
        fs.writeFile(<span class="string">'testfile2'</span>, <span class="string">'test2'</span>, callback);
    }
]);
</code></pre>
<p>It’s possible to pass any number of additional arguments when calling the<br>continuation:</p>
<pre><code class="js">node&gt; <span class="keyword">var</span> fn = <span class="keyword">async</span>.apply(sys.puts, <span class="string">'one'</span>);
node&gt; fn(<span class="string">'two'</span>, <span class="string">'three'</span>);
one
two
three
</code></pre>
<hr>
<p><a name="nextTick" /></p>
<h3 id="nextTick(callback)">nextTick(callback)</h3><p>Calls <code>callback</code> on a later loop around the event loop. In Node.js this just<br>calls <code>process.nextTick</code>; in the browser it falls back to <code>setImmediate(callback)</code><br>if available, otherwise <code>setTimeout(callback, 0)</code>, which means other higher priority<br>events may precede the execution of <code>callback</code>.</p>
<p>This is used internally for browser-compatibility purposes.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>callback</code> - The function to call on a later loop around the event loop.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> call_order = [];
<span class="keyword">async</span>.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
    call_order.push(<span class="string">'two'</span>);
    <span class="comment">// call_order now equals ['one','two']</span>
});
call_order.push(<span class="string">'one'</span>)
</code></pre>
<p><a name="times" /></p>
<h3 id="times(n,_callback)">times(n, callback)</h3><p>Calls the <code>callback</code> function <code>n</code> times, and accumulates results in the same manner<br>you would use with <a href="#map"><code>map</code></a>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>n</code> - The number of times to run the function.</li>
<li><code>callback</code> - The function to call <code>n</code> times.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="comment">// Pretend this is some complicated async factory</span>
<span class="keyword">var</span> createUser = <span class="function"><span class="keyword">function</span>(<span class="params">id, callback</span>) </span>{
  callback(<span class="literal">null</span>, {
    id: <span class="string">'user'</span> + id
  })
}
<span class="comment">// generate 5 users</span>
<span class="keyword">async</span>.times(<span class="number">5</span>, <span class="function"><span class="keyword">function</span>(<span class="params">n, next</span>)</span>{
    createUser(n, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>{
      next(err, user)
    })
}, <span class="function"><span class="keyword">function</span>(<span class="params">err, users</span>) </span>{
  <span class="comment">// we should now have 5 users</span>
});
</code></pre>
<p><a name="timesSeries" /></p>
<h3 id="timesSeries(n,_callback)">timesSeries(n, callback)</h3><p>The same as <a href="#times"><code>times</code></a>, only the iterator is applied to each item in <code>arr</code> in<br>series. The next <code>iterator</code> is only called once the current one has completed.<br>The results array will be in the same order as the original.</p>
<h2 id="Utils-1">Utils</h2><p><a name="memoize" /></p>
<h3 id="memoize(fn,_[hasher])">memoize(fn, [hasher])</h3><p>Caches the results of an <code>async</code> function. When creating a hash to store function<br>results against, the callback is omitted from the hash and an optional hash<br>function can be used.</p>
<p>The cache of results is exposed as the <code>memo</code> property of the function returned<br>by <code>memoize</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>fn</code> - The function to proxy and cache results from.</li>
<li><code>hasher</code> - Tn optional function for generating a custom hash for storing<br>results. It has all the arguments applied to it apart from the callback, and<br>must be synchronous.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> slow_fn = <span class="function"><span class="keyword">function</span> (<span class="params">name, callback</span>) </span>{
    <span class="comment">// do something</span>
    callback(<span class="literal">null</span>, result);
};
<span class="keyword">var</span> fn = <span class="keyword">async</span>.memoize(slow_fn);

<span class="comment">// fn can now be used as if it were slow_fn</span>
fn(<span class="string">'some name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="comment">// callback</span>
});
</code></pre>
<p><a name="unmemoize" /></p>
<h3 id="unmemoize(fn)">unmemoize(fn)</h3><p>Undoes a <a href="#memoize"><code>memoize</code></a>d function, reverting it to the original, unmemoized<br>form. Handy for testing.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>fn</code> - the memoized function</li>
</ul>
<p><a name="log" /></p>
<h3 id="log(function,_arguments)">log(function, arguments)</h3><p>Logs the result of an <code>async</code> function to the <code>console</code>. Only works in Node.js or<br>in browsers that support <code>console.log</code> and <code>console.error</code> (such as FF and Chrome).<br>If multiple arguments are returned from the async function, <code>console.log</code> is<br>called on each argument in order.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>function</code> - The function you want to eventually apply all arguments to.</li>
<li><code>arguments...</code> - Any number of arguments to apply to the function.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params">name, callback</span>)</span>{
    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        callback(<span class="literal">null</span>, <span class="string">'hello '</span> + name);
    }, <span class="number">1000</span>);
};
</code></pre>
<pre><code class="js">node&gt; <span class="keyword">async</span>.log(hello, <span class="string">'world'</span>);
<span class="string">'hello world'</span>
</code></pre>
<hr>
<p><a name="dir" /></p>
<h3 id="dir(function,_arguments)">dir(function, arguments)</h3><p>Logs the result of an <code>async</code> function to the <code>console</code> using <code>console.dir</code> to<br>display the properties of the resulting object. Only works in Node.js or<br>in browsers that support <code>console.dir</code> and <code>console.error</code> (such as FF and Chrome).<br>If multiple arguments are returned from the async function, <code>console.dir</code> is<br>called on each argument in order.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>function</code> - The function you want to eventually apply all arguments to.</li>
<li><code>arguments...</code> - Any number of arguments to apply to the function.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="js"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params">name, callback</span>)</span>{
    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
        callback(<span class="literal">null</span>, {hello: name});
    }, <span class="number">1000</span>);
};
</code></pre>
<pre><code class="js">node&gt; <span class="keyword">async</span>.dir(hello, <span class="string">'world'</span>);
{hello: <span class="string">'world'</span>}
</code></pre>
<hr>
<p><a name="noConflict" /></p>
<h3 id="noConflict()">noConflict()</h3><p>Changes the value of <code>async</code> back to its original value, returning a reference to the<br><code>async</code> object.</p>
