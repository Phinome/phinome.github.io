<h1 id="combined-stream">combined-stream <a href="https://travis-ci.org/felixge/node-combined-stream"><img src="https://travis-ci.org/felixge/node-combined-stream.svg?branch=master" alt="Build Status"></a></h1><p>A stream that emits multiple other streams one after another.</p>
<h2 id="Installation">Installation</h2><pre><code class="bash">npm install combined-stream
</code></pre>
<h2 id="Usage">Usage</h2><p>Here is a simple example that shows how you can use combined-stream to combine<br>two files into one:</p>
<pre><code class="javascript"><span class="keyword">var</span> CombinedStream = <span class="built_in">require</span>(<span class="string">'combined-stream'</span>);
<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);

<span class="keyword">var</span> combinedStream = CombinedStream.create();
combinedStream.append(fs.createReadStream(<span class="string">'file1.txt'</span>));
combinedStream.append(fs.createReadStream(<span class="string">'file2.txt'</span>));

combinedStream.pipe(fs.createWriteStream(<span class="string">'combined.txt'</span>));
</code></pre>
<p>While the example above works great, it will pause all source streams until<br>they are needed. If you don’t want that to happen, you can set <code>pauseStreams</code><br>to <code>false</code>:</p>
<pre><code class="javascript"><span class="keyword">var</span> CombinedStream = <span class="built_in">require</span>(<span class="string">'combined-stream'</span>);
<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);

<span class="keyword">var</span> combinedStream = CombinedStream.create({pauseStreams: <span class="literal">false</span>});
combinedStream.append(fs.createReadStream(<span class="string">'file1.txt'</span>));
combinedStream.append(fs.createReadStream(<span class="string">'file2.txt'</span>));

combinedStream.pipe(fs.createWriteStream(<span class="string">'combined.txt'</span>));
</code></pre>
<p>However, what if you don’t have all the source streams yet, or you don’t want<br>to allocate the resources (file descriptors, memory, etc.) for them right away?<br>Well, in that case you can simply provide a callback that supplies the stream<br>by calling a <code>next()</code> function:</p>
<pre><code class="javascript"><span class="keyword">var</span> CombinedStream = <span class="built_in">require</span>(<span class="string">'combined-stream'</span>);
<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);

<span class="keyword">var</span> combinedStream = CombinedStream.create();
combinedStream.append(<span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>{
  next(fs.createReadStream(<span class="string">'file1.txt'</span>));
});
combinedStream.append(<span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>{
  next(fs.createReadStream(<span class="string">'file2.txt'</span>));
});

combinedStream.pipe(fs.createWriteStream(<span class="string">'combined.txt'</span>));
</code></pre>
<h2 id="API">API</h2><h3 id="CombinedStream-create([options])">CombinedStream.create([options])</h3><p>Returns a new combined stream object. Available options are:</p>
<ul>
<li><code>maxDataSize</code></li>
<li><code>pauseStreams</code></li>
</ul>
<p>The effect of those options is described below.</p>
<h3 id="combinedStream-pauseStreams_=_true">combinedStream.pauseStreams = <code>true</code></h3><p>Whether to apply back pressure to the underlaying streams. If set to <code>false</code>,<br>the underlaying streams will never be paused. If set to <code>true</code>, the<br>underlaying streams will be paused right after being appended, as well as when<br><code>delayedStream.pipe()</code> wants to throttle.</p>
<h3 id="combinedStream-maxDataSize_=_2_*_1024_*_1024">combinedStream.maxDataSize = <code>2 * 1024 * 1024</code></h3><p>The maximum amount of bytes (or characters) to buffer for all source streams.<br>If this value is exceeded, <code>combinedStream</code> emits an <code>&#39;error&#39;</code> event.</p>
<h3 id="combinedStream-dataSize_=_0">combinedStream.dataSize = <code>0</code></h3><p>The amount of bytes (or characters) currently buffered by <code>combinedStream</code>.</p>
<h3 id="combinedStream-append(stream)">combinedStream.append(stream)</h3><p>Appends the given <code>stream</code> to the combinedStream object. If <code>pauseStreams</code> is<br>set to `true, this stream will also be paused right away.</p>
<p><code>streams</code> can also be a function that takes one parameter called <code>next</code>. <code>next</code><br>is a function that must be invoked in order to provide the <code>next</code> stream, see<br>example above.</p>
<p>Regardless of how the <code>stream</code> is appended, combined-stream always attaches an<br><code>&#39;error&#39;</code> listener to it, so you don’t have to do that manually.</p>
<p>Special case: <code>stream</code> can also be a String or Buffer.</p>
<h3 id="combinedStream-write(data)">combinedStream.write(data)</h3><p>You should not call this, <code>combinedStream</code> takes care of piping the appended<br>streams into itself for you.</p>
<h3 id="combinedStream-resume()">combinedStream.resume()</h3><p>Causes <code>combinedStream</code> to start drain the streams it manages. The function is<br>idempotent, and also emits a <code>&#39;resume&#39;</code> event each time which usually goes to<br>the stream that is currently being drained.</p>
<h3 id="combinedStream-pause();">combinedStream.pause();</h3><p>If <code>combinedStream.pauseStreams</code> is set to <code>false</code>, this does nothing.<br>Otherwise a <code>&#39;pause&#39;</code> event is emitted, this goes to the stream that is<br>currently being drained, so you can use it to apply back pressure.</p>
<h3 id="combinedStream-end();">combinedStream.end();</h3><p>Sets <code>combinedStream.writable</code> to false, emits an <code>&#39;end&#39;</code> event, and removes<br>all streams from the queue.</p>
<h3 id="combinedStream-destroy();">combinedStream.destroy();</h3><p>Same as <code>combinedStream.end()</code>, except it emits a <code>&#39;close&#39;</code> event instead of<br><code>&#39;end&#39;</code>.</p>
<h2 id="License">License</h2><p>combined-stream is licensed under the MIT license.</p>
