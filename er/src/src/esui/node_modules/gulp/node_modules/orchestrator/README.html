<p><a href="https://travis-ci.org/orchestrator/orchestrator"><img src="https://secure.travis-ci.org/orchestrator/orchestrator.svg?branch=master" alt="Build Status"></a><br><a href="https://david-dm.org/orchestrator/orchestrator"><img src="https://david-dm.org/orchestrator/orchestrator.svg" alt="Dependency Status"></a></p>
<h1 id="Orchestrator">Orchestrator</h1><p>A module for sequencing and executing tasks and dependencies in maximum concurrency</p>
<h2 id="Usage">Usage</h2><h3 id="1-_Get_a_reference:">1. Get a reference:</h3><pre><code class="javascript"><span class="keyword">var</span> Orchestrator = <span class="built_in">require</span>(<span class="string">'orchestrator'</span>);
<span class="keyword">var</span> orchestrator = <span class="keyword">new</span> Orchestrator();
</code></pre>
<h3 id="2-_Load_it_up_with_stuff_to_do:">2. Load it up with stuff to do:</h3><pre><code class="javascript">orchestrator.add(<span class="string">'thing1'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  <span class="comment">// do stuff</span>
});
orchestrator.add(<span class="string">'thing2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  <span class="comment">// do stuff</span>
});
</code></pre>
<h3 id="3-_Run_the_tasks:">3. Run the tasks:</h3><pre><code class="javascript">orchestrator.start(<span class="string">'thing1'</span>, <span class="string">'thing2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
  <span class="comment">// all done</span>
});
</code></pre>
<h2 id="API">API</h2><h3 id="orchestrator-add(name[,_deps][,_function]);">orchestrator.add(name[, deps][, function]);</h3><p>Define a task</p>
<pre><code class="javascript">orchestrator.add(<span class="string">'thing1'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  <span class="comment">// do stuff</span>
});
</code></pre>
<h4 id="name">name</h4><p>Type: <code>String</code></p>
<p>The name of the task.</p>
<h4 id="deps">deps</h4><p>Type: <code>Array</code></p>
<p>An array of task names to be executed and completed before your task will run.</p>
<pre><code class="javascript">orchestrator.add(<span class="string">'mytask'</span>, [<span class="string">'array'</span>, <span class="string">'of'</span>, <span class="string">'task'</span>, <span class="string">'names'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
  <span class="comment">// Do stuff</span>
});
</code></pre>
<p><strong>Note:</strong> Are your tasks running before the dependencies are complete?  Make sure your dependency tasks<br>are correctly using the async run hints: take in a callback or return a promise or event stream.</p>
<h4 id="fn">fn</h4><p>Type: <code>function</code></p>
<p>The function that performs the task’s operations.  For asynchronous tasks, you need to provide a hint when the task is complete:</p>
<ul>
<li>Take in a callback</li>
<li>Return a stream or a promise</li>
</ul>
<h4 id="examples:">examples:</h4><p><strong>Accept a callback:</strong></p>
<pre><code class="javascript">orchestrator.add(<span class="string">'thing2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{
  <span class="comment">// do stuff</span>
  callback(err);
});
</code></pre>
<p><strong>Return a promise:</strong></p>
<pre><code class="javascript"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);

orchestrator.add(<span class="string">'thing3'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  <span class="keyword">var</span> deferred = Q.defer();

  <span class="comment">// do async stuff</span>
  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    deferred.resolve();
  }, <span class="number">1</span>);

  <span class="keyword">return</span> deferred.promise;
});
</code></pre>
<p><strong>Return a stream:</strong> (task is marked complete when stream ends)</p>
<pre><code class="javascript"><span class="keyword">var</span> map = <span class="built_in">require</span>(<span class="string">'map-stream'</span>);

orchestrator.add(<span class="string">'thing4'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
  <span class="keyword">var</span> stream = map(<span class="function"><span class="keyword">function</span> (<span class="params">args, cb</span>) </span>{
    cb(<span class="literal">null</span>, args);
  });
  <span class="comment">// do stream stuff</span>
  <span class="keyword">return</span> stream;
});
</code></pre>
<p><strong>Note:</strong> By default, tasks run with maximum concurrency — e.g. it launches all the tasks at once and waits for nothing.<br>If you want to create a series where tasks run in a particular order, you need to do two things:</p>
<ul>
<li>give it a hint to tell it when the task is done,</li>
<li>and give it a hint that a task depends on completion of another.</li>
</ul>
<p>For these examples, let’s presume you have two tasks, “one” and “two” that you specifically want to run in this order:</p>
<ol>
<li><p>In task “one” you add a hint to tell it when the task is done.  Either take in a callback and call it when you’re<br>done or return a promise or stream that the engine should wait to resolve or end respectively.</p>
</li>
<li><p>In task “two” you add a hint telling the engine that it depends on completion of the first task.</p>
</li>
</ol>
<p>So this example would look like this:</p>
<pre><code class="javascript"><span class="keyword">var</span> Orchestrator = <span class="built_in">require</span>(<span class="string">'orchestrator'</span>);
<span class="keyword">var</span> orchestrator = <span class="keyword">new</span> Orchestrator();

<span class="comment">// takes in a callback so the engine knows when it'll be done</span>
orchestrator.add(<span class="string">'one'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>{
    <span class="comment">// do stuff -- async or otherwise</span>
    cb(err); <span class="comment">// if err is not null or undefined, the orchestration will stop, and <span class="doctag"><span class="keyword">note</span></span> that it failed</span>
});

<span class="comment">// identifies a dependent task must be complete before this one begins</span>
orchestrator.add(<span class="string">'two'</span>, [<span class="string">'one'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="comment">// task 'one' is done now</span>
});

orchestrator.start(<span class="string">'one'</span>, <span class="string">'two'</span>);
</code></pre>
<h3 id="orchestrator-hasTask(name);">orchestrator.hasTask(name);</h3><p>Have you defined a task with this name?</p>
<h4 id="name-1">name</h4><p>Type: <code>String</code></p>
<p>The task name to query</p>
<h3 id="orchestrator-start(tasks…[,_cb]);">orchestrator.start(tasks…[, cb]);</h3><p>Start running the tasks</p>
<h4 id="tasks">tasks</h4><p>Type: <code>String</code> or <code>Array</code> of <code>String</code>s</p>
<p>Tasks to be executed. You may pass any number of tasks as individual arguments.</p>
<h4 id="cb">cb</h4><p>Type: <code>function</code>: <code>function (err) {</code></p>
<p>Callback to call after run completed.</p>
<p>Passes single argument: <code>err</code>: did the orchestration succeed?</p>
<p><strong>Note:</strong> Tasks run concurrently and therefore may not complete in order.<br><strong>Note:</strong> Orchestrator uses <code>sequencify</code> to resolve dependencies before running, and therefore may not start in order.<br>Listen to orchestration events to watch task running.</p>
<pre><code class="javascript">orchestrator.start(<span class="string">'thing1'</span>, <span class="string">'thing2'</span>, <span class="string">'thing3'</span>, <span class="string">'thing4'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{
  <span class="comment">// all done</span>
});
</code></pre>
<pre><code class="javascript">orchestrator.start([<span class="string">'thing1'</span>,<span class="string">'thing2'</span>], [<span class="string">'thing3'</span>,<span class="string">'thing4'</span>]);
</code></pre>
<p><strong>FRAGILE:</strong> Orchestrator catches exceptions on sync runs to pass to your callback<br>but doesn’t hook to process.uncaughtException so it can’t pass those exceptions<br>to your callback</p>
<p><strong>FRAGILE:</strong> Orchestrator will ensure each task and each dependency is run once during an orchestration run<br>even if you specify it to run more than once. (e.g. <code>orchestrator.start(&#39;thing1&#39;, &#39;thing1&#39;)</code><br>will only run ‘thing1’ once.) If you need it to run a task multiple times, wait for<br>the orchestration to end (start’s callback) then call start again.<br>(e.g. <code>orchestrator.start(&#39;thing1&#39;, function () {orchestrator.start(&#39;thing1&#39;);})</code>.)<br>Alternatively create a second orchestrator instance.</p>
<h3 id="orchestrator-stop()">orchestrator.stop()</h3><p>Stop an orchestration run currently in process</p>
<p><strong>Note:</strong> It will call the <code>start()</code> callback with an <code>err</code> noting the orchestration was aborted</p>
<h3 id="orchestrator-on(event,_cb);">orchestrator.on(event, cb);</h3><p>Listen to orchestrator internals</p>
<h4 id="event">event</h4><p>Type: <code>String</code></p>
<p>Event name to listen to:</p>
<ul>
<li>start: from start() method, shows you the task sequence</li>
<li>stop: from stop() method, the queue finished successfully</li>
<li>err: from stop() method, the queue was aborted due to a task error</li>
<li>task_start: from _runTask() method, task was started</li>
<li>task_stop: from _runTask() method, task completed successfully</li>
<li>task_err: from _runTask() method, task errored</li>
<li>task_not_found: from start() method, you’re trying to start a task that doesn’t exist</li>
<li>task_recursion: from start() method, there are recursive dependencies in your task list</li>
</ul>
<h4 id="cb-1">cb</h4><p>Type: <code>function</code>: <code>function (e) {</code></p>
<p>Passes single argument: <code>e</code>: event details</p>
<pre><code class="javascript">orchestrator.on(<span class="string">'task_start'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>{
  <span class="comment">// e.message is the log message</span>
  <span class="comment">// e.task is the task name if the message applies to a task else `undefined`</span>
  <span class="comment">// e.err is the error if event is 'err' else `undefined`</span>
});
<span class="comment">// for task_end and task_err:</span>
orchestrator.on(<span class="string">'task_stop'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>{
  <span class="comment">// e is the same object from task_start</span>
  <span class="comment">// e.message is updated to show how the task ended</span>
  <span class="comment">// e.duration is the task run duration (in seconds)</span>
});
</code></pre>
<p><strong>Note:</strong> fires either <em>stop or </em>err but not both.</p>
<h3 id="orchestrator-onAll(cb);">orchestrator.onAll(cb);</h3><p>Listen to all orchestrator events from one callback</p>
<h4 id="cb-2">cb</h4><p>Type: <code>function</code>: <code>function (e) {</code></p>
<p>Passes single argument: <code>e</code>: event details</p>
<pre><code class="javascript">orchestrator.onAll(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>{
  <span class="comment">// e is the original event args</span>
  <span class="comment">// e.src is event name</span>
});
</code></pre>
<h2 id="LICENSE">LICENSE</h2><p>(MIT License)</p>
<p>Copyright (c) 2013 <a href="http://richardsonandsons.com/">Richardson &amp; Sons, LLC</a></p>
<p>Permission is hereby granted, free of charge, to any person obtaining<br>a copy of this software and associated documentation files (the<br>“Software”), to deal in the Software without restriction, including<br>without limitation the rights to use, copy, modify, merge, publish,<br>distribute, sublicense, and/or sell copies of the Software, and to<br>permit persons to whom the Software is furnished to do so, subject to<br>the following conditions:</p>
<p>The above copyright notice and this permission notice shall be<br>included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,<br>EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF<br>MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND<br>NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE<br>LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION<br>OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION<br>WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
