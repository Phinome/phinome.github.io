<p><a href="https://travis-ci.org/isaacs/node-glob/"><img src="https://travis-ci.org/isaacs/node-glob.svg?branch=master" alt="Build Status"></a> <a href="https://david-dm.org/isaacs/node-glob"><img src="https://david-dm.org/isaacs/node-glob.svg" alt="Dependency Status"></a> <a href="https://david-dm.org/isaacs/node-glob#info=devDependencies"><img src="https://david-dm.org/isaacs/node-glob/dev-status.svg" alt="devDependency Status"></a> <a href="https://david-dm.org/isaacs/node-glob#info=optionalDependencies"><img src="https://david-dm.org/isaacs/node-glob/optional-status.svg" alt="optionalDependency Status"></a></p>
<h1 id="Glob">Glob</h1><p>Match files using the patterns the shell uses, like stars and stuff.</p>
<p>This is a glob implementation in JavaScript.  It uses the <code>minimatch</code><br>library to do its matching.</p>
<p><img src="oh-my-glob.gif" alt=""></p>
<h2 id="Usage">Usage</h2><pre><code class="javascript"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">"glob"</span>)

<span class="comment">// options is optional</span>
glob(<span class="string">"**/*.js"</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>{
  <span class="comment">// files is an array of filenames.</span>
  <span class="comment">// If the `nonull` option is set, and nothing</span>
  <span class="comment">// was found, then files is ["**/*.js"]</span>
  <span class="comment">// er is an error object or null.</span>
})
</code></pre>
<h2 id="Glob_Primer">Glob Primer</h2><p>“Globs” are the patterns you type when you do stuff like <code>ls *.js</code> on<br>the command line, or put <code>build/*</code> in a <code>.gitignore</code> file.</p>
<p>Before parsing the path part patterns, braced sections are expanded<br>into a set.  Braced sections start with <code>{</code> and end with <code>}</code>, with any<br>number of comma-delimited sections within.  Braced sections may contain<br>slash characters, so <code>a{/b/c,bcd}</code> would expand into <code>a/b/c</code> and <code>abcd</code>.</p>
<p>The following characters have special magic meaning when used in a<br>path portion:</p>
<ul>
<li><code>*</code> Matches 0 or more characters in a single path portion</li>
<li><code>?</code> Matches 1 character</li>
<li><code>[...]</code> Matches a range of characters, similar to a RegExp range.<br>If the first character of the range is <code>!</code> or <code>^</code> then it matches<br>any character not in the range.</li>
<li><code>!(pattern|pattern|pattern)</code> Matches anything that does not match<br>any of the patterns provided.</li>
<li><code>?(pattern|pattern|pattern)</code> Matches zero or one occurrence of the<br>patterns provided.</li>
<li><code>+(pattern|pattern|pattern)</code> Matches one or more occurrences of the<br>patterns provided.</li>
<li><code>*(a|b|c)</code> Matches zero or more occurrences of the patterns provided</li>
<li><code>@(pattern|pat*|pat?erN)</code> Matches exactly one of the patterns<br>provided</li>
<li><code>**</code> If a “globstar” is alone in a path portion, then it matches<br>zero or more directories and subdirectories searching for matches.<br>It does not crawl symlinked directories.</li>
</ul>
<h3 id="Dots">Dots</h3><p>If a file or directory path portion has a <code>.</code> as the first character,<br>then it will not match any glob pattern unless that pattern’s<br>corresponding path part also has a <code>.</code> as its first character.</p>
<p>For example, the pattern <code>a/.*/c</code> would match the file at <code>a/.b/c</code>.<br>However the pattern <code>a/*/c</code> would not, because <code>*</code> does not start with<br>a dot character.</p>
<p>You can make glob treat dots as normal characters by setting<br><code>dot:true</code> in the options.</p>
<h3 id="Basename_Matching">Basename Matching</h3><p>If you set <code>matchBase:true</code> in the options, and the pattern has no<br>slashes in it, then it will seek for any file anywhere in the tree<br>with a matching basename.  For example, <code>*.js</code> would match<br><code>test/simple/basic.js</code>.</p>
<h3 id="Negation">Negation</h3><p>The intent for negation would be for a pattern starting with <code>!</code> to<br>match everything that <em>doesn’t</em> match the supplied pattern.  However,<br>the implementation is weird, and for the time being, this should be<br>avoided.  The behavior will change or be deprecated in version 5.</p>
<h3 id="Empty_Sets">Empty Sets</h3><p>If no matching files are found, then an empty array is returned.  This<br>differs from the shell, where the pattern itself is returned.  For<br>example:</p>
<pre><code>$ echo a<span class="keyword">*</span>s<span class="keyword">*</span>d<span class="keyword">*</span>f
a<span class="keyword">*</span>s<span class="keyword">*</span>d<span class="keyword">*</span>f
</code></pre><p>To get the bash-style behavior, set the <code>nonull:true</code> in the options.</p>
<h3 id="See_Also:">See Also:</h3><ul>
<li><code>man sh</code></li>
<li><code>man bash</code> (Search for “Pattern Matching”)</li>
<li><code>man 3 fnmatch</code></li>
<li><code>man 5 gitignore</code></li>
<li><a href="https://github.com/isaacs/minimatch">minimatch documentation</a></li>
</ul>
<h2 id="glob-hasMagic(pattern,_[options])">glob.hasMagic(pattern, [options])</h2><p>Returns <code>true</code> if there are any special characters in the pattern, and<br><code>false</code> otherwise.</p>
<p>Note that the options affect the results.  If <code>noext:true</code> is set in<br>the options object, then <code>+(a|b)</code> will not be considered a magic<br>pattern.  If the pattern has a brace expansion, like <code>a/{b/c,x/y}</code><br>then that is considered magical, unless <code>nobrace:true</code> is set in the<br>options.</p>
<h2 id="glob(pattern,_[options],_cb)">glob(pattern, [options], cb)</h2><ul>
<li><code>pattern</code> {String} Pattern to be matched</li>
<li><code>options</code> {Object}</li>
<li><code>cb</code> {Function}<ul>
<li><code>err</code> {Error | null}</li>
<li><code>matches</code> {Array<String>} filenames found matching the pattern</li>
</ul>
</li>
</ul>
<p>Perform an asynchronous glob search.</p>
<h2 id="glob-sync(pattern,_[options])">glob.sync(pattern, [options])</h2><ul>
<li><code>pattern</code> {String} Pattern to be matched</li>
<li><code>options</code> {Object}</li>
<li>return: {Array<String>} filenames found matching the pattern</li>
</ul>
<p>Perform a synchronous glob search.</p>
<h2 id="Class:_glob-Glob">Class: glob.Glob</h2><p>Create a Glob object by instantiating the <code>glob.Glob</code> class.</p>
<pre><code class="javascript"><span class="keyword">var</span> Glob = <span class="built_in">require</span>(<span class="string">"glob"</span>).Glob
<span class="keyword">var</span> mg = <span class="keyword">new</span> Glob(pattern, options, cb)
</code></pre>
<p>It’s an EventEmitter, and starts walking the filesystem to find matches<br>immediately.</p>
<h3 id="new_glob-Glob(pattern,_[options],_[cb])">new glob.Glob(pattern, [options], [cb])</h3><ul>
<li><code>pattern</code> {String} pattern to search for</li>
<li><code>options</code> {Object}</li>
<li><code>cb</code> {Function} Called when an error occurs, or matches are found<ul>
<li><code>err</code> {Error | null}</li>
<li><code>matches</code> {Array<String>} filenames found matching the pattern</li>
</ul>
</li>
</ul>
<p>Note that if the <code>sync</code> flag is set in the options, then matches will<br>be immediately available on the <code>g.found</code> member.</p>
<h3 id="Properties">Properties</h3><ul>
<li><code>minimatch</code> The minimatch object that the glob uses.</li>
<li><code>options</code> The options object passed in.</li>
<li><code>aborted</code> Boolean which is set to true when calling <code>abort()</code>.  There<br>is no way at this time to continue a glob search after aborting, but<br>you can re-use the statCache to avoid having to duplicate syscalls.</li>
<li><code>statCache</code> Collection of all the stat results the glob search<br>performed.</li>
<li><code>cache</code> Convenience object.  Each field has the following possible<br>values:<ul>
<li><code>false</code> - Path does not exist</li>
<li><code>true</code> - Path exists</li>
<li><code>&#39;DIR&#39;</code> - Path exists, and is not a directory</li>
<li><code>&#39;FILE&#39;</code> - Path exists, and is a directory</li>
<li><code>[file, entries, ...]</code> - Path exists, is a directory, and the<br>array value is the results of <code>fs.readdir</code></li>
</ul>
</li>
<li><code>statCache</code> Cache of <code>fs.stat</code> results, to prevent statting the same<br>path multiple times.</li>
<li><code>symlinks</code> A record of which paths are symbolic links, which is<br>relevant in resolving <code>**</code> patterns.</li>
</ul>
<h3 id="Events">Events</h3><ul>
<li><code>end</code> When the matching is finished, this is emitted with all the<br>matches found.  If the <code>nonull</code> option is set, and no match was found,<br>then the <code>matches</code> list contains the original pattern.  The matches<br>are sorted, unless the <code>nosort</code> flag is set.</li>
<li><code>match</code> Every time a match is found, this is emitted with the matched.</li>
<li><code>error</code> Emitted when an unexpected error is encountered, or whenever<br>any fs error occurs if <code>options.strict</code> is set.</li>
<li><code>abort</code> When <code>abort()</code> is called, this event is raised.</li>
</ul>
<h3 id="Methods">Methods</h3><ul>
<li><code>pause</code> Temporarily stop the search</li>
<li><code>resume</code> Resume the search</li>
<li><code>abort</code> Stop the search forever</li>
</ul>
<h3 id="Options">Options</h3><p>All the options that can be passed to Minimatch can also be passed to<br>Glob to change pattern matching behavior.  Also, some have been added,<br>or have glob-specific ramifications.</p>
<p>All options are false by default, unless otherwise noted.</p>
<p>All options are added to the Glob object, as well.</p>
<p>If you are running many <code>glob</code> operations, you can pass a Glob object<br>as the <code>options</code> argument to a subsequent operation to shortcut some<br><code>stat</code> and <code>readdir</code> calls.  At the very least, you may pass in shared<br><code>symlinks</code>, <code>statCache</code>, and <code>cache</code> options, so that parallel glob<br>operations will be sped up by sharing information about the<br>filesystem.</p>
<ul>
<li><code>cwd</code> The current working directory in which to search.  Defaults<br>to <code>process.cwd()</code>.</li>
<li><code>root</code> The place where patterns starting with <code>/</code> will be mounted<br>onto.  Defaults to <code>path.resolve(options.cwd, &quot;/&quot;)</code> (<code>/</code> on Unix<br>systems, and <code>C:\</code> or some such on Windows.)</li>
<li><code>dot</code> Include <code>.dot</code> files in normal matches and <code>globstar</code> matches.<br>Note that an explicit dot in a portion of the pattern will always<br>match dot files.</li>
<li><code>nomount</code> By default, a pattern starting with a forward-slash will be<br>“mounted” onto the root setting, so that a valid filesystem path is<br>returned.  Set this flag to disable that behavior.</li>
<li><code>mark</code> Add a <code>/</code> character to directory matches.  Note that this<br>requires additional stat calls.</li>
<li><code>nosort</code> Don’t sort the results.</li>
<li><code>stat</code> Set to true to stat <em>all</em> results.  This reduces performance<br>somewhat, and is completely unnecessary, unless <code>readdir</code> is presumed<br>to be an untrustworthy indicator of file existence.</li>
<li><code>silent</code> When an unusual error is encountered when attempting to<br>read a directory, a warning will be printed to stderr.  Set the<br><code>silent</code> option to true to suppress these warnings.</li>
<li><code>strict</code> When an unusual error is encountered when attempting to<br>read a directory, the process will just continue on in search of<br>other matches.  Set the <code>strict</code> option to raise an error in these<br>cases.</li>
<li><code>cache</code> See <code>cache</code> property above.  Pass in a previously generated<br>cache object to save some fs calls.</li>
<li><code>statCache</code> A cache of results of filesystem information, to prevent<br>unnecessary stat calls.  While it should not normally be necessary<br>to set this, you may pass the statCache from one glob() call to the<br>options object of another, if you know that the filesystem will not<br>change between calls.  (See “Race Conditions” below.)</li>
<li><code>symlinks</code> A cache of known symbolic links.  You may pass in a<br>previously generated <code>symlinks</code> object to save <code>lstat</code> calls when<br>resolving <code>**</code> matches.</li>
<li><code>sync</code> Perform a synchronous glob search.</li>
<li><code>nounique</code> In some cases, brace-expanded patterns can result in the<br>same file showing up multiple times in the result set.  By default,<br>this implementation prevents duplicates in the result set.  Set this<br>flag to disable that behavior.</li>
<li><code>nonull</code> Set to never return an empty set, instead returning a set<br>containing the pattern itself.  This is the default in glob(3).</li>
<li><code>debug</code> Set to enable debug logging in minimatch and glob.</li>
<li><code>nobrace</code> Do not expand <code>{a,b}</code> and <code>{1..3}</code> brace sets.</li>
<li><code>noglobstar</code> Do not match <code>**</code> against multiple filenames.  (Ie,<br>treat it as a normal <code>*</code> instead.)</li>
<li><code>noext</code> Do not match <code>+(a|b)</code> “extglob” patterns.</li>
<li><code>nocase</code> Perform a case-insensitive match.  Note: on<br>case-insensitive filesystems, non-magic patterns will match by<br>default, since <code>stat</code> and <code>readdir</code> will not raise errors.</li>
<li><code>matchBase</code> Perform a basename-only match if the pattern does not<br>contain any slash characters.  That is, <code>*.js</code> would be treated as<br>equivalent to <code>**/*.js</code>, matching all js files in all directories.</li>
<li><code>nonegate</code> Suppress <code>negate</code> behavior.  (See below.)</li>
<li><code>nocomment</code> Suppress <code>comment</code> behavior.  (See below.)</li>
<li><code>nonull</code> Return the pattern when no matches are found.</li>
<li><code>nodir</code> Do not match directories, only files.</li>
</ul>
<h2 id="Comparisons_to_other_fnmatch/glob_implementations">Comparisons to other fnmatch/glob implementations</h2><p>While strict compliance with the existing standards is a worthwhile<br>goal, some discrepancies exist between node-glob and other<br>implementations, and are intentional.</p>
<p>If the pattern starts with a <code>!</code> character, then it is negated.  Set the<br><code>nonegate</code> flag to suppress this behavior, and treat leading <code>!</code><br>characters normally.  This is perhaps relevant if you wish to start the<br>pattern with a negative extglob pattern like <code>!(a|B)</code>.  Multiple <code>!</code><br>characters at the start of a pattern will negate the pattern multiple<br>times.</p>
<p>If a pattern starts with <code>#</code>, then it is treated as a comment, and<br>will not match anything.  Use <code>\#</code> to match a literal <code>#</code> at the<br>start of a line, or set the <code>nocomment</code> flag to suppress this behavior.</p>
<p>The double-star character <code>**</code> is supported by default, unless the<br><code>noglobstar</code> flag is set.  This is supported in the manner of bsdglob<br>and bash 4.3, where <code>**</code> only has special significance if it is the only<br>thing in a path part.  That is, <code>a/**/b</code> will match <code>a/x/y/b</code>, but<br><code>a/**b</code> will not.</p>
<p>Note that symlinked directories are not crawled as part of a <code>**</code>,<br>though their contents may match against subsequent portions of the<br>pattern.  This prevents infinite loops and duplicates and the like.</p>
<p>If an escaped pattern has no matches, and the <code>nonull</code> flag is set,<br>then glob returns the pattern as-provided, rather than<br>interpreting the character escapes.  For example,<br><code>glob.match([], &quot;\\*a\\?&quot;)</code> will return <code>&quot;\\*a\\?&quot;</code> rather than<br><code>&quot;*a?&quot;</code>.  This is akin to setting the <code>nullglob</code> option in bash, except<br>that it does not resolve escaped pattern characters.</p>
<p>If brace expansion is not disabled, then it is performed before any<br>other interpretation of the glob pattern.  Thus, a pattern like<br><code>+(a|{b),c)}</code>, which would not be valid in bash or zsh, is expanded<br><strong>first</strong> into the set of <code>+(a|b)</code> and <code>+(a|c)</code>, and those patterns are<br>checked for validity.  Since those two are valid, matching proceeds.</p>
<h2 id="Windows">Windows</h2><p><strong>Please only use forward-slashes in glob expressions.</strong></p>
<p>Though windows uses either <code>/</code> or <code>\</code> as its path separator, only <code>/</code><br>characters are used by this glob implementation.  You must use<br>forward-slashes <strong>only</strong> in glob expressions.  Back-slashes will always<br>be interpreted as escape characters, not path separators.</p>
<p>Results from absolute patterns such as <code>/foo/*</code> are mounted onto the<br>root setting using <code>path.join</code>.  On windows, this will by default result<br>in <code>/foo/*</code> matching <code>C:\foo\bar.txt</code>.</p>
<h2 id="Race_Conditions">Race Conditions</h2><p>Glob searching, by its very nature, is susceptible to race conditions,<br>since it relies on directory walking and such.</p>
<p>As a result, it is possible that a file that exists when glob looks for<br>it may have been deleted or modified by the time it returns the result.</p>
<p>As part of its internal implementation, this program caches all stat<br>and readdir calls that it makes, in order to cut down on system<br>overhead.  However, this also makes it even more susceptible to races,<br>especially if the cache or statCache objects are reused between glob<br>calls.</p>
<p>Users are thus advised not to use a glob result as a guarantee of<br>filesystem state in the face of rapid changes.  For the vast majority<br>of operations, this is never a problem.</p>
<h2 id="Contributing">Contributing</h2><p>Any change to behavior (including bugfixes) must come with a test.</p>
<p>Patches that fail tests or reduce performance will be rejected.</p>
<pre><code><span class="comment"># to run tests</span>
<span class="built_in">npm</span> test

<span class="comment"># to re-generate test fixtures</span>
<span class="built_in">npm</span> run test-regen

<span class="comment"># to benchmark against bash/zsh</span>
<span class="built_in">npm</span> run bench

<span class="comment"># to profile javascript</span>
<span class="built_in">npm</span> run prof
</code></pre>