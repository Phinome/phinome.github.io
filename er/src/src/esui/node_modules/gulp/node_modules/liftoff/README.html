<p align="center"><br>  <a href="http://liftoffjs.com"><br>    <img height="100" width="297" src="https://raw.githubusercontent.com/tkellen/js-liftoff/master/artwork/liftoff.png"/><br>  </a><br></p>

<h1 id="liftoff">liftoff <a href="http://travis-ci.org/tkellen/js-liftoff"><img src="https://secure.travis-ci.org/tkellen/js-liftoff.png" alt="Build Status"></a> <a href="https://ci.appveyor.com/project/tkellen/js-liftoff/branch/master"><img src="https://ci.appveyor.com/api/projects/status/5a6w8xuq8ed1ilc4/branch/master?svg=true" alt="Build status"></a></h1><blockquote>
<p>Launch your command line tool with ease.</p>
</blockquote>
<p><a href="https://nodei.co/npm/liftoff/"><img src="https://nodei.co/npm/liftoff.png" alt="NPM"></a></p>
<h2 id="What_is_it?">What is it?</h2><p><a href="http://weblog.bocoup.com/building-command-line-tools-in-node-with-liftoff/">See this blog post</a>, <a href="http://github.com/tkellen/node-hacker">check out this proof of concept</a>, or read on.</p>
<p>Say you’re writing a CLI tool.  Let’s call it <a href="http://github.com/tkellen/node-hacker">hacker</a>.  You want to configure it using a <code>Hackerfile</code>.  This is node, so you install <code>hacker</code> locally for each project you use it in.  But, in order to get the <code>hacker</code> command in your PATH, you also install it globally.</p>
<p>Now, when you run <code>hacker</code>, you want to configure what it does using the <code>Hackerfile</code> in your current directory, and you want it to execute using the local installation of your tool.  Also, it’d be nice if the <code>hacker</code> command was smart enough to traverse up your folders until it finds a <code>Hackerfile</code>&mdash;for those times when you’re not in the root directory of your project.  Heck, you might even want to launch <code>hacker</code> from a folder outside of your project by manually specifying a working directory.  Liftoff manages this for you.</p>
<p>So, everything is working great.  Now you can find your local <code>hacker</code> and <code>Hackerfile</code> with ease.  Unfortunately, it turns out you’ve authored your <code>Hackerfile</code> in coffee-script, or some other JS variant.  In order to support <em>that</em>, you have to load the compiler for it, and then register the extension for it with node.  Good news, Liftoff can do that, and a whole lot more, too.</p>
<h2 id="API">API</h2><h3 id="constructor(opts)">constructor(opts)</h3><p>Create an instance of Liftoff to invoke your application.</p>
<p>An example utilizing all options:</p>
<pre><code class="js"><span class="keyword">const</span> Hacker = <span class="keyword">new</span> Liftoff({
  name: <span class="string">'hacker'</span>,
  processTitle: <span class="string">'hacker'</span>,
  moduleName: <span class="string">'hacker'</span>,
  configName: <span class="string">'hackerfile'</span>,
  extensions: {
    <span class="string">'.js'</span>: <span class="literal">null</span>,
    <span class="string">'.json'</span>: <span class="literal">null</span>,
    <span class="string">'.coffee'</span>: <span class="string">'coffee-script/register'</span>
  },
  v8flags: [<span class="string">'--harmony'</span>] <span class="comment">// or v8flags: require('v8flags');</span>
});
</code></pre>
<h4 id="opts-name">opts.name</h4><p>Sugar for setting <code>processTitle</code>, <code>moduleName</code>, <code>configName</code> automatically.</p>
<p>Type: <code>String</code><br>Default: <code>null</code></p>
<p>These are equivalent:</p>
<pre><code class="js"><span class="keyword">const</span> Hacker = Liftoff({
  processTitle: <span class="string">'hacker'</span>,
  moduleName: <span class="string">'hacker'</span>,
  configName: <span class="string">'hackerfile'</span>
});
</code></pre>
<pre><code class="js"><span class="keyword">const</span> Hacker = Liftoff({name:<span class="string">'hacker'</span>});
</code></pre>
<h4 id="opts-moduleName">opts.moduleName</h4><p>Sets which module your application expects to find locally when being run.</p>
<p>Type: <code>String</code><br>Default: <code>null</code></p>
<h4 id="opts-configName">opts.configName</h4><p>Sets the name of the configuration file Liftoff will attempt to find.  Case-insensitive.</p>
<p>Type: <code>String</code><br>Default: <code>null</code></p>
<h4 id="opts-extensions">opts.extensions</h4><p>Set extensions to include when searching for a configuration file.  If an external module is needed to load a given extension (e.g. <code>.coffee</code>), the module name should be specified as the value for the key.</p>
<p>Type: <code>Object</code><br>Default: <code>{&quot;.js&quot;:null,&quot;.json&quot;:null}</code></p>
<p><strong>Examples:</strong></p>
<p>In this example Liftoff will look for <code>myappfile{.js,.json,.coffee}</code>.  If a config with the extension <code>.coffee</code> is found, Liftoff will try to require <code>coffee-script/require</code> from the current working directory.</p>
<pre><code class="js"><span class="keyword">const</span> MyApp = <span class="keyword">new</span> Liftoff({
  name: <span class="string">'myapp'</span>
  extensions: {
    <span class="string">'.js'</span>: <span class="literal">null</span>,
    <span class="string">'.json'</span>: <span class="literal">null</span>,
    <span class="string">'.coffee'</span>: <span class="string">'coffee-script/register'</span>
  }
});
</code></pre>
<p>In this example, Liftoff will look for <code>.myapp{rc}</code>.</p>
<pre><code class="js"><span class="keyword">const</span> MyApp = <span class="keyword">new</span> Liftoff({
  name: <span class="string">'myapp'</span>,
  configName: <span class="string">'.myapp'</span>,
  extensions: {
    <span class="string">'rc'</span>: <span class="literal">null</span>
  }
});
</code></pre>
<p>In this example, Liftoff will automatically attempt to load the correct module for any javascript variant supported by <a href="https://github.com/tkellen/node-interpret">node-interpret</a> (as long as it does not require a register method).</p>
<pre><code class="js"><span class="keyword">const</span> MyApp = <span class="keyword">new</span> Liftoff({
  name: <span class="string">'myapp'</span>,
  extensions: <span class="built_in">require</span>(<span class="string">'interpret'</span>).jsVariants
});
</code></pre>
<h4 id="opts-v8flags">opts.v8flags</h4><p>Any flag specified here will be applied to node, not your program.  Useful for supporting invocations like <code>myapp --harmony command</code>, where <code>--harmony</code> should be passed to node, not your program. This functionality is implemented using <a href="http://github.com/tkellen/node-flagged-respawn">flagged-respawn</a>. To support all v8flags, see <a href="https://github.com/tkellen/node-v8flags">node-v8flags</a>.</p>
<p>Type: <code>Array|Function</code><br>Default: <code>null</code></p>
<p>If this method is a function, it should take a node-style callback that yields an array of flags.</p>
<h4 id="opts-processTitle">opts.processTitle</h4><p>Sets what the <a href="http://nodejs.org/api/process.html#process_process_title">process title</a> will be.</p>
<p>Type: <code>String</code><br>Default: <code>null</code></p>
<h4 id="opts-completions(type)">opts.completions(type)</h4><p>A method to handle bash/zsh/whatever completions.</p>
<p>Type: <code>Function</code><br>Default: <code>null</code></p>
<h2 id="launch(opts,_callback(env))">launch(opts, callback(env))</h2><p>Launches your application with provided options, builds an environment, and invokes your callback, passing the calculated environment as the first argument.</p>
<h5 id="Example_Configuration_w/_Options_Parsing:">Example Configuration w/ Options Parsing:</h5><pre><code class="js"><span class="keyword">const</span> Liftoff = <span class="built_in">require</span>(<span class="string">'liftoff'</span>);
<span class="keyword">const</span> MyApp = <span class="keyword">new</span> Liftoff({name:<span class="string">'myapp'</span>});
<span class="keyword">const</span> argv = <span class="built_in">require</span>(<span class="string">'minimist'</span>)(process.argv.slice(<span class="number">2</span>));
<span class="keyword">const</span> invoke = <span class="function"><span class="keyword">function</span> (<span class="params">env</span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">'my environment is:'</span>, env);
  <span class="built_in">console</span>.log(<span class="string">'my cli options are:'</span>, argv);
  <span class="built_in">console</span>.log(<span class="string">'my liftoff config is:'</span>, <span class="keyword">this</span>);
};
MyApp.launch({
  cwd: argv.cwd,
  configPath: argv.myappfile,
  <span class="built_in">require</span>: argv.require,
  completion: argv.completion
}, invoke);
</code></pre>
<h4 id="opts-cwd">opts.cwd</h4><p>Change the current working directory for this launch. Relative paths are calculated against <code>process.cwd()</code>.</p>
<p>Type: <code>String</code><br>Default: <code>process.cwd()</code></p>
<p><strong>Example Configuration:</strong></p>
<pre><code class="js"><span class="keyword">const</span> argv = <span class="built_in">require</span>(<span class="string">'minimist'</span>)(process.argv.slice(<span class="number">2</span>));
MyApp.launch({
  cwd: argv.cwd
}, invoke);
</code></pre>
<p><strong>Matching CLI Invocation:</strong></p>
<pre><code>myapp <span class="comment">--cwd ../</span>
</code></pre><h4 id="opts-configPath">opts.configPath</h4><p>Don’t search for a config, use the one provided. <strong>Note:</strong> Liftoff will assume the current working directory is the directory containing the config file unless an alternate location is explicitly specified using <code>cwd</code>.</p>
<p>Type: <code>String</code><br>Default: <code>null</code></p>
<p><strong>Example Configuration:</strong></p>
<pre><code class="js"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'minimist'</span>)(process.argv.slice(<span class="number">2</span>));
MyApp.launch({
  configPath: argv.myappfile
}, invoke);
</code></pre>
<p><strong>Matching CLI Invocation:</strong></p>
<pre><code>myapp --myappfile <span class="regexp">/var/</span>www<span class="regexp">/project/My</span>appfile.js
</code></pre><p><strong>Examples using <code>cwd</code> and <code>configPath</code> together:</strong></p>
<p>These are functionally identical:</p>
<pre><code>myapp --myappfile <span class="regexp">/var/</span>www<span class="regexp">/project/My</span>appfile.js
myapp --cwd <span class="regexp">/var/</span>www<span class="regexp">/project</span>
</code></pre><p>These can run myapp from a shared directory as though it were located in another project:</p>
<pre><code>myapp --myappfile <span class="regexp">/Users/</span>name<span class="regexp">/Myappfile.js --cwd /</span>var<span class="regexp">/www/</span>project1
myapp --myappfile <span class="regexp">/Users/</span>name<span class="regexp">/Myappfile.js --cwd /</span>var<span class="regexp">/www/</span>project2
</code></pre><h4 id="opts-require">opts.require</h4><p>A string or array of modules to attempt requiring from the local working directory before invoking the launch callback.</p>
<p>Type: <code>String|Array</code><br>Default: <code>null</code></p>
<p><strong>Example Configuration:</strong></p>
<pre><code class="js"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'minimist'</span>)(process.argv.slice(<span class="number">2</span>));
MyApp.launch({
  <span class="built_in">require</span>: argv.require
}, invoke);
</code></pre>
<p><strong>Matching CLI Invocation:</strong></p>
<pre><code class="js">myapp --<span class="built_in">require</span> coffee-script/register
</code></pre>
<h4 id="callback(env)">callback(env)</h4><p>A function to start your application.  When invoked, <code>this</code> will be your instance of Liftoff. The <code>env</code> param will contain the following keys:</p>
<ul>
<li><code>cwd</code>: the current working directory</li>
<li><code>require</code>: an array of modules that liftoff tried to pre-load</li>
<li><code>configNameSearch</code>: the config files searched for</li>
<li><code>configPath</code>: the full path to your configuration file (if found)</li>
<li><code>configBase</code>: the base directory of your configuration file (if found)</li>
<li><code>modulePath</code>: the full path to the local module your project relies on (if found)</li>
<li><code>modulePackage</code>: the contents of the local module’s package.json (if found)</li>
</ul>
<h3 id="events">events</h3><h4 id="require(name,_module)">require(name, module)</h4><p>Emitted when a module is pre-loaded.</p>
<pre><code class="js"><span class="keyword">var</span> Hacker = <span class="keyword">new</span> Liftoff({name:<span class="string">'hacker'</span>});
Hacker.on(<span class="string">'require'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name, module</span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">'Requiring external module: '</span>+name+<span class="string">'...'</span>);
  <span class="comment">// automatically register coffee-script extensions</span>
  <span class="keyword">if</span> (name === <span class="string">'coffee-script'</span>) {
    <span class="built_in">module</span>.register();
  }
});
</code></pre>
<h4 id="requireFail(name,_err)">requireFail(name, err)</h4><p>Emitted when a requested module cannot be preloaded.</p>
<pre><code class="js"><span class="keyword">var</span> Hacker = <span class="keyword">new</span> Liftoff({name:<span class="string">'hacker'</span>});
Hacker.on(<span class="string">'requireFail'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name, err</span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">'Unable to load:'</span>, name, err);
});
</code></pre>
<h4 id="respawn(flags,_child)">respawn(flags, child)</h4><p>Emitted when Liftoff re-spawns your process (when a <a href="#optsnodeflags"><code>nodeFlag</code></a> is detected).</p>
<pre><code class="js"><span class="keyword">var</span> Hacker = <span class="keyword">new</span> Liftoff({
  name: <span class="string">'hacker'</span>,
  nodeFlags: [<span class="string">'--harmony'</span>]
});
Hacker.on(<span class="string">'respawn'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">flags, child</span>) </span>{
  <span class="built_in">console</span>.log(<span class="string">'Detected node flags:'</span>, flags);
  <span class="built_in">console</span>.log(<span class="string">'Respawned to PID:'</span>, child.pid);
});
</code></pre>
<p>Event will be triggered for this command:<br><code>hacker --harmony commmand</code></p>
<h2 id="Examples">Examples</h2><p>Check out how <a href="https://github.com/gulpjs/gulp/blob/master/bin/gulp.js">gulp</a> uses Liftoff.</p>
<p>For a bare-bones example, try <a href="https://github.com/tkellen/node-hacker/blob/master/bin/hacker.js">the hacker project</a>.</p>
<p>To try the example, do the following:</p>
<ol>
<li>Install the sample project <code>hacker</code> with <code>npm install -g hacker</code>.</li>
<li>Make a <code>Hackerfile.js</code> with some arbitrary javascript it.</li>
<li>Install hacker next to it with <code>npm install hacker</code>.</li>
<li>Run <code>hacker</code> while in the same parent folder.</li>
</ol>
