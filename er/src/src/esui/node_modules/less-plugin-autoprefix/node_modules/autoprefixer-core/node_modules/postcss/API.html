<h1 id="PostCSS_API">PostCSS API</h1><ul>
<li><a href="#postcss-function">postcss function</a></li>
<li><a href="#postcss-class">PostCSS class</a></li>
<li><a href="#result-class">Result class</a></li>
<li><a href="#vendor-module">Vendor module</a></li>
<li><a href="#list-module">List module</a></li>
<li><a href="#input-class">Input class</a></li>
<li><a href="#nodes-common-methods">Nodes common methods</a></li>
<li><a href="#containers-common-methods">Containers common methods</a></li>
<li><a href="#root-node">Root node</a></li>
<li><a href="#atrule-node">AtRule node</a></li>
<li><a href="#rule-node">Rule node</a></li>
<li><a href="#declaration-node">Declaration node</a></li>
<li><a href="#comment-node">Comment node</a></li>
</ul>
<h2 id="postcss_function"><code>postcss</code> function</h2><p>The <code>postcss</code> function is the main entry point for PostCSS.</p>
<pre><code class="js"><span class="keyword">var</span> postcss = <span class="built_in">require</span>(<span class="string">'postcss'</span>);
</code></pre>
<h3 id="postcss(plugins)"><code>postcss(plugins)</code></h3><p>Returns a new <code>PostCSS</code> instance that will apply <code>plugins</code><br>as CSS processors.</p>
<pre><code class="js">postcss([autoprefixer, cssnext, cssgrace]).process(css).css;
</code></pre>
<p>You can also set plugins with the <a href="#puseplugin"><code>PostCSS#use</code></a> method.</p>
<p>See <a href="#puseplugin"><code>PostCSS#use</code></a> below for details about plugin formats.</p>
<h3 id="postcss-parse(css,_opts)"><code>postcss.parse(css, opts)</code></h3><p>Parses source <code>css</code> and returns a new <code>Root</code> node, which contains<br>the source CSS nodes.</p>
<pre><code class="js"><span class="comment">// Simple CSS concatenation with source map support</span>
<span class="keyword">var</span> root1 = postcss.parse(css1, { from: file1 });
<span class="keyword">var</span> root2 = postcss.parse(css2, { from: file2 });
root1.append(root2).toResult().css;
</code></pre>
<p>Options:</p>
<ul>
<li><code>from</code>: the path to the source CSS file. You should always set <code>from</code>,<br>because it is used in map generation and in syntax error messages.</li>
<li><code>safe</code>: enable <a href="https://github.com/postcss/postcss#safe-mode">Safe Mode</a>, in which PostCSS will try<br>to fix CSS syntax errors.</li>
<li><code>map</code>: an object of <a href="https://github.com/postcss/postcss#source-map">source map options</a>.<br>Only <code>map.prev</code> is used in <code>parse</code>.</li>
</ul>
<h3 id="postcss-root(props)"><code>postcss.root(props)</code></h3><p>Creates a new <a href="#root-node"><code>Root</code> node</a>.</p>
<pre><code class="js">postcss.root({ after: <span class="string">'\n'</span> }).toString() <span class="comment">//=&gt; "\n"</span>
</code></pre>
<h3 id="postcss-atRule(props)"><code>postcss.atRule(props)</code></h3><p>Creates a new <a href="#atrule-node"><code>AtRule</code> node</a>.</p>
<pre><code class="js">postcss.atRule({ name: <span class="string">'charset'</span> }).toString() <span class="comment">//=&gt; "@charset"</span>
</code></pre>
<h3 id="postcss-rule(props)"><code>postcss.rule(props)</code></h3><p>Creates a new <a href="#rule-node"><code>Rule</code> node</a>.</p>
<pre><code class="js">postcss.rule({ selector: <span class="string">'a'</span> }).toString() <span class="comment">//=&gt; "a {\n}"</span>
</code></pre>
<h3 id="postcss-decl(props)"><code>postcss.decl(props)</code></h3><p>Creates a new <a href="#declaration-node"><code>Declaration</code> node</a>.</p>
<pre><code class="js">postcss.decl({ prop: <span class="string">'color'</span>, value: <span class="string">'black'</span> }).toString() <span class="comment">//=&gt; "color: black"</span>
</code></pre>
<h3 id="postcss-comment(props)"><code>postcss.comment(props)</code></h3><p>Creates a new <a href="#comment-node"><code>Comment</code> node</a>.</p>
<pre><code class="js">postcss.comment({ text: <span class="string">'test'</span> }).toString() <span class="comment">//=&gt; "/* test */"</span>
</code></pre>
<h2 id="PostCSS_class"><code>PostCSS</code> class</h2><p>A <code>PostCSS</code> instance contains plugins to process CSS. You can create<br>one <code>PostCSS</code> instance, initialize its plugins, and then use that instance<br>on many CSS files.</p>
<pre><code class="js"><span class="keyword">var</span> processor = postcss([autoprefixer, cssnext, cssgrace]);
processor.process(css1).css;
processor.process(css2).css;
</code></pre>
<h3 id="p-use(plugin)"><code>p.use(plugin)</code></h3><p>Adds a plugin to be used as a CSS processor.</p>
<pre><code class="js"><span class="keyword">var</span> processor = postcss();
processor.use(autoprefixer).use(cssnext).use(cssgrace);
</code></pre>
<p>Plugins can also be added by passing them as arguments when creating<br>a <code>postcss</code> instance (cf. <a href="#postcssplugins"><code>postcss(plugins)</code></a>).</p>
<p>Plugins can come in three formats:</p>
<ol>
<li>A function. PostCSS will pass the function a <a href="#root-node"><code>Root</code> node</a><br>as the first argument.</li>
<li>An object with a <code>postcss</code> method. PostCSS will use that method<br>as described in #1.</li>
<li>Another <code>PostCSS</code> instance. PostCSS will copy plugins<br>from that instance to this one.</li>
</ol>
<p>Plugin functions should mutate the passed <code>Root</code> node and return nothing,<br>or return a new <code>Root</code> node.</p>
<pre><code class="js">processor.use(<span class="function"><span class="keyword">function</span> (<span class="params">css</span>) </span>{
    css.prepend({ name: <span class="string">'charset'</span>, params: <span class="string">'"UTF-8"'</span> });
});
processor.use(<span class="function"><span class="keyword">function</span> (<span class="params">css</span>) </span>{
    <span class="keyword">return</span> postcss.root();
});
</code></pre>
<h3 id="p-process(css,_opts)"><code>p.process(css, opts)</code></h3><p>This is the main method of PostCSS. It will parse the source CSS<br>and create a <a href="#root-node"><code>Root</code> node</a>; send this <code>Root</code> to each plugin successively,<br>for transformations; and then return a <code>Result</code> instance created<br>from the transformed <code>Root</code>.</p>
<pre><code class="js"><span class="keyword">var</span> result = processor.process(css, { from: <span class="string">'a.css'</span>, to: <span class="string">'a.out.css'</span> });
</code></pre>
<p>Input CSS formats are:</p>
<ul>
<li>A string of CSS.</li>
<li>A <code>Result</code> instance from another PostCSS processor. PostCSS will accept<br>the already parsed <code>Root</code> from it.</li>
<li>Any object with a <code>toString()</code> method — for example, a file stream.</li>
</ul>
<p>Options:</p>
<ul>
<li><code>from</code>: the path of the CSS source file. You should always set <code>from</code>,<br>because it is used in source map generation and syntax error messages.</li>
<li><code>to</code>: the path where you’ll put the output CSS file. You should always set<br><code>to</code> to generate correct source maps.</li>
<li><code>safe</code>: enable <a href="https://github.com/postcss/postcss#safe-mode">Safe Mode</a>, in which PostCSS will try<br>to fix CSS syntax errors.</li>
<li><code>map</code>: an object of <a href="https://github.com/postcss/postcss#source-map">source map options</a>.</li>
</ul>
<h2 id="Result_class"><code>Result</code> class</h2><p>Provides result of PostCSS transformations.</p>
<p>A <code>Result</code> instance is returned<br>by <a href="#pprocesscss-opts"><code>PostCSS#process(css, opts)</code></a> and <a href="#roottoresult-opts"><code>Root#toResult(opts)</code></a>.</p>
<pre><code class="js"><span class="keyword">var</span> result1 = postcss().process(css);
<span class="keyword">var</span> result2 = postcss.parse(css).toResult();
</code></pre>
<h3 id="result-root"><code>result.root</code></h3><p>The source <code>Root</code> instance.</p>
<pre><code class="js">root.toResult().root == root;
</code></pre>
<h3 id="result-opts"><code>result.opts</code></h3><p>Options from the <a href="#pprocesscss-opts"><code>PostCSS#process(css, opts)</code></a> or<br><a href="#roottoresult-opts"><code>Root#toResult(opts)</code></a> call that produced<br>this <code>Result</code> instance.</p>
<pre><code class="js">postcss().process(css, opts).opts == opts;
</code></pre>
<h3 id="result-css"><code>result.css</code></h3><p>A CSS string representing this <code>Result</code>’s ‘<code>Root</code> instance.</p>
<pre><code class="js">postcss().process(<span class="string">'a{}'</span>).css <span class="comment">//=&gt; "a{}"</span>
</code></pre>
<p>This property is generated <em>lazily</em>: <code>Root</code> is not stringified until<br>the first request for the <code>css</code> property (or the <a href="#resultmap"><code>result.map</code></a> property).<br>That initial request for <code>css</code> will also generate a source map.<br>Source map will inlined into CSS or assigned to the <a href="#resultmap"><code>result.map</code></a> property,<br>if user ask to save map to separated file.</p>
<h3 id="result-map"><code>result.map</code></h3><p>An instance of the <code>SourceMapGenerator</code> class from the <a href="https://github.com/mozilla/source-map"><code>source-map</code></a> library,<br>representing changes to the <code>Result</code>’s <code>Root</code> instance.</p>
<pre><code class="js">result.map.toJSON() <span class="comment">//=&gt; { version: 3, file: 'a.css', sources: ['a.css'], … }</span>
</code></pre>
<p>This property is generated <em>lazily</em>: the source map for <code>Root</code> is not generated<br>until the first request for the <code>map</code> property (or the <a href="#resultcss"><code>result.css</code></a> property).<br>That initial request will also stringify <code>Root</code> and assign the generated<br>CSS string to the <a href="#resultcss"><code>result.css</code></a> property.</p>
<p>Additionally, <em>this property will receive a value only if the user does not wan<br>an inline source map</em>. By default, PostCSS generates inline source maps,<br>written directly into the processed CSS; so by default the <code>map</code> property<br>will be empty.</p>
<p>An external source map will be generated — and assigned to <code>map</code> — only if the<br>user has set the <code>map.inline</code> option to <code>false</code>, or if PostCSS was passed<br>an external input source map.</p>
<pre><code class="js"><span class="keyword">if</span> ( result.map ) {
    fs.writeFileSync(to + <span class="string">'.map'</span>, result.map.toString());
}
</code></pre>
<h2 id="Vendor_module">Vendor module</h2><p>Contains helpers for working with vendor prefixes.</p>
<h3 id="vendor-prefix(string)"><code>vendor.prefix(string)</code></h3><p>Returns the vendor prefix extracted from an input string.</p>
<pre><code class="js">vendor.prefix(<span class="string">'-moz-tab-size'</span>) <span class="comment">//=&gt; '-moz-'</span>
</code></pre>
<h3 id="vendor-unprefixed(string)"><code>vendor.unprefixed(string)</code></h3><p>Returns the input string stripped of its vendor prefix.</p>
<pre><code class="js">vendor.unprefixed(<span class="string">'-moz-tab-size'</span>) <span class="comment">//=&gt; 'tab-size'</span>
</code></pre>
<h2 id="List_module">List module</h2><p>Contains helpers for safely splitting lists of CSS values, preserving parentheses<br>and quotes.</p>
<pre><code class="js"><span class="keyword">var</span> list = <span class="built_in">require</span>(<span class="string">'postcss/lib/list'</span>);
</code></pre>
<h3 id="list-space(string)"><code>list.space(string)</code></h3><p>Safely splits space-separated values (such as those for <code>background</code>,<br><code>border-radius</code>, and other shorthand properties).</p>
<pre><code class="js">list.space(<span class="string">'1px calc(10% + 1px)'</span>)
<span class="comment">//=&gt; ['1px', 'calc(10% + 1px)']</span>
</code></pre>
<h3 id="list-comma(string)"><code>list.comma(string)</code></h3><p>Safely splits comma-separated values (such as those<br>for <code>transition-*</code> and <code>background</code> properties).</p>
<pre><code class="js">list.comma(<span class="string">'black, linear-gradient(white, black)'</span>)
<span class="comment">//=&gt; ['black', 'linear-gradient(white, black)']</span>
</code></pre>
<h2 id="Input_class"><code>Input</code> class</h2><p>Represents the source CSS.</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(css, { from: file });
<span class="keyword">var</span> input = root.source.input;
</code></pre>
<h3 id="input-file"><code>input.file</code></h3><p>The absolute path to the CSS source file defined with<br>the <a href="#pprocesscss-opts"><code>from</code> option</a>.</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(css, { from: <span class="string">'a.css'</span> });
root.source.input.file <span class="comment">//=&gt; '/home/ai/a.css'</span>
</code></pre>
<h3 id="input-id"><code>input.id</code></h3><p>The unique ID of the CSS source. This is used if the user did not enter a <code>from</code><br>options so PostCSS does not know about a file path.</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(css);
root.source.input.file <span class="comment">//=&gt; undefined</span>
root.source.input.id   <span class="comment">//=&gt; &lt;input css 1&gt;</span>
</code></pre>
<h3 id="input-from"><code>input.from</code></h3><p>The CSS source identifier. Contains <a href="#inputfile"><code>input.file</code></a> if the user set the<br><a href="#pprocesscss-opts"><code>from</code> option</a>, or <a href="#inputid"><code>input.id</code></a> if she did not.</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(css, { from: <span class="string">'a.css'</span> });
root.source.input.from <span class="comment">//=&gt; '/home/ai/a.css'</span>

<span class="keyword">var</span> root  = postcss.parse(css);
root.source.input.from <span class="comment">//=&gt; &lt;input css 1&gt;</span>
</code></pre>
<h3 id="input-map"><code>input.map</code></h3><p>Represents the input source map passed from a compilation step before PostCSS<br>(for example, from the Sass compiler).</p>
<p><code>map.consumer()</code> returns an instance of the <code>SourceMapConsumer</code> class<br>from the <a href="https://github.com/mozilla/source-map"><code>source-map</code></a> library.</p>
<pre><code class="js">root.source.input.map.consumer().sources <span class="comment">//=&gt; ['a.sass']</span>
</code></pre>
<h3 id="input-origin(line,_column)"><code>input.origin(line, column)</code></h3><p>Reads the input source map and returns a symbol position in the input source<br>(for example, in a Sass file that was compiled to CSS before being passed<br>to PostCSS):</p>
<pre><code class="js">root.source.input.origin(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">//=&gt; { source: 'a.css', line: 3, column: 1 }</span>
</code></pre>
<h2 id="Nodes:_common_methods">Nodes: common methods</h2><p>All node classes have many common methods.</p>
<h3 id="node-type"><code>node.type</code></h3><p>Returns a string representing the node’s type.</p>
<p>Possible values are <code>root</code>, <code>atrule</code>, <code>rule</code>, <code>decl</code>, or <code>comment</code>.</p>
<pre><code class="js">postcss.decl({ prop: <span class="string">'color'</span>, value: <span class="string">'black'</span> }).type <span class="comment">//=&gt; 'decl'</span>
</code></pre>
<h3 id="node-parent"><code>node.parent</code></h3><p>Returns the node’s parent node.</p>
<pre><code class="js">root.nodes[<span class="number">0</span>].parent == root;
</code></pre>
<h3 id="node-source"><code>node.source</code></h3><p>Returns the input source of the node, with the following properties:</p>
<ul>
<li><code>node.source.input</code>: An <a href="#inputclass"><code>Input</code></a> instance.</li>
<li><code>node.source.start</code>: The starting position of the node’s source —<br>line and column.</li>
<li><code>node.source.end</code>: The ending position of the node’s source — line and column.</li>
</ul>
<pre><code class="js">decl.source.input.from <span class="comment">//=&gt; '/home/ai/a.sass'</span>
decl.source.start      <span class="comment">//=&gt; { line: 10, column: 2 }</span>
decl.source.end        <span class="comment">//=&gt; { line: 10, column: 12 }</span>
</code></pre>
<p>The property is used in source map generation.</p>
<p>If you create a node manually (for example, with <code>postcss.decl()</code>),<br>that node will not have a <code>source</code> property and will be absent<br>from the source map. For this reason, plugin developer should consider<br>cloning nodes to create new ones (in which case the new node’s source<br>will reference the original, cloned node) or setting the <code>source</code> property<br>manually.</p>
<pre><code class="js"><span class="comment">// Bad</span>
<span class="keyword">var</span> prefixed = postcss.decl({ prop: <span class="string">'-moz-'</span> + decl.prop, value: decl.value });

<span class="comment">// Good</span>
<span class="keyword">var</span> prefixed = decl.clone({ prop: <span class="string">'-moz-'</span> + decl.prop });
</code></pre>
<pre><code class="js"><span class="keyword">if</span> ( atrule.name == <span class="string">'add-link'</span> ) {
    <span class="keyword">var</span> rule = postcss.rule({ selector: <span class="string">'a'</span> }); <span class="comment">// Rule has no source</span>
    atrule.parent.insertBefore(atrule, rule);   <span class="comment">// We add it because of atrule</span>
    rule.source = atrule.source;                <span class="comment">// So we copy source from atrule</span>
}
</code></pre>
<h3 id="node-toString()"><code>node.toString()</code></h3><p>Returns a CSS string representing the node.</p>
<pre><code class="js">postcss.rule({ selector: <span class="string">'a'</span> }).toString() <span class="comment">//=&gt; 'a {}''</span>
</code></pre>
<h3 id="node-error(message)"><code>node.error(message)</code></h3><p>Returns a <code>CssSyntaxError</code> instance that presents the original position<br>of the node in the source, showing line and column numbers and also<br>a small excerpt to facilitate debugging.</p>
<p>It will use an input source map, if present, to get the original position<br>of the source, even from a previous compilation step<br>(for example, from Sass compilation).</p>
<p>This method produces very useful error messages.</p>
<pre><code class="js"><span class="keyword">if</span> ( !variables[name] ) {
    <span class="keyword">throw</span> decl.error(<span class="string">'Unknown variable '</span> + name);
    <span class="comment">// CssSyntaxError: a.sass:4:3: Unknown variable $black</span>
    <span class="comment">// a</span>
    <span class="comment">//   color: $black</span>
    <span class="comment">//   ^</span>
    <span class="comment">//   background: white</span>
}

<span class="keyword">if</span> ( oldSyntax.check(decl) ) {
    <span class="built_in">console</span>.warn( decl.error(<span class="string">'Old syntax for variables'</span>).message );
    <span class="comment">// a.sass:4:3: Old syntax for variables</span>
}
</code></pre>
<h3 id="node-next()_and_node-prev()"><code>node.next()</code> and <code>node.prev()</code></h3><p>Returns the next/previous child of the node’s parent; or returns <code>undefined</code><br>if the current node is the last/first child.</p>
<pre><code class="js"><span class="keyword">var</span> annotation = decl.prev();
<span class="keyword">if</span> ( annotation.type == <span class="string">'comment'</span> ) {
    readAnnotation( annotation.text );
}
</code></pre>
<h3 id="node-root()"><code>node.root()</code></h3><p>Returns the <code>Root</code> instance of the node’s tree.</p>
<pre><code class="js">root.nodes[<span class="number">0</span>].nodes[<span class="number">0</span>].root() == root
</code></pre>
<h3 id="node-removeSelf()"><code>node.removeSelf()</code></h3><p>Removes the node from its parent, and cleans the <code>parent</code> property in the node<br>and its children.</p>
<pre><code class="js"><span class="keyword">if</span> ( decl.prop.match(<span class="regexp">/^-webkit-/</span>) ) {
    decl.removeSelf();
}
</code></pre>
<h3 id="node-replaceWith(otherNode)"><code>node.replaceWith(otherNode)</code></h3><p>Inserts another node before the current node, and removes the current node.</p>
<pre><code class="js"><span class="keyword">if</span> ( atrule.name == <span class="string">'mixin'</span> ) {
    atrule.replaceWith(mixinRules[atrule.params]);
}
</code></pre>
<h3 id="node-clone(props)"><code>node.clone(props)</code></h3><p>Returns a clones of the node.</p>
<p>The resultant clone node and its (clone) children will have clean <code>parent</code><br>and code style properties. You can override properties in the clone node<br>by passing a <code>props</code> argument.</p>
<pre><code class="js"><span class="keyword">var</span> clonded = decl.clone({ prop: <span class="string">'-moz-'</span> + decl.prop });
cloned.before     <span class="comment">//=&gt; undefined</span>
cloned.parent     <span class="comment">//=&gt; undefined</span>
cloned.toString() <span class="comment">//=&gt; -moz-transform: scale(0)</span>
</code></pre>
<h3 id="node-cloneBefore(props)_and_node-cloneAfter(props)"><code>node.cloneBefore(props)</code> and <code>node.cloneAfter(props)</code></h3><p>Shortcuts to clone the node and insert the resultant clone node before/after<br>the current node.</p>
<pre><code class="js">decl.cloneBefore({ prop: <span class="string">'-moz-'</span> + decl.prop });
</code></pre>
<h3 id="node-moveTo(newParent)"><code>node.moveTo(newParent)</code></h3><p>Removes the node from its current parent and inserts it<br>at the end of <code>newParent</code>.</p>
<p>This will clean the <code>before</code> and <code>after</code> code style properties from the node,<br>and replace them with the indentation style of <code>newParent</code>. It will also clean<br>the <code>between</code> property if <code>newParent</code> is in another <code>Root</code>.</p>
<pre><code class="js">atrule.moveTo(atrule.parent.parent);
</code></pre>
<h3 id="node-moveBefore(otherNode)_and_node-moveAfter(otherNode)"><code>node.moveBefore(otherNode)</code> and <code>node.moveAfter(otherNode)</code></h3><p>Removes the node from its current parent and inserts it into a new parent<br>before/after <code>otherNode</code>.</p>
<p>This will also clean the node’s code style properties just<br>as <code>node.moveTo(newParent)</code> does.</p>
<h3 id="node-style(prop,_defaultType)"><code>node.style(prop, defaultType)</code></h3><p>Returns a code style property value. If the node is missing the code style<br>property (because the node was manually built or cloned), PostCSS will try<br>to autodetect the code style property by looking at other nodes in the tree.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a { background: white }'</span>);
root.nodes[<span class="number">0</span>].append({ prop: <span class="string">'color'</span>, value: <span class="string">'black'</span> });
root.nodes[<span class="number">0</span>].nodes[<span class="number">1</span>].style(<span class="string">'before'</span>) <span class="comment">//=&gt; ' '</span>
</code></pre>
<h2 id="Containers:_common_methods">Containers: common methods</h2><p>The <code>Root</code>, <code>AtRule</code>, and <code>Rule</code> container nodes have some common methods<br>to help work with their children.</p>
<p>Note that all containers can store <em>any</em> content. If you write a rule inside<br>a rule, PostCSS will parse it.</p>
<h3 id="container-nodes"><code>container.nodes</code></h3><p>An array containing the container’s children.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a { color: black }'</span>);
root.nodes.length           <span class="comment">//=&gt; 1</span>
root.nodes[<span class="number">0</span>].selector      <span class="comment">//=&gt; 'a'</span>
root.nodes[<span class="number">0</span>].nodes[<span class="number">0</span>].prop <span class="comment">//=&gt; 'color'</span>
</code></pre>
<h3 id="container-first"><code>container.first</code></h3><p>The container’s first child.</p>
<pre><code class="js">rule.first == rules.nodes[<span class="number">0</span>];
</code></pre>
<h3 id="container-last"><code>container.last</code></h3><p>The container’s last child.</p>
<pre><code class="js">rule.last == rule.nodes[rule.nodes.length - <span class="number">1</span>];
</code></pre>
<h3 id="container-index(child)"><code>container.index(child)</code></h3><p>Returns <code>child</code>’s index within the container’s <code>nodes</code> array.</p>
<pre><code class="js">rule.index( rule.nodes[<span class="number">2</span>] ) <span class="comment">//=&gt; 2</span>
</code></pre>
<h3 id="container-every(callback)"><code>container.every(callback)</code></h3><p>Returns <code>true</code> if <code>callback</code> returns a truthy value for all<br>of the container’s children.</p>
<pre><code class="js"><span class="keyword">var</span> noPrefixes = rule.every(<span class="function"><span class="keyword">function</span> (<span class="params">decl</span>) </span>{
    <span class="keyword">return</span> decl.prop[<span class="number">0</span>] != <span class="string">'-'</span>;
});
</code></pre>
<h3 id="container-some(callback)"><code>container.some(callback)</code></h3><p>Return <code>true</code> if <code>callback</code> returns a truthy value<br>for (at least) one of the container’s children.</p>
<pre><code class="js"><span class="keyword">var</span> hasPrefix = rule.some(<span class="function"><span class="keyword">function</span> (<span class="params">decl</span>) </span>{
    <span class="keyword">return</span> decl.prop[<span class="number">0</span>] == <span class="string">'-'</span>;
});
</code></pre>
<h3 id="container-each(callback)"><code>container.each(callback)</code></h3><p>Iterates through the container’s immediate children, calling <code>callback</code><br>for each child.</p>
<p><code>callback</code> receives 2 arguments: the node itself and an index.</p>
<p>Returning <code>false</code> within <code>callback</code> will break iteration.</p>
<pre><code class="js"><span class="keyword">var</span> color;
rule.each(<span class="function"><span class="keyword">function</span> (<span class="params">decl</span>) </span>{
    <span class="keyword">if</span> ( decl.prop == <span class="string">'color'</span> ) {
        color = decl.value;
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
});
</code></pre>
<p>Unlike the <code>for {}</code>-cycle or <code>Array#forEach()</code> this iterator is safe<br>if you are mutating the array of child nodes during iteration.<br>PostCSS will adjust the current index to match the mutations.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a { color: black; z-index: 1 }'</span>);
<span class="keyword">var</span> rule = root.first;

<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rule.nodes.length; i++ ) {
    <span class="keyword">var</span> decl = rule.nodes[i];
    decl.cloneBefore({ prop: <span class="string">'-webkit-'</span> + decl.prop });
    <span class="comment">// Cycle will be infinite, because cloneBefore move current node</span>
    <span class="comment">// to next index</span>
}

rule.each(<span class="function"><span class="keyword">function</span> (<span class="params">decl</span>) </span>{
    decl.cloneBefore({ prop: <span class="string">'-webkit-'</span> + decl.prop });
    <span class="comment">// Will be executed only for color and z-index</span>
});
</code></pre>
<p><code>container.each()</code> only iterates through the container’s immediate children.<br>If you need to recursively iterate through all the container’s descendents,<br>use <code>container.eachInside()</code>.</p>
<h3 id="container-eachInside(callback)"><code>container.eachInside(callback)</code></h3><p>Recursively iterates through the container’s children,<br>those children’s children, etc., calling <code>callback</code> for each.</p>
<p><code>callback</code> receives 2 arguments: the node itself and an index.</p>
<pre><code class="js">root.eachInside(<span class="function"><span class="keyword">function</span> (<span class="params">node</span>) </span>{
    <span class="comment">// Will be iterate through all nodes</span>
});
</code></pre>
<p>Like <code>container.each()</code>, this method is safe to use<br>if you are mutating arrays during iteration.</p>
<p>If you only need to iterate through the container’s immediate children,<br>use <code>container.each()</code>.</p>
<h3 id="container-eachDecl([propFilter,]_callback)"><code>container.eachDecl([propFilter,] callback)</code></h3><p>Recursively iterates through all declaration nodes within the container,<br>calling <code>callback</code> for each.</p>
<p><code>callback</code> receives 2 arguments: the node itself and an index.</p>
<pre><code class="js">root.eachDecl(<span class="function"><span class="keyword">function</span> (<span class="params">decl</span>) </span>{
    <span class="keyword">if</span> ( decl.prop.match(<span class="regexp">/^-webkit-/</span>) ) {
        decl.removeSelf();
    }
});
</code></pre>
<p>If you pass a string or regular expression as <code>filter</code>, only those declarations whose<br>property matches<code>filter</code> will be iterated over.</p>
<pre><code class="js"><span class="comment">// Make flat design</span>
root.eachDecl(<span class="string">'border-radius'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">decl</span>) </span>{
    decl.removeSelf();
});
root.eachDecl(<span class="regexp">/^background/</span>, <span class="function"><span class="keyword">function</span> (<span class="params">decl</span>) </span>{
    decl.value = takeFirstColorFromGradient(decl.value);
});
</code></pre>
<p>Like <code>container.each()</code>, this method is safe to use if you are mutating<br>arrays during iteration.</p>
<h3 id="container-eachAtRule([nameFilter,]_callback)"><code>container.eachAtRule([nameFilter,] callback)</code></h3><p>Recursively iterates through all at-rule nodes within the container,<br>calling <code>callback</code> for each.</p>
<p><code>callback</code> receives 2 arguments: the node itself and an index.</p>
<pre><code class="js">root.eachAtRule(<span class="function"><span class="keyword">function</span> (<span class="params">rule</span>) </span>{
    <span class="keyword">if</span> ( rule.name.match(<span class="regexp">/^-webkit-/</span>) ) rule.removeSelf();
});
</code></pre>
<p>If you pass a string or regular expression as <code>filter</code>, only those at-rules whose name<br>matches <code>filter</code> will be iterated over.</p>
<pre><code class="js"><span class="keyword">var</span> first = <span class="literal">false</span>;
root.eachAtRule(<span class="string">'charset'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">rule</span>) </span>{
    <span class="keyword">if</span> ( !first ) {
        first = <span class="literal">true</span>;
    } <span class="keyword">else</span> {
        rule.removeSelf();
    }
});
</code></pre>
<p>Like <code>container.each()</code>, this method is safe to use if you are mutating arrays<br>during iteration.</p>
<h3 id="container-eachRule(callback)"><code>container.eachRule(callback)</code></h3><p>Recursively iterates through all rule nodes within the container, calling<br><code>callback</code> for each.</p>
<p><code>callback</code> receives 2 arguments: the node itself and an index.</p>
<pre><code class="js"><span class="keyword">var</span> selectors = [];
root.eachRule(<span class="function"><span class="keyword">function</span> (<span class="params">rule</span>) </span>{
    selectors.push(rule.selector);
});
<span class="built_in">console</span>.log(<span class="string">'You CSS uses '</span> + selectors.length + <span class="string">' selectors'</span>);
</code></pre>
<p>Like <code>container.each()</code>, this method is safe to use if you are mutating arrays<br>during iteration.</p>
<h3 id="container-eachComment(callback)"><code>container.eachComment(callback)</code></h3><p>Recursively iterates through all comment nodes within the container, calling<br><code>callback</code> for each.</p>
<pre><code class="js">root.eachComment(<span class="function"><span class="keyword">function</span> (<span class="params">comment</span>) </span>{
    comment.removeSelf();
})
</code></pre>
<p>Like <code>container.each()</code>, this method is safe to use if you are mutating arrays<br>during iteration.</p>
<h3 id="container-replaceValues(regexp,_opts,_callback)"><code>container.replaceValues(regexp, opts, callback)</code></h3><p>Passes all declaration values within the container that match <code>regexp</code> through<br><code>callback</code>, replacing those values with the returned result of <code>callback</code>.</p>
<p><code>callback</code> will receive the same arguments as those passed to a function<br>parameter of <a href="(https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter)"><code>String#replace</code></a>.</p>
<p>You can speed up the search by passing <code>opts</code>:</p>
<ul>
<li><code>props</code>: An array of property names. The method will only search for values<br>that match <code>regexp</code> within declarations of listed properties.</li>
<li><code>fast</code>: A string that will be used to narrow down values and speed up<br>the regexp search. Searching every single value with a regexp can be slow;<br>so if you pass a <code>fast</code> string, PostCSS will first check whether the value<br>contains the <code>fast</code> string; and only if it does will PostCSS check that value<br>against <code>regexp</code>. For example, instead of just checking for <code>/\d+rem/</code> on<br>all values, you can set <code>fast: &#39;rem&#39;</code> to first check whether a value has<br>the <code>rem</code> unit, and only if it does perform the regexp check.</li>
</ul>
<p>This method is useful if you are using a custom unit or function,<br>so need to iterate through all values.</p>
<pre><code class="js">root.replaceValues(<span class="regexp">/\d+rem/</span>, { fast: <span class="string">'rem'</span> }, <span class="function"><span class="keyword">function</span> (<span class="params">string</span>) </span>{
    <span class="keyword">return</span> <span class="number">15</span> * <span class="built_in">parseInt</span>(string) + <span class="string">'px'</span>;
});
</code></pre>
<h3 id="container-prepend(node)_and_container-append(node)"><code>container.prepend(node)</code> and <code>container.append(node)</code></h3><p>Insert a new node to the start/end of the container.</p>
<pre><code class="js"><span class="keyword">var</span> decl = postcss.decl({ prop: <span class="string">'color'</span>, value: <span class="string">'black'</span> });
rule.append(decl);
</code></pre>
<p>Because each node class is identifiable by unique properties, you can use<br>the following shortcuts to create nodes to prepend/append:</p>
<pre><code class="js">root.append({ name: <span class="string">'@charset'</span>, params: <span class="string">'"UTF-8"'</span> }); <span class="comment">// at-rule</span>
root.append({ selector: <span class="string">'a'</span> });                       <span class="comment">// rule</span>
rule.append({ prop: <span class="string">'color'</span>, value: <span class="string">'black'</span> });       <span class="comment">// declaration</span>
rule.append({ text: <span class="string">'Comment'</span> })                      <span class="comment">// comment</span>
</code></pre>
<h3 id="container-insertBefore(oldNode,_newNew)_and_container-insertAftr(oldNode,_newNew)"><code>container.insertBefore(oldNode, newNew)</code>  and <code>container.insertAftr(oldNode, newNew)</code></h3><p>Insert <code>newNode</code> before/after <code>oldNode</code> within the container.</p>
<p><code>oldNode</code> can be a node or a node’s index.</p>
<pre><code class="js">rule.insertBefore(decl, decl.clone({ prop: <span class="string">'-webkit-'</span> + decl.prop }));
</code></pre>
<p>You can also use the same shorcuts available to <code>container.append()</code>.</p>
<pre><code class="js">rule.insertBefore(decl, { prop: <span class="string">'color'</span>, value: <span class="string">'black'</span> });
</code></pre>
<h3 id="container-remove(node)"><code>container.remove(node)</code></h3><p>Removes <code>node</code> from the container, and the <code>parent</code> properties of <code>node</code><br>and its children.</p>
<p><code>node</code> can be a node or a node’s index.</p>
<pre><code class="js">rule.nodes.length  <span class="comment">//=&gt; 5</span>
rule.remove(decl);
rule.nodes.length  <span class="comment">//=&gt; 4</span>
decl.parent        <span class="comment">//=&gt; undefined</span>
</code></pre>
<h3 id="container-removeAll()"><code>container.removeAll()</code></h3><p>Removes all children from the container, and cleans their <code>parent</code> properties.</p>
<pre><code class="js">rule.removeAll();
rule.nodes.length <span class="comment">//=&gt; 0</span>
</code></pre>
<h2 id="Root_node"><code>Root</code> node</h2><p>Represents a CSS file and contains all its parsed nodes.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a{color:black} b{z-index:2}'</span>);
root.type         <span class="comment">//=&gt; 'root'</span>
root.nodes.length <span class="comment">//=&gt; 2</span>
</code></pre>
<h3 id="root-toResult(opts)"><code>root.toResult(opts)</code></h3><p>Returns a <a href="#result-class"><code>Result</code></a> instance representing the root’s CSS.</p>
<pre><code class="js"><span class="keyword">var</span> root1 = postcss.parse(css1, { from: <span class="string">'a.css'</span> });
<span class="keyword">var</span> root2 = postcss.parse(css2, { from: <span class="string">'b.css'</span> });

root1.append(root2);
<span class="keyword">var</span> result = root1.toResult({ to: <span class="string">'all.css'</span>, map: <span class="literal">true</span> });
</code></pre>
<p>Options:</p>
<ul>
<li><code>to</code>: the path where you’ll put the output CSS file. You should always set<br><code>to</code> to generate correct source maps.</li>
<li><code>map</code>: an object of <a href="https://github.com/postcss/postcss#source-map">source map options</a>.</li>
</ul>
<h3 id="root-after"><code>root.after</code></h3><p>The space symbols after the last child of <code>root</code>,<br>such as <code>\n</code> at the end of a file.</p>
<pre><code class="js"><span class="keyword">var</span> root = parse(<span class="string">'a {}\nb { color: black }\n'</span>);
root.after <span class="comment">//=&gt; '\n'</span>
</code></pre>
<p>This is a code style property.</p>
<h2 id="AtRule_node"><code>AtRule</code> node</h2><p>Represents an at-rule.</p>
<p>This node will have a <code>nodes</code> property, representing its children,<br>if it is followed in the CSS by a <code>{}</code> block.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'@charset "UTF-8"; @media print {}'</span>);

<span class="keyword">var</span> charset = root.first;
charset.type  <span class="comment">//=&gt; 'atrule'</span>
charset.nodes <span class="comment">//=&gt; undefined</span>

<span class="keyword">var</span> media = root.last;
media.nodes   <span class="comment">//=&gt; []</span>
</code></pre>
<h3 id="atrule-name"><code>atrule.name</code></h3><p>The at-rule’s name. This is the identifier that immediately follows the <code>@</code>.</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(<span class="string">'@media print {}'</span>);
<span class="keyword">var</span> media = root.first;
media.name <span class="comment">//=&gt; 'media'</span>
</code></pre>
<h3 id="atrule-params"><code>atrule.params</code></h3><p>The at-rule’s parameters. These are the values that follow the at-rule’s name<br>but precede any <code>{}</code> block. The spec refers to this area<br>as the at-rule’s “prelude”.</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(<span class="string">'@media print, screen {}'</span>);
<span class="keyword">var</span> media = root.first;
media.params <span class="comment">//=&gt; '[print, screen]'</span>
</code></pre>
<p>This value will be cleaned of comments. If the source at-rule’s prelude<br>contained comments, those comments will be available<br>in the <code>_params.raw</code> property.</p>
<p>If you have not changed the parameters, calling <code>atrule.toString()</code><br>will stringify the original raw value (comments and all).</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(<span class="string">'@media print, /**/ screen {}'</span>);
<span class="keyword">var</span> media = root.first;
media.params      <span class="comment">//=&gt; '[print,  screen]'</span>
media._params.raw <span class="comment">//=&gt; 'print, /**/ screen'</span>
media.toString()  <span class="comment">//=&gt; '@media print, /**/ screen {}'</span>
</code></pre>
<h3 id="atrule-before"><code>atrule.before</code></h3><p>The space symbols before the at-rule.</p>
<p>The default value is <code>\n</code>, except for the first rule in a <code>Root</code>,<br>whose <code>before</code> property is empty.</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(<span class="string">'@charset "UTF-8";\n@media print {}\n'</span>);
<span class="keyword">var</span> media = root.last;
media.before <span class="comment">//=&gt; '\n'</span>
</code></pre>
<p>This is a code style property.</p>
<h3 id="atrule-afterName"><code>atrule.afterName</code></h3><p>The space symbols between the at-rule’s name and its parameters.</p>
<p>The default value is <code> </code>.</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(<span class="string">'@media\n  print,\n  screen {}\n'</span>);
<span class="keyword">var</span> media = root.first;
media.afterName <span class="comment">//=&gt; '\n  '</span>
</code></pre>
<p>This is a code style property.</p>
<h3 id="atrule-between"><code>atrule.between</code></h3><p>The space symbols between the at-rule’s parameters<br>and <code>{</code>, the block-opening curly brace.</p>
<p>The default value is <code> </code>.</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(<span class="string">'@media print, screen\n{}\n'</span>);
<span class="keyword">var</span> media = root.first;
media.before <span class="comment">//=&gt; '\n'</span>
</code></pre>
<p>This is a code style property.</p>
<h3 id="atrule-after"><code>atrule.after</code></h3><p>The space symbols between the at-rule’s last child and <code>}</code>,<br>the block-closing curly brace.</p>
<p>The default value is <code>\n</code> if the at-rule has children,<br>and an empty string (<code>&#39;&#39;</code>) if it does not.</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(<span class="string">'@media print {\n  a {}\n  }\n'</span>);
<span class="keyword">var</span> media = root.first;
media.after <span class="comment">//=&gt; '\n  '</span>
</code></pre>
<p>This is a code style property.</p>
<h3 id="atrule-semicolon"><code>atrule.semicolon</code></h3><p><code>true</code> if at-rule’s last child declaration<br>is followed by an (optional) semicolon.</p>
<p><code>undefined</code> if the semicolon is omitted.</p>
<pre><code class="js">postcss.parse(<span class="string">'@page{color:black}'</span>).first.semicolon  <span class="comment">//=&gt; undefined</span>
postcss.parse(<span class="string">'@page{color:black;}'</span>).first.semicolon <span class="comment">//=&gt; true</span>
</code></pre>
<p>This is a code style property.</p>
<h2 id="Rule_node"><code>Rule</code> node</h2><p>Represents a CSS rule: a selector followed by a declaration block.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a{}'</span>);
<span class="keyword">var</span> rule = root.first;
rule.type       <span class="comment">//=&gt; 'rule'</span>
rule.toString() <span class="comment">//=&gt; 'a{}'</span>
</code></pre>
<h3 id="rule-selector"><code>rule.selector</code></h3><p>The rule’s full selector represented as a string. If there are multiple<br>comma-separated selectors, the entire group will be included.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a, b { }'</span>);
<span class="keyword">var</span> rule = root.first;
rule.selector <span class="comment">//=&gt; 'a, b'</span>
</code></pre>
<p>This value will be cleaned of comments. If the source selector contained<br>comments, those comments will be available in the <code>_selector.raw</code> property.</p>
<p>If you have not changed the selector, the result of <code>rule.toString()</code><br>will include the original raw selector value (comments and all).</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a /**/ b {}'</span>);
<span class="keyword">var</span> rule = root.first;
rule.selector      <span class="comment">//=&gt; 'a  b'</span>
rule._selector.raw <span class="comment">//=&gt; 'a /**/ b'</span>
rule.toString()    <span class="comment">//=&gt; 'a /**/ b {}'</span>
</code></pre>
<h3 id="rule-selectors"><code>rule.selectors</code></h3><p>An array containing the rule’s individual selectors.<br>Groups of selectors are split at commas.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a, b { }'</span>);
<span class="keyword">var</span> rule = root.first;

rule.selector  <span class="comment">//=&gt; 'a, b'</span>
rule.selectors <span class="comment">//=&gt; ['a', 'b']</span>

rule.selectors = [<span class="string">'a'</span>, <span class="string">'strong'</span>];
rule.selector <span class="comment">//=&gt; 'a, strong'</span>
</code></pre>
<h3 id="rule-before"><code>rule.before</code></h3><p>The space symbols before the rule.</p>
<p>The default value is <code>\n</code>, except for first rule in root,<br>whose <code>before</code> property is empty.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a {}\nb {}\n'</span>);
<span class="keyword">var</span> rule = root.last;
rule.before <span class="comment">//=&gt; '\n'</span>
</code></pre>
<p>This is a code style property.</p>
<h3 id="rule-after"><code>rule.after</code></h3><p>The space symbols between the rule’s last child and <code>}</code>,<br>the block-closing curly brace.</p>
<p>The default value is <code>\n</code> if rule has children and an empty string (<code>&#39;&#39;</code>)<br>if it does not.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'@a {\n  color: black\n  }\n'</span>);
<span class="keyword">var</span> rule = root.first;
root.after <span class="comment">//=&gt; '\n  '</span>
</code></pre>
<p>This is a code style property.</p>
<h3 id="rule-semicolon"><code>rule.semicolon</code></h3><p><code>true</code> if rule’s last child declaration is followed by an (optional) semicolon.</p>
<p><code>undefined</code> if the semicolon is omitted.</p>
<pre><code class="js">postcss.parse(<span class="string">'a{color:black}'</span>).first.semicolon  <span class="comment">//=&gt; undefined</span>
postcss.parse(<span class="string">'a{color:black;}'</span>).first.semicolon <span class="comment">//=&gt; true</span>
</code></pre>
<p>This is a code style property.</p>
<h2 id="Declaration_node"><code>Declaration</code> node</h2><p>Represents a CSS declaration.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a { color: black }'</span>);
<span class="keyword">var</span> decl = root.first.first;
decl.type       <span class="comment">//=&gt; 'decl'</span>
decl.toString() <span class="comment">//=&gt; ' color: black'</span>
</code></pre>
<h3 id="declaration-prop"><code>declaration.prop</code></h3><p>The declaration’s property name.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a { color: black }'</span>);
<span class="keyword">var</span> decl = root.first.first;
decl.prop <span class="comment">//=&gt; 'color'</span>
</code></pre>
<h3 id="declaration-value"><code>declaration.value</code></h3><p>The declaration’s value.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a { color: black }'</span>);
<span class="keyword">var</span> decl = root.first.first;
decl.value <span class="comment">//=&gt; 'black'</span>
</code></pre>
<p>This value will be cleaned of comments. If the source value contained comments,<br>those comments will be available in the <code>_value.raw</code> property.</p>
<p>If you have not changed the value, the result of <code>decl.toString()</code> will include<br>the original raw value (comments and all).</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a { border-radius: 3px /**/ 0 }'</span>);
<span class="keyword">var</span> decl = root.first.first;
decl.value      <span class="comment">//=&gt; '3px  0'</span>
decl._value.raw <span class="comment">//=&gt; '3px /**/ 0'</span>
decl.toString() <span class="comment">//=&gt; ' border-radius: 3px /**/ 0'</span>
</code></pre>
<h3 id="declaration-before"><code>declaration.before</code></h3><p>The space symbols before the declaration.</p>
<p>Default value is <code>\n</code>.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a {\n  color: black\n}\n'</span>);
<span class="keyword">var</span> decl = root.first.first;
decl.before <span class="comment">//=&gt; '\n  '</span>
</code></pre>
<p>This is a code style property.</p>
<h3 id="declaration-between"><code>declaration.between</code></h3><p>The symbols between the declaration’s property and its value.</p>
<p>Default value is <code>:</code>.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a { color/**/: black }'</span>);
<span class="keyword">var</span> decl = root.first.first;
decl.between <span class="comment">//=&gt; '/**/: '</span>
</code></pre>
<p>This is a code style property.</p>
<h3 id="declaration-important"><code>declaration.important</code></h3><p><code>true</code> if the declaration has an <code>!important</code> annotation.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a { color: black !important; color: white }'</span>);
root.first.first.important <span class="comment">//=&gt; true</span>
root.first.last.important  <span class="comment">//=&gt; undefined</span>
</code></pre>
<p>If there are comments between the declaration’s value and its<br><code>!important</code> annotation, they will be available in the <code>_important</code> property.</p>
<pre><code class="js"><span class="keyword">var</span> root = postcss.parse(<span class="string">'a { color: black /**/ !important }'</span>);
root.first.first._important <span class="comment">//=&gt; ' /**/ !important'</span>
</code></pre>
<h2 id="Comment_node"><code>Comment</code> node</h2><p>Represents a comment between declarations or statements (rule and at-rules).<br>Comments inside selectors, at-rules parameters, or declaration values<br>will be stored in the raw properties explained above.</p>
<pre><code class="js"><span class="keyword">var</span> root    = postcss.parse(<span class="string">'a { color: /* inner */ black; /* outer */ }'</span>);
<span class="keyword">var</span> decl    = root.first.first;
<span class="keyword">var</span> comment = root.first.last;

comment.type <span class="comment">//=&gt; 'comment'</span>
decl.between <span class="comment">//=&gt; ': /* inner */'</span>
</code></pre>
<h3 id="comment-text"><code>comment.text</code></h3><p>The comment’s text.</p>
<pre><code class="js"><span class="keyword">var</span> root    = postcss.parse(<span class="string">'/* Empty file */'</span>);
<span class="keyword">var</span> comment = root.first;
<span class="keyword">var</span> comment.text <span class="comment">//=&gt; 'Empty file'</span>
</code></pre>
<h3 id="comment-left_and_comment-right"><code>comment.left</code> and <code>comment.right</code></h3><p>The space symbols before/after the comment’s text.</p>
<p>Default value is <code> </code>.</p>
<pre><code class="js"><span class="keyword">var</span> root  = postcss.parse(<span class="string">'/* long */ /*short*/'</span>);
<span class="keyword">var</span> long  = root.first;
<span class="keyword">var</span> short = root.last;

long.left  <span class="comment">//=&gt; ' '</span>
short.left <span class="comment">//=&gt; ''</span>
</code></pre>
<p>This is a code style property.</p>
<h3 id="comment-before"><code>comment.before</code></h3><p>The space symbols before the comment.</p>
<p>Default value is <code>\n</code>.</p>
<pre><code class="js"><span class="keyword">var</span> root    = postcss.parse(<span class="string">'a {\n  /**/}\n'</span>);
<span class="keyword">var</span> comment = root.first.first;
comment.before <span class="comment">//=&gt; '\n  '</span>
</code></pre>
<p>This is a code style property.</p>
