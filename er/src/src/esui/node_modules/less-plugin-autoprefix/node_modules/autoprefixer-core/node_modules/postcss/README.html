<h1 id="PostCSS">PostCSS <a href="https://travis-ci.org/postcss/postcss"><img src="https://travis-ci.org/postcss/postcss.svg" alt="Build Status"></a> <a href="https://gitter.im/postcss/postcss?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join Chat.svg" alt="Gitter"></a></h1><p><img align="right" width="95" height="95" src="http://postcss.github.io/postcss/logo.svg" title="Philosopher’s stone, logo of PostCSS"></p>
<p>PostCSS is a tool for transforming CSS with JS plugins. The growing ecosystem<br>of PostCSS plugins can add vendor prefixes, support variables and mixins,<br>transpile future CSS syntax, inline images, and more.</p>
<p>PostCSS is used by Google, Twitter, Alibaba, and Shopify.<br>Its most popular plugin, <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a>, is one of the most universally<br>praised CSS processors available.</p>
<p>PostCSS can do the same work as preprocessors like Sass, Less, and Stylus.<br>But PostCSS is modular, 4-40x faster, and much more powerful.</p>
<p>PostCSS itself is very small. It includes only a CSS parser,<br>a CSS node tree API, a source map generator, and a node tree stringifier.<br>All CSS transformations are encapsulated in modular plugins. And these plugins<br>are themselves small plain JS functions, which receive a CSS node tree,<br>apply transformations to it, and return a modified tree.</p>
<p>You can use the <a href="https://github.com/putaindecode/cssnext">cssnext</a> plugin pack and write future CSS code right now:</p>
<pre><code class="css"><span class="pseudo">:root</span> <span class="rules">{
    <span class="rule"><span class="attribute">--row</span>:<span class="value"> <span class="number">1rem</span></span></span>;
    <span class="rule"><span class="attribute">--mainColor</span>:<span class="value"> <span class="hexcolor">#ffbbaaff</span></span></span>;
}</span>

<span class="at_rule">@<span class="keyword">custom-media</span> --mobile (width &lt;= <span class="number">640px</span>)</span>;

<span class="at_rule">@<span class="keyword">custom-selector</span> --heading h1, h2, h3, h4, h5, h6</span>;

<span class="class">.post-article</span> <span class="tag">--heading</span> <span class="rules">{
    <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="function">calc</span>(<span class="number">10</span> * <span class="function">var</span>(--row))</span></span>;
    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="function">color</span>(<span class="function">var</span>(--mainColor) <span class="function">blackness</span>(+<span class="number">20%</span>))</span></span>;
    <span class="rule"><span class="attribute">font-variant-caps</span>:<span class="value"> small-caps</span></span>;
}</span>
<span class="at_rule">@<span class="keyword">media</span> (--mobile) </span>{
    <span class="class">.post-article</span> <span class="tag">--heading</span> <span class="rules">{
        <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">0</span></span></span>;
    }</span>
}
</code></pre>
<p>Or if you like the power provided by preprocessors like Sass,<br>you could combine <a href="https://github.com/postcss/postcss-nested">postcss-nested</a>, <a href="https://github.com/postcss/postcss-mixins">postcss-mixins</a>, <a href="https://github.com/postcss/postcss-easings">postcss-easings</a><br>and <a href="https://github.com/postcss/postcss-media-minmax">postcss-media-minmax</a>:</p>
<pre><code class="css">$mobile: width &lt;= 640px;

@define-mixin social-icon $color {
    background: $color;
    &amp;:hover {
        background: color($color whiteness(+10%));
    }
}

.social-icon {
    transition: background 200ms ease-in-sine;
    &amp;.is-twitter {
        @mixin social-icon #55acee;
    }
    &amp;.is-facebook {
        @mixin social-icon #3b5998;
    }
}

.post-article {
    padding: 10px 5px;
    @media ($mobile) {
        padding: 0;
    }
}
</code></pre>
<p>Twitter account for articles, releases, and new plugins: <a href="https://twitter.com/postcss">@postcss</a>.<br>Weibo account: <a href="http://weibo.com/postcss">postcss</a>.</p>
<p><a href="https://evilmartians.com/?utm_source=postcss"><br><img src="https://evilmartians.com/badges/sponsored-by-evil-martians.svg" alt="Sponsored by Evil Martians" width="236" height="54"><br></a></p>
<h2 id="How_PostCSS_differs_from_Preprocessors">How PostCSS differs from Preprocessors</h2><p>Sass, Less and Stylus provide specialized languages that you can use to write<br>CSS templates. These languages and their compilers are defined together<br>in large codebases. Tools and libraries for preprocessors must work within<br>each preprocessor’s limitations: usually they can only offer sets<br>of pre-defined mixins, functions, and variables.</p>
<p>In contrast, PostCSS provides a simple API that modular plugins can use<br>to understand, transform, and create CSS. PostCSS plugins, therefore,<br>can be created, maintained, and implemented independently. And they can perform<br>many different tasks, not just compile special syntaxes to CSS.<br>Each plugin does one thing well.</p>
<h2 id="Features">Features</h2><h3 id="Modularity">Modularity</h3><p>Without any plugins, PostCSS will parse your CSS and stringify it back<br>to you without changing a single byte. All of the processing that enables<br>special features and syntax in your stylesheets is made possible<br>by PostCSS plugins, which are nothing more than JS functions.</p>
<p>Because each PostCSS plugin is an independent module, different plugins can take<br>different approaches. This flexibility allows plugin authors to create whatever<br>features they can imagine, while empowering PostCSS users to add only<br>those features that they want to their workflow.</p>
<p>Some plugins, like <a href="https://github.com/postcss/postcss-custom-properties">postcss-custom-properties</a>, <a href="https://github.com/postcss/postcss-media-minmax">postcss-media-minmax</a>,<br>and <a href="https://github.com/postcss/postcss-calc">postcss-calc</a>, implement syntax from present and future W3C specs,<br>transpiling it to cross-browser-compatible output. Other plugins,<br>like <a href="https://github.com/postcss/postcss-mixins">postcss-mixins</a> and <a href="https://github.com/davidtheclark/postcss-simple-extend">postcss-simple-extend</a>, add new powers<br>to your stylesheets that are not yet part of any spec. With PostCSS,<br>you can decide for yourself which plugins match your own needs and preferences.</p>
<p>Another advantage of PostCSS’s modularity is that anybody can contribute easily<br>to the PostCSS ecosystem. Plugins are simple npm packages;<br>so there are no barriers to writing your own plugins, or contributing ideas<br>and bug fixes to the plugins that you use.</p>
<h3 id="Perfomance">Perfomance</h3><p>PostCSS is one of the fastest CSS parsers written in JS. (Only <a href="https://github.com/NV/CSSOM">CSSOM</a> is<br>faster, and only because it is less accurate.) So PostCSS will read your CSS<br>and apply transformations faster than any other stylesheet processor out there.</p>
<p>If you use Ruby Sass now, PostCSS could significantly improve your development<br>process: PostCSS processing is <em>40 times faster</em> than Ruby Sass compilation.<br>And even if you throw in the entire <a href="https://github.com/putaindecode/cssnext">cssnext</a> plugin pack, PostCSS,<br>written in JS, is still <em>4 times faster</em> than <a href="https://github.com/sass/libsass">libsass</a>, written on C++.</p>
<h3 id="Powerful_Tools">Powerful Tools</h3><p>PostCSS plugins can read and rebuild an entire CSS node tree. With this power,<br>plugin authors are able to create tools that would be impossible<br>to build into preprocessors (like <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a>).</p>
<p>PostCSS-powered tools can do much more than transform special syntax into<br>browser-friendly CSS. PostCSS plugin authors have built linters<br>(like <a href="https://github.com/anandthakker/doiuse">doiuse</a> and <a href="https://github.com/necolas/postcss-bem-linter">postcss-bem-linter</a>), code review tools<br>(like <a href="https://github.com/davidtheclark/list-selectors">list-selectors</a>), and minifiers (like <a href="https://github.com/hail2u/node-csswring">csswring</a>).<br>With <a href="https://github.com/Ser-Gen/postcss-data-packer">postcss-data-packer</a>, you can create a cacheable “sprite”<br>by moving all <code>data:uri</code> values to separate file.</p>
<p>One unique example of PostCSS’s power is <a href="https://github.com/MohammadYounes/rtlcss">RTLCSS</a>. As you know,<br>in Arabic and Hebrew, writing moves from right-to-left (RTL), instead<br>of the more widespread left-to-right convention. Because a language’s<br>directionality affects its readers’ perspective, an international site’s layout<br>needs to change for RTL users, not just its text. (Check out <a href="https://ar.wikipedia.org/wiki/%D9%84%D8%BA%D8%A9_%D8%B9%D8%B1%D8%A8%D9%8A%D8%A9">Arabic Wikipedia</a><br>as an example.) The <a href="https://github.com/MohammadYounes/rtlcss">RTLCSS</a> plugin effectively “mirrors” your stylesheet<br>by swapping <code>left</code> and <code>right</code>, changing the value order in <code>margin</code> shorthands,<br>and more.</p>
<h3 id="Use_the_CSS_of_the_Future">Use the CSS of the Future</h3><p>CSS3 added valuable features, but some of them are not yet available in all<br>of the browsers that developers need to support. And exciting future CSS modules<br>are being drafted now — some even implemented in cutting-edge browsers —<br>that will not be widely available for quite a while. But PostCSS plugins<br>can allow us to write this CSS of the future, then transpile it to code usable<br>in all the browsers we must support.</p>
<p><a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> exemplifies this power: you write spec-compliant, future-friendly<br>CSS, pretending that vendor prefixes don’t exist, and it does the dirty work<br>of inserting the prefixes you’ll need. All of the plugins bundled into <a href="https://github.com/putaindecode/cssnext">cssnext</a><br>do similar work, allowing authors to use syntax and functions<br>from the latest W3C specs without worrying about the fallbacks they’ll need.</p>
<p>As more CSS specs are drafted, more PostCSS plugins will be written. Users will<br>be able to write stylesheets using standard, interoperable syntax, instead of<br>a specialized language for a specialized tool (as with preprocessors).</p>
<h2 id="Quick_Start">Quick Start</h2><ol>
<li>Implement PostCSS with your build tool of choice. See the PostCSS <a href="https://github.com/nDmitry/grunt-postcss">Grunt</a>,<br><a href="https://github.com/w0rm/gulp-postcss">Gulp</a>, and <a href="https://github.com/postcss/postcss-loader">webpack</a> plugins more detailed instructions.</li>
<li>Select plugins from the list below and add them to your PostCSS process.</li>
<li>Make awesome products.</li>
</ol>
<h2 id="Plugins_Packs">Plugins Packs</h2><ul>
<li><a href="https://github.com/putaindecode/cssnext">cssnext</a> contains plugins that allow you to use future CSS features today.</li>
<li><a href="https://github.com/morishitter/acss">ACSS</a> contains plugins that transform your CSS according<br>to special annotation comments.</li>
</ul>
<h2 id="Plugins">Plugins</h2><h3 id="Future_CSS_Syntax">Future CSS Syntax</h3><ul>
<li><a href="https://github.com/postcss/postcss-color-function">postcss-color-function</a> supports functions to transform colors.</li>
<li><a href="https://github.com/postcss/postcss-color-gray">postcss-color-gray</a> supports the <code>gray()</code> function.</li>
<li><a href="https://github.com/TrySound/postcss-color-hex">postcss-color-hex</a> transforms <code>rgb()</code> and <code>rgba()</code> to hex.</li>
<li><a href="https://github.com/postcss/postcss-color-hex-alpha">postcss-color-hex-alpha</a> supports <code>#rrggbbaa</code> and <code>#rgba</code> notation.</li>
<li><a href="https://github.com/postcss/postcss-color-hwb">postcss-color-hwb</a> transforms <code>hwb()</code> to widely compatible <code>rgb()</code>.</li>
<li><a href="https://github.com/postcss/postcss-color-rebeccapurple">postcss-color-rebeccapurple</a> supports the <code>rebeccapurple</code> color.</li>
<li><a href="https://github.com/postcss/postcss-custom-media">postcss-custom-media</a> supports custom aliases for media queries.</li>
<li><a href="https://github.com/postcss/postcss-custom-properties">postcss-custom-properties</a> supports variables, using syntax from<br>the W3C Custom Properties.</li>
<li><a href="https://github.com/postcss/postcss-custom-selectors">postcss-custom-selectors</a> adds custom aliases for selectors.</li>
<li><a href="https://github.com/postcss/postcss-font-variant">postcss-font-variant</a> transpiles human-readable <code>font-variant</code> to more widely<br>supported CSS.</li>
<li><a href="https://github.com/vitkarpov/postcss-host">postcss-host</a> makes the Shadow DOM’s <code>:host</code> selector work properly<br>with pseudo-classes.</li>
<li><a href="https://github.com/postcss/postcss-media-minmax">postcss-media-minmax</a> adds <code>&lt;=</code> and <code>=&gt;</code> statements to media queries.</li>
<li><a href="https://github.com/twbs/mq4-hover-shim">mq4-hover-shim</a> supports the <code>@media (hover)</code> feature.</li>
</ul>
<h3 id="Fallbacks">Fallbacks</h3><ul>
<li><a href="https://github.com/Rycochet/postcss-epub">postcss-epub</a> adds the <code>-epub-</code> prefix to relevant properties.</li>
<li><a href="https://github.com/iamvdo/postcss-opacity">postcss-opacity</a> adds opacity filter for IE8.</li>
<li><a href="https://github.com/iamvdo/postcss-vmin">postcss-vmin</a> generates <code>vm</code> fallback for <code>vmin</code> unit in IE9.</li>
<li><a href="https://github.com/postcss/postcss-will-change">postcss-will-change</a> inserts 3D hack before <code>will-change</code> property.</li>
<li><a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> adds vendor prefixes for you, using data from Can I Use.</li>
<li><a href="https://github.com/cssdream/cssgrace">cssgrace</a> provides various helpers and transpiles CSS3 for IE<br>and other old browsers.</li>
<li><a href="https://github.com/robwierzbowski/node-pixrem">pixrem</a> generates pixel fallbacks for <code>rem</code> units.</li>
<li><a href="https://github.com/iamvdo/pleeease-filters">pleeease-filters</a> converts WebKit filters to SVG filters,<br>for cross-browser compatibility.</li>
</ul>
<h3 id="Language_Extensions">Language Extensions</h3><ul>
<li><a href="https://github.com/postcss/postcss-mixins">postcss-mixins</a> enables mixins more powerful than Sass’s,<br>defined within stylesheets or in JS.</li>
<li><a href="https://github.com/postcss/postcss-nested">postcss-nested</a> unwraps nested rules, as Sass does.</li>
<li><a href="https://github.com/davidtheclark/postcss-simple-extend">postcss-simple-extend</a> supports extending of silent classes,<br>like Sass’s <code>@extend</code>.</li>
<li><a href="https://github.com/postcss/postcss-simple-vars">postcss-simple-vars</a> supports for Sass-style variables.</li>
<li><a href="https://github.com/geddski/csstyle">csstyle</a> adds components workflow to your styles.</li>
</ul>
<h3 id="Optimizations">Optimizations</h3><ul>
<li><a href="https://github.com/borodean/postcss-assets">postcss-assets</a> allows you to simplify URLs, insert image dimensions,<br>and inline files.</li>
<li><a href="https://github.com/postcss/postcss-calc">postcss-calc</a> reduces <code>calc()</code> to values<br>(when expressions involve the same units).</li>
<li><a href="https://github.com/Ser-Gen/postcss-data-packer">postcss-data-packer</a> moves embedded Base64 data out of the stylesheet<br>and into a separate file.</li>
<li><a href="https://github.com/postcss/postcss-import">postcss-import</a> inlines the stylesheets referred to by <code>@import</code> rules.</li>
<li><a href="https://github.com/postcss/postcss-url">postcss-url</a> rebases or inlines <code>url()</code>s.</li>
<li><a href="https://github.com/hail2u/node-csswring">csswring</a> is a CSS minifier.</li>
<li><a href="https://github.com/AoDev/css-byebye">css-byebye</a> removes the CSS rules that you don’t want.</li>
<li><a href="https://github.com/hail2u/node-css-mqpacker">css-mqpacker</a> joins matching CSS media queries into a single statement.</li>
<li><a href="https://github.com/lexich/webpcss">webpcss</a> adds URLs for WebP images, so they can be used by browsers<br>that support WebP.</li>
</ul>
<h3 id="Shortcuts">Shortcuts</h3><ul>
<li><a href="https://github.com/postcss/postcss-easings">postcss-easings</a> replaces easing names from easings.net<br>with <code>cubic-bezier()</code> functions.</li>
<li><a href="https://github.com/postcss/postcss-size">postcss-size</a> adds a <code>size</code> shortcut that sets width and height<br>with one declaration.</li>
</ul>
<h3 id="Others">Others</h3><ul>
<li><a href="https://github.com/postcss/postcss-brand-colors">postcss-brand-colors</a> inserts company brand colors<br>in the <code>brand-colors</code> module.</li>
<li><a href="https://github.com/zaim/postcss-color-palette">postcss-color-palette</a> transforms CSS2 color keywords to a custom palette.</li>
<li><a href="https://github.com/hail2u/postcss-single-charset">postcss-single-charset</a> ensures that there is one<br>and only one <code>@charset</code> rule at the top of file.</li>
<li><a href="https://github.com/MohammadYounes/rtlcss">rtlcss</a> mirrors styles for right-to-left locales.</li>
</ul>
<h3 id="Analysis">Analysis</h3><ul>
<li><a href="https://github.com/necolas/postcss-bem-linter">postcss-bem-linter</a> lints CSS for conformance to SUIT CSS methodology.</li>
<li><a href="https://github.com/vovanbo/css2modernizr">css2modernizr</a> creates a Modernizr config file<br>that requires only the tests that your CSS uses.</li>
<li><a href="https://github.com/anandthakker/doiuse">doiuse</a> lints CSS for browser support, using data from Can I Use.</li>
<li><a href="https://github.com/davidtheclark/list-selectors">list-selectors</a> lists and categorizes the selectors used in your CSS,<br>for code review and analysis.</li>
</ul>
<h2 id="Usage">Usage</h2><h3 id="JavaScript_API">JavaScript API</h3><pre><code class="js"><span class="keyword">var</span> postcss   = <span class="built_in">require</span>(<span class="string">'postcss'</span>);
<span class="keyword">var</span> processor = postcss([<span class="built_in">require</span>(<span class="string">'cssnext'</span>), <span class="built_in">require</span>(<span class="string">'cssgrace'</span>)]);

<span class="keyword">var</span> result = processor.process(css, { from: <span class="string">'app.css'</span>, to: <span class="string">'app.out.css'</span> });
<span class="built_in">console</span>.log(result.css);
</code></pre>
<p>Read the <a href="https://github.com/postcss/postcss/blob/master/API.md#postcss-function">postcss function</a>, <a href="https://github.com/postcss/postcss/blob/master/API.md#postcss-class">processor</a>, and <a href="https://github.com/postcss/postcss/blob/master/API.md#result-class">Result</a> API docs for more details.</p>
<h3 id="Source_Maps">Source Maps</h3><p>PostCSS has great <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">source maps</a> support. It can read and interpret maps<br>from previous transformation steps, autodetect the format that you expect,<br>and output both external and inline maps.</p>
<p>To ensure that you generate an accurate source map, you must indicate the input<br>and output CSS files paths — using the options <code>from</code> and <code>to</code>, respectively.</p>
<p>To generate a new source map with the default options, simply set <code>map: true</code>.<br>This will generate an inline source map that contains the source content.<br>If you don’t want the map inlined, you can use set <code>map.inline: false</code>.</p>
<pre><code class="js"><span class="keyword">var</span> result = processor.process(css, {
    from: <span class="string">'main.css'</span>,
    to:   <span class="string">'main.out.css'</span>,
    map: { inline: <span class="literal">false</span> },
});

result.map <span class="comment">//=&gt; '{"version":3,"file":"main.out.css","sources":["main.css"],"names":[],"mappings":"AAAA,KAAI"}'</span>
</code></pre>
<p>If PostCSS finds source maps from a previous transformation,<br>it will automatically update that source map with the same options.</p>
<pre><code class="js"><span class="comment">// main.sass.css has an annotation comment with a link to main.sass.css.map</span>
<span class="keyword">var</span> result = minifier.process(css, { from: <span class="string">'main.sass.css'</span>, to: <span class="string">'main.min.css'</span> });
result.map <span class="comment">//=&gt; Source map from main.sass to main.min.css</span>
</code></pre>
<p>If you want more control over source map generation, you can define the <code>map</code><br>option as an object with the following parameters:</p>
<ul>
<li><p><code>inline</code> boolean: indicates that the source map should be embedded<br>in the output CSS as a Base64-encoded comment. By default it is <code>true</code>.<br>But if all previous maps are external, not inline, PostCSS will not embed<br>the map even if you do not set this option.</p>
<p>If you have an inline source map, the <code>result.map</code> property will be empty,<br>as the source map will be contained within the text of <code>result.css</code>.</p>
</li>
<li><p><code>prev</code> string, object or boolean: source map content from<br>a previous processing step (for example, Sass compilation).<br>PostCSS will try to read the previous source map automatically<br>(based on comments within the source CSS), but you can use this option<br>to identify it manually. If desired, you can omit the previous map<br>with <code>prev: false</code>.</p>
</li>
<li><p><code>sourcesContent</code> boolean: indicates that PostCSS should set the origin<br>content (for example, Sass source) of the source map. By default it is <code>true</code>.<br>But if all previous maps do not contain sources content, PostCSS will also<br>leave it out even if you do not set this option.</p>
</li>
<li><p><code>annotation</code> boolean or string: indicates that PostCSS should add annotation<br>comments to the CSS. By default, PostCSS will always add a comment with a path<br>to the source map. But if the input CSS does not have any annotation<br>comment, PostCSS will omit it, too, even if you do not set this option.</p>
<p>By default, PostCSS presumes that you want to save the source map as<br><code>opts.to + &#39;.map&#39;</code> and will use this path in the annotation comment.<br>But you can set another path by providing a string value for <code>annotation</code>.</p>
<p>If you have set <code>inline: true</code>, annotation cannot be disabled.</p>
</li>
</ul>
<h3 id="Safe_Mode">Safe Mode</h3><p>If you provide a <code>safe: true</code> option to the <code>process</code> or <code>parse</code> methods,<br>PostCSS will try to correct any syntax errors that it finds in the CSS.</p>
<pre><code class="js">postcss.parse(<span class="string">'a {'</span>);                 <span class="comment">// will throw "Unclosed block"</span>
postcss.parse(<span class="string">'a {'</span>, { safe: <span class="literal">true</span> }); <span class="comment">// will return CSS root for a {}</span>
</code></pre>
<p>This is useful for legacy code filled with hacks. Another use-case<br>is interactive tools with live input — for example,<br>the <a href="http://jsfiddle.net/simevidas/udyTs/show/light/">Autoprefixer demo</a>.</p>
<h2 id="How_to_Develop_PostCSS_Plugin">How to Develop PostCSS Plugin</h2><ul>
<li><a href="https://github.com/postcss/postcss/blob/master/API.md">PostCSS API</a></li>
<li><a href="https://github.com/postcss/postcss-plugin-boilerplate">Plugin Boilerplate</a></li>
</ul>
